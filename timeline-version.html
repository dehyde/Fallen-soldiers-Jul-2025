<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fallen Soldiers - Timeline Memorial</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Handjet:wght@100..900&family=Heebo:wght@100..900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Heebo', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #333;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .stats-header {
            display: none;
        }

        .total-count {
            font-size: 3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .count-label {
            font-size: 1.2em;
            opacity: 0.7;
            color: #666;
        }

        .names-container {
            position: fixed;
            top: 20px;
            bottom: 60px;
            left: 5px;
            right: 5px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            align-content: center;
            gap: 3.3px;
            overflow: hidden;
            justify-content: center;
            direction: rtl;
        }

        .soldier-name {
            font-family: 'Handjet', monospace;
            font-size: 1px; /* will be dynamically calculated */
            font-weight: 400;
            padding: 2px 4px;
            background: rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            line-height: 1.1; /* This matches the calculation */
            text-decoration: none;
            -webkit-text-decoration-line: none;
            text-decoration-line: none;
            font-feature-settings: normal;
        }

        .soldier-name:hover {
            background: rgba(0,0,0,0.3);
            transform: scale(1.05);
        }

        .soldier-name.fallen {
            opacity: 0.2;
            background: rgba(255,100,100,0.1);
        }

        .soldier-name.alive {
            opacity: 1;
            background: rgba(0,56,168,0.9);
            color: white;
        }

        .soldier-name.dying {
            opacity: 1;
            background: rgba(139, 0, 0, 0.8) !important; /* Dark red background */
            color: rgb(255, 69, 69) !important; /* Bright red text */
            font-weight: bold;
            z-index: 100;
            position: relative;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .timeline-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(15px);
            /* Remove top border */
            /* border-top: 2px solid rgba(0,0,0,0.3); */
            /* Remove shadow */
            /* box-shadow: 0 -4px 20px rgba(0,0,0,0.1); */
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 10px 50px;
            z-index: 100;
        }

        .timeline-track {
            position: relative;
            height: 1px;
            background: #333;
            border-radius: 0;
            margin: 5px 0 15px 0;
            border: none;
        }

        .timeline-progress {
            position: absolute;
            top: -1px;
            right: 0;
            height: 4px;
            width: 0%;
            background: #000;
            border-radius: 0;
            transition: none;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-axis {
            position: absolute;
            top: 5px;
            left: 0;
            right: 0;
            height: 10px;
            z-index: 5;
            pointer-events: none;
        }

        .timeline-tick {
            position: absolute;
            width: 1px;
            height: 2px;
            background: rgba(0,0,0,0.4);
            top: 0;
        }

        .timeline-tick.major {
            height: 3px;
            width: 1px;
            background: rgba(0,0,0,0.6);
        }

        .timeline-date-label {
            position: absolute;
            top: 5px;
            font-size: 8px;
            color: #666;
            white-space: nowrap;
            transform: translateX(-50%);
            font-weight: 500;
        }

        .timeline-slider {
            width: 100%;
            height: 4px;
            background: transparent;
            outline: none;
            position: absolute;
            top: 0;
            cursor: pointer;
            -webkit-appearance: none;
            z-index: 20;
        }

        .timeline-slider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333;
            border: none;
            outline: none;
        }

        #timelineSlider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #333 0%, #555 100%);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            opacity: 0;
            z-index: 30;
        }

        .timeline-container:hover .timeline-slider::-webkit-slider-thumb {
            opacity: 1;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(0,0,0,0.2);
        }

        .timeline-slider::-moz-range-track {
            height: 2px;
            background: #333;
            border: none;
            outline: none;
        }

        #timelineSlider::-moz-range-track {
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        #timelineSlider {
            background: transparent !important;
            border: none !important;
            outline: none !important;
        }

        .timeline-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #333 0%, #555 100%);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .timeline-container:hover .timeline-slider::-moz-range-thumb {
            opacity: 1;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }

        .timeline-handle-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 50;
            pointer-events: none;
            opacity: 1;
            transform: translateX(-50%);
            top: -65px;
            font-family: 'Heebo', sans-serif;
            text-align: center;
            line-height: 1.3;
        }

        .timeline-handle-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            transition: left 0.1s ease;
        }


        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.5em;
        }

        .draggable-container {
            position: fixed;
            top: 50%;
            right: 100px;
            transform: translateY(-50%);
            width: 280px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(15px);
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 200;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
        }

        .draggable-container:hover {
            cursor: grab;
            background: rgba(250,250,250,0.95);
        }

        .draggable-container:active {
            cursor: grabbing;
        }


        .draggable-container.dragging {
            box-shadow: 0 20px 64px rgba(0,0,0,0.15);
            transition: box-shadow 0.1s ease;
        }


        .draggable-content {
            padding: 20px;
            cursor: inherit;
            direction: rtl;
            text-align: right;
        }

        .content-text {
            font-size: 1.1em;
            line-height: 1.4;
            color: #333;
            margin-bottom: 20px;
            font-family: 'Heebo', sans-serif;
            cursor: inherit;
        }

        .cta-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
            cursor: grab;
        }

        .cta-buttons:hover {
            cursor: grab;
        }

        .cta-buttons:active {
            cursor: grabbing;
        }

        .cta-primary {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 2px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
        }

        .cta-primary:hover {
            background: #333333;
            transform: translateY(-1px);
        }

        .cta-tertiary {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 2px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
        }

        .cta-tertiary:hover {
            background: rgba(0,0,0,0.05);
            border-color: #bbb;
        }

        .timeline-tooltip {
            /* Reset inherited styles */
            all: initial;
            /* Apply our intended styles */
            position: absolute;
            background: rgba(0, 0, 0, 0.9) !important;
            color: white !important;
            padding: 12px 16px !important;
            border-radius: 4px !important;
            border-top-left-radius: 4px !important;
            border-top-right-radius: 4px !important;
            border-bottom-left-radius: 4px !important;
            border-bottom-right-radius: 4px !important;
            font-size: 13px !important;
            max-width: 400px !important;
            min-width: 250px !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            direction: rtl !important;
            text-align: right !important;
            font-family: 'Heebo', sans-serif !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            line-height: 1.4 !important;
            backdrop-filter: blur(10px) !important;
            display: block !important;
        }

        .timeline-tooltip strong {
            display: block !important;
            margin-bottom: 8px !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            font-family: 'Heebo', sans-serif !important;
        }
    </style>
</head>
<body>
    <div class="draggable-container" id="draggableContainer">
        <div class="draggable-content">
            <div class="content-text" id="contentText">
                טוען נתונים...
            </div>
            <div class="cta-buttons">
                <button class="cta-tertiary" id="ctaBack">חזור</button>
                <button class="cta-primary" id="ctaContinue">המשך</button>
            </div>
        </div>
    </div>

    <div class="names-container" id="namesContainer">
        <div class="loading">Loading memorial data...</div>
    </div>

    <div class="timeline-container">
        <div class="timeline-track">
            <div class="timeline-progress" id="timelineProgress"></div>
            <input type="range" id="timelineSlider" class="timeline-slider" min="0" max="643" value="0">
            <div class="timeline-axis" id="timelineAxis"></div>
            <div class="timeline-handle-tooltip" id="timelineTooltip">
                <div id="tooltipDate">29/07/25</div>
                <div id="tooltipAlive">0 soldiers alive</div>
            </div>
        </div>
        <!-- Removed timeline labels -->
    </div>

    <script>
        class NarrativeEngine {
            constructor(timeline) {
                this.timeline = timeline;
                this.narrativePoints = [];
                this.currentPointId = 'loaded';
                this.isNavigating = false; // Flag to prevent conflicting navigation
                this.currentAnimationId = null; // Track current animation
            }

            async loadNarrative() {
                try {
                    const response = await fetch('narrative.csv');
                    const csvText = await response.text();
                    console.log('CSV loaded:', csvText.substring(0, 200) + '...');
                    this.parseNarrativeCsv(csvText);
                    console.log(`Loaded ${this.narrativePoints.length} narrative points:`, this.narrativePoints);
                } catch (error) {
                    console.error('Error loading narrative:', error);
                    // Fallback content if CSV fails to load
                    document.getElementById('contentText').innerHTML = 'שגיאה בטעינת הנתונים';
                }
            }

            parseNarrativeCsv(csvText) {
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.parseCsvLine(line);
                    if (values.length === headers.length) {
                        const point = {};
                        headers.forEach((header, index) => {
                            point[header.trim()] = values[index].trim();
                        });
                        this.narrativePoints.push(point);
                    }
                }
            }

            parseCsvLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current);
                return result;
            }

            // Advanced placeholder parsing
            parseTemplate(content) {
                return content.replace(/\{\{([^}]+)\}\}/g, (match, placeholder) => {
                    return this.resolvePlaceholder(placeholder.trim());
                });
            }

            resolvePlaceholder(placeholder) {
                const [type, ...params] = placeholder.split(':');
                
                switch(type) {
                    case 'total_count':
                        return `<strong>${this.timeline.soldiers.filter(s => s.death_date >= this.timeline.oct26Date).length}</strong>`;
                    
                    case 'alive_count':
                        return `<strong>${this.getAliveCount()}</strong>`;
                    
                    case 'fallen_count':
                        return `<strong>${this.getFallenCount()}</strong>`;
                    
                    case 'fallen_since_date':
                        const days = parseInt(params[0]) || 0;
                        return `<strong>${this.getFallenSince(days)}</strong>`;
                    
                    case 'fallen_on_date':
                        const targetDays = parseInt(params[0]) || 0;
                        return `<strong>${this.getFallenOnDate(targetDays)}</strong>`;
                    
                    case 'date_hebrew':
                        const daysBack = parseInt(params[0]) || 0;
                        return this.formatHebrewDate(daysBack);
                    
                    case 'days_since_start':
                        return `<strong>${Math.round((this.timeline.currentEndDate - this.timeline.oct26Date) / (1000 * 60 * 60 * 24))}</strong>`;
                    
                    case 'percentage_fallen':
                        const total = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.oct26Date).length;
                        const fallen = this.getFallenCount();
                        return `<strong>${Math.round((fallen / total) * 100)}</strong>`;
                    
                    case 'soldier_name':
                        return this.getSoldierName(params[0]);
                    
                    case 'months_since_start':
                        return `<strong>${this.getMonthsSinceStart()}</strong>`;
                    
                    case 'average_monthly_casualties':
                        return `<strong>${this.getAverageMonthlycasualties()}</strong>`;
                    
                    case 'days_since_last_deaths':
                        return `<strong>${this.getDaysSinceLastDeaths()}</strong>`;
                    
                    case 'last_deaths_text':
                        return this.getLastDeathsText();
                    
                    case 'war_continuation_message':
                        return this.getWarContinuationMessage();
                    
                    case 'political_event_date':
                        return this.getPoliticalEventDate();
                    
                    case 'coalition_threat_date':
                        return this.getCoalitionThreatDate();
                    
                    case 'coalition_threat_person':
                        return this.getCoalitionThreatPerson();
                    
                    case 'coalition_threats_count':
                        return `<strong>${this.getCoalitionThreatsCount()}</strong>`;
                    
                    case 'days_since_decision':
                        return `<strong>${this.getDaysSinceDecision()}</strong>`;
                    
                    case 'could_be_alive_count':
                        return `<strong>${this.getCouldBeAliveCount()}</strong>`;
                    
                    case 'random_names':
                        return this.getRandomNames();
                    
                    case 'fallen_since_january':
                        return `<strong>${this.getFallenSinceJanuary()}</strong>`;
                    
                    case 'fallen_last_month':
                        return `<strong>${this.getFallenLastMonth()}</strong>`;
                    
                    case 'last_month_names':
                        return this.getLastMonthNames();
                    
                    case 'last_month_remaining_count':
                        return `<strong>${this.getLastMonthRemainingCount()}</strong>`;
                    
                    default:
                        return `{{${placeholder}}}`;
                }
            }

            getAliveCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date && 
                    s.death_date > this.timeline.currentEndDate
                ).length;
            }

            getFallenCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date && 
                    s.death_date <= this.timeline.currentEndDate
                ).length;
            }

            getFallenSince(daysBack) {
                const sinceDate = new Date(this.timeline.currentEndDate);
                sinceDate.setDate(sinceDate.getDate() - daysBack);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date && 
                    s.death_date <= this.timeline.currentEndDate &&
                    s.death_date >= sinceDate
                ).length;
            }

            getFallenOnDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const startOfDay = new Date(targetDate);
                startOfDay.setHours(0, 0, 0, 0);
                const endOfDay = new Date(targetDate);
                endOfDay.setHours(23, 59, 59, 999);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= startOfDay && 
                    s.death_date <= endOfDay
                ).length;
            }

            formatHebrewDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${targetDate.getDate()} ${hebrewMonths[targetDate.getMonth()]} ${targetDate.getFullYear()}`;
            }

            getSoldierName(type) {
                const relevantSoldiers = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.oct26Date);
                
                switch(type) {
                    case 'first':
                        const first = relevantSoldiers.sort((a, b) => a.death_date - b.death_date)[0];
                        return first ? `<strong>${first.name}</strong>` : 'לא ידוע';
                    
                    case 'latest':
                        const latest = relevantSoldiers
                            .filter(s => s.death_date <= this.timeline.currentEndDate)
                            .sort((a, b) => b.death_date - a.death_date)[0];
                        return latest ? `<strong>${latest.name}</strong>` : 'לא ידוע';
                    
                    default:
                        return 'לא ידוע';
                }
            }

            getMonthsSinceStart() {
                const startDate = this.timeline.oct26Date;
                const currentDate = this.timeline.todayDate; // Use today's date instead of timeline date
                
                const yearDiff = currentDate.getFullYear() - startDate.getFullYear();
                const monthDiff = currentDate.getMonth() - startDate.getMonth();
                const dayDiff = currentDate.getDate() - startDate.getDate();
                
                let totalMonths = yearDiff * 12 + monthDiff;
                
                // Add partial month if we've passed the start day
                if (dayDiff >= 0) {
                    totalMonths += Math.round(dayDiff / 30 * 10) / 10; // Round to 1 decimal
                }
                
                return Math.round(totalMonths);
            }

            getAverageMonthlycasualties() {
                const monthsSinceStart = this.getMonthsSinceStart();
                const totalFallen = this.getFallenCount();
                
                if (monthsSinceStart === 0) return 0;
                
                return Math.round(totalFallen / monthsSinceStart);
            }

            getDaysSinceLastDeaths() {
                // Use today's date, not currentEndDate, for this calculation
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                // Find the most recent death date from all soldiers
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Calculate days from today back to most recent death
                return Math.round((this.timeline.todayDate - latestDeathDate) / (1000 * 60 * 60 * 24));
            }

            getLastDeathsText() {
                // Use all soldiers to find the most recent deaths (up to today)
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date
                );
                
                if (relevantSoldiers.length === 0) return '';
                
                // Find soldiers who died on the most recent death date
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                const soldiersOnLatestDate = relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000 // Same day
                );
                
                if (soldiersOnLatestDate.length === 1) {
                    return `נהרג <strong>${soldiersOnLatestDate[0].name}</strong>`;
                } else if (soldiersOnLatestDate.length === 2) {
                    return `נהרגו <strong>${soldiersOnLatestDate[0].name}</strong> ו-<strong>${soldiersOnLatestDate[1].name}</strong>`;
                } else if (soldiersOnLatestDate.length > 2) {
                    const names = soldiersOnLatestDate.slice(0, -1).map(s => `<strong>${s.name}</strong>`).join(', ');
                    const lastName = `<strong>${soldiersOnLatestDate[soldiersOnLatestDate.length - 1].name}</strong>`;
                    return `נהרגו ${names} ו-${lastName}`;
                }
                
                return '';
            }

            getWarContinuationMessage() {
                const lastDeathsCount = this.getLastDeathsOnMostRecentDate();
                
                if (lastDeathsCount === 1) {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הוא היה חוזר הביתה למשפחה שלו';
                } else {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הם היו חוזרים הביתה למשפחות שלהם';
                }
            }

            getLastDeathsOnMostRecentDate() {
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.oct26Date && 
                    s.death_date <= this.timeline.currentEndDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                return relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000
                ).length;
            }

            getPoliticalEventDate() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 'תאריך לא ידוע';
                
                const eventDate = new Date(netanyahuEvent.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatDate() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'תאריך לא ידוע';
                
                const firstThreat = threatEvents[0];
                const eventDate = new Date(firstThreat.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatPerson() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'לא ידוע';
                
                const firstThreat = threatEvents[0];
                if (firstThreat.id.includes('smotrich')) {
                    return 'סמוטריץ\'';
                } else if (firstThreat.id.includes('ben_gvir')) {
                    return 'בן גביר';
                }
                
                return 'לא ידוע';
            }

            getCoalitionThreatsCount() {
                return this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).length;
            }

            getDaysSinceDecision() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const eventDate = new Date(netanyahuEvent.date);
                return Math.round((this.timeline.todayDate - eventDate) / (1000 * 60 * 60 * 24));
            }

            getCouldBeAliveCount() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const decisionDate = new Date(netanyahuEvent.date);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date > decisionDate && 
                    s.death_date >= this.timeline.oct26Date
                ).length;
            }

            getRandomNames() {
                const couldBeAliveSoldiers = this.timeline.soldiers.filter(s => {
                    const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                        e.id === 'netanyahu_considers_ceasefire'
                    );
                    
                    if (!netanyahuEvent) return false;
                    
                    const decisionDate = new Date(netanyahuEvent.date);
                    return s.death_date > decisionDate && s.death_date >= this.timeline.oct26Date;
                });
                
                // Select 3 random names and make them bold
                const shuffled = couldBeAliveSoldiers.sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, 3);
                
                return selected.map(s => `- <strong>${s.name}</strong>`).join('<br>');
            }

            getFallenSinceJanuary() {
                const januaryDate = new Date('2024-01-07');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= januaryDate && 
                    s.death_date >= this.timeline.oct26Date
                ).length;
            }

            getFallenLastMonth() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.oct26Date
                ).length;
            }

            getLastMonthNames() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.oct26Date
                );
                
                // Get first 3 names and make them bold
                const names = lastMonthSoldiers.slice(0, 3).map(s => `<strong>${s.name}</strong>`);
                return names.join(', ');
            }

            getLastMonthRemainingCount() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.oct26Date
                );
                
                // Return count of remaining soldiers beyond the first 3
                return Math.max(0, lastMonthSoldiers.length - 3);
            }

            // Navigation methods
            getCurrentPoint() {
                return this.narrativePoints.find(p => p.id === this.currentPointId) || this.narrativePoints[0];
            }

            navigateToPoint(pointId) {
                const point = this.narrativePoints.find(p => p.id === pointId);
                if (!point) return;
                
                // Cancel any ongoing animation immediately (allows override)
                if (this.currentAnimationId) {
                    clearTimeout(this.currentAnimationId);
                    this.currentAnimationId = null;
                    console.log('Previous navigation cancelled, starting new one');
                }
                
                this.isNavigating = true;
                this.currentPointId = pointId;
                
                // Get current and target timeline points
                const currentTimelinePoint = parseInt(document.getElementById('timelineSlider').value);
                let targetTimelinePoint = parseInt(point.timeline_point);
                
                // Special handling for recent_deaths: use actual days since last deaths
                if (pointId === 'recent_deaths') {
                    targetTimelinePoint = this.timeline.narrative.getDaysSinceLastDeaths();
                }
                
                // Update content immediately
                this.updateNarrativeContent();
                
                // Start gradual animation if there's a difference
                if (currentTimelinePoint !== targetTimelinePoint) {
                    this.animateToTimelinePoint(currentTimelinePoint, targetTimelinePoint);
                } else {
                    // If already at target, just update visualization and unlock navigation
                    this.timeline.updateVisualization();
                    this.isNavigating = false;
                }
            }

            animateToTimelinePoint(startPoint, endPoint) {
                const slider = document.getElementById('timelineSlider');
                const progressBar = document.getElementById('timelineProgress');
                
                // Determine direction and speed
                const isMovingBack = endPoint > startPoint; // Moving back in time (higher days back)
                const isMovingForward = endPoint < startPoint; // Moving forward in time (lower days back)
                
                // Set different speeds: slower for forward, faster for backward
                const forwardSpeed = 25; // ms per day when moving forward in time (SLOWER)
                const backwardSpeed = 15;  // ms per day when moving back in time (SLOWER)
                
                const speed = isMovingForward ? forwardSpeed : backwardSpeed;
                const step = isMovingBack ? 1 : -1;
                
                let current = startPoint;
                
                const animate = () => {
                    // Check if animation was cancelled
                    if (!this.isNavigating) {
                        console.log('Animation cancelled during execution');
                        return;
                    }
                    
                    // Update current timeline point
                    current += step;
                    
                    // Update slider
                    slider.value = current;
                    
                    // Update timeline progress
                    const progress = ((643 - current) / 643) * 100;
                    progressBar.style.width = progress + '%';
                    
                    // Update timeline date
                    const newEndDate = new Date(this.timeline.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - current);
                    this.timeline.currentEndDate = newEndDate;
                    
                    // Update tooltip during animation
                    this.timeline.updateTooltip(current, newEndDate);
                    
                    // Update visualization
                    this.timeline.updateVisualization();
                    
                    // Check if we've reached the target
                    const reachedTarget = isMovingBack ? (current >= endPoint) : (current <= endPoint);
                    
                    if (!reachedTarget) {
                        // Continue animation with tracked timeout
                        this.currentAnimationId = setTimeout(animate, speed);
                    } else {
                        // Animation complete - unlock navigation
                        this.isNavigating = false;
                        this.currentAnimationId = null;
                    }
                };
                
                // Start animation with tracked timeout
                this.currentAnimationId = setTimeout(animate, speed);
            }

            updateNarrativeContent() {
                const point = this.getCurrentPoint();
                if (!point) return;
                
                const contentText = document.getElementById('contentText');
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');
                
                // Parse and update content
                const parsedContent = this.parseTemplate(point.content_hebrew);
                contentText.innerHTML = parsedContent;
                
                // Update buttons
                ctaContinue.textContent = point.cta_continue_he || 'המשך';
                ctaBack.textContent = point.cta_back_he || 'חזור';
                
                // Show/hide buttons based on navigation - hide back button for first narrative point
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                ctaBack.style.display = (currentIndex > 0) ? 'inline-block' : 'none';
                ctaContinue.style.display = this.getNextPoint() ? 'inline-block' : 'none';
            }

            getNextPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex < this.narrativePoints.length - 1 ? this.narrativePoints[currentIndex + 1] : null;
            }

            getPrevPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex > 0 ? this.narrativePoints[currentIndex - 1] : null;
            }

        }

        class TimelineMemorial {
            constructor() {
                this.soldiers = [];
                this.timelineEvents = [];
                this.oct26Date = new Date('2023-10-26');
                this.todayDate = new Date();
                this.currentEndDate = new Date(); // Start at today so all soldiers are "fallen"
                this.navigationState = 'month_back'; // 'month_back' or 'today'
                this.narrative = new NarrativeEngine(this);
                this.dyingTimeouts = new Map(); // Track timeouts for performance
                this.init();
            }

            async init() {
                await this.loadData();
                await this.loadTimelineEvents(); // Load timeline events
                await this.narrative.loadNarrative(); // Load narrative data
                this.setupEventListeners();
                this.generateTimelineAxis();
                this.renderAllNames();
                
                // Initialize with war overview narrative point (at today - 0 days back)
                this.narrative.navigateToPoint('war_overview');
                
                // Initialize timeline progress bar (show full timeline initially)
                const initialProgress = ((643 - 0) / 643) * 100;
                document.getElementById('timelineProgress').style.width = initialProgress + '%';
                
                // Recalculate font size after timeline changes with buffer
                setTimeout(() => {
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.oct26Date);
                    console.log('Forcing font recalculation for', relevantSoldiers.length, 'soldiers');
                    
                    // Force container dimensions update
                    const container = document.getElementById('namesContainer');
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    console.log('New container dimensions:', availableWidth, 'x', availableHeight);
                    
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 200);
            }

            async loadData() {
                try {
                    const response = await fetch('idf-url-increment.csv');
                    const csvText = await response.text();
                    this.parseCsvData(csvText);
                    console.log(`Loaded ${this.soldiers.length} soldiers`);
                    
                    if (this.soldiers.length > 0) {
                        const dates = this.soldiers.map(s => s.death_date).sort((a,b) => a - b);
                        console.log('Date range:', dates[0].toLocaleDateString(), 'to', dates[dates.length-1].toLocaleDateString());
                        
                        const afterOct26 = this.soldiers.filter(s => s.death_date >= this.oct26Date);
                        console.log(`${afterOct26.length} soldiers died after Oct 26, 2023`);
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    document.getElementById('namesContainer').innerHTML = '<div class="loading">Error loading memorial data</div>';
                }
            }

            async loadTimelineEvents() {
                try {
                    console.log('Attempting to load timeline-events.csv...');
                    const response = await fetch('timeline-events.csv');
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('CSV text loaded:', csvText.substring(0, 200) + '...');
                    this.parseTimelineEvents(csvText);
                    console.log(`Loaded ${this.timelineEvents.length} timeline events`);
                } catch (error) {
                    console.error('Error loading timeline events:', error);
                    // Create test events if CSV fails to load
                    console.log('Creating test timeline events...');
                    this.timelineEvents = [
                        {
                            id: 'test_event',
                            date: '2025-07-29',
                            title_hebrew: 'אירוע מבחן',
                            description_hebrew: 'זהו אירוע מבחן',
                            eventDate: new Date('2025-07-29')
                        }
                    ];
                    console.log('Test events created:', this.timelineEvents.length);
                }
            }

            parseCsvData(csvText) {
                const lines = csvText.split('\n');
                let currentRecord = '';
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.match(/^"\d+-\d+"/)) {
                        if (currentRecord) {
                            const soldier = this.parseCsvLine(currentRecord);
                            if (soldier && soldier.death_date) {
                                this.soldiers.push(soldier);
                            }
                        }
                        currentRecord = line;
                    } else {
                        currentRecord += ' ' + line;
                    }
                }
                
                if (currentRecord) {
                    const soldier = this.parseCsvLine(currentRecord);
                    if (soldier && soldier.death_date) {
                        this.soldiers.push(soldier);
                    }
                }
            }

            parseCsvLine(line) {
                const deathDateField = line;
                
                const hebrewMonths = {
                    'באוקטובר': 9,
                    'בנובמבר': 10,
                    'בדצמבר': 11,
                    'בינואר': 0,
                    'בפברואר': 1,
                    'במרץ': 2,
                    'באפריל': 3,
                    'במאי': 4,
                    'ביוני': 5,
                    'ביולי': 6,
                    'באוגוסט': 7,
                    'בספטמבר': 8
                };

                let deathDate = null;
                let matchedDateStr = '';
                
                for (const [hebrewMonth, monthIndex] of Object.entries(hebrewMonths)) {
                    const pattern = new RegExp(`(\\d{1,2}) ${hebrewMonth} (\\d{4})`);
                    const match = deathDateField.match(pattern);
                    if (match) {
                        const day = parseInt(match[1]);
                        const year = parseInt(match[2]);
                        deathDate = new Date(year, monthIndex, day);
                        matchedDateStr = match[0];
                        break;
                    }
                }

                if (!deathDate) return null;

                // Simple approach: extract from the whole line using simpler patterns
                let name = 'Unknown';
                let rank = 'Unknown'; 
                let unit = 'Unknown';
                
                // Extract name: look for pattern with Hebrew text followed by ז"ל
                const namePattern = /\s+([א-ת\s']+)\s+ז""ל/;
                const nameMatch = line.match(namePattern);
                if (nameMatch) {
                    const fullName = nameMatch[1].trim();
                    // Remove rank prefix if it exists
                    const cleanName = fullName.replace(/^(רס""[א-ת]+|סמל|סרן|רב""ט|סמ""ר|רס""ל|רס""ם)\s+/, '');
                    name = cleanName.trim();
                }
                
                // Extract rank: look for common rank patterns at start
                const rankPattern = /","(רס""[א-ת\(\)\\s]+|סמל|סרן|רב""ט|סמ""ר|רס""ל|רס""ם[^"]*)/;
                const rankMatch = line.match(rankPattern);
                if (rankMatch) {
                    rank = rankMatch[1].trim();
                }
                
                // Extract unit: appears after ז"ל and before נפל
                const unitPattern = /ז""ל","([^"]+)","([^"]+)","נפל/;
                const unitMatch = line.match(unitPattern);  
                if (unitMatch) {
                    unit = unitMatch[2].trim();
                }

                return {
                    name: name,
                    rank: rank,
                    unit: unit,
                    death_date: deathDate,
                    death_date_string: matchedDateStr
                };
            }

            parseTimelineEvents(csvText) {
                const lines = csvText.split('\n');
                const headers = this.narrative.parseCsvLine(lines[0]);
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.narrative.parseCsvLine(line);
                    const event = {};
                    
                    headers.forEach((header, index) => {
                        event[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    
                    // Parse date
                    if (event.date) {
                        event.eventDate = new Date(event.date);
                        console.log('Timeline event parsed:', event.title_hebrew, 'Date:', event.eventDate);
                    }
                    
                    this.timelineEvents.push(event);
                }
                console.log('Total timeline events loaded:', this.timelineEvents.length);
            }

            generateTimelineAxis() {
                const axisContainer = document.getElementById('timelineAxis');
                axisContainer.innerHTML = '';
                
                const startDate = new Date('2023-10-26');
                const endDate = new Date();
                const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)); // From today back to Oct 26, 2023
                
                // Generate major ticks every 3 months and minor ticks every month
                const majorTickMonths = [0, 3, 6, 9, 12, 15, 18, 21]; // Every 3 months
                const minorTickMonths = [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20]; // Every month
                
                // Calculate date positions
                const monthsTotal = 21; // Approximately 21 months from Oct 2023 to Jul 2025
                
                // Major ticks with labels
                majorTickMonths.forEach(monthOffset => {
                    if (monthOffset <= monthsTotal) {
                        const tickDate = new Date(startDate);
                        tickDate.setMonth(tickDate.getMonth() + monthOffset);
                        
                        const position = ((monthsTotal - monthOffset) / monthsTotal) * 100;
                        
                        // Create tick mark
                        const tick = document.createElement('div');
                        tick.className = 'timeline-tick major';
                        tick.style.left = position + '%';
                        axisContainer.appendChild(tick);
                        
                        // Create date label
                        const label = document.createElement('div');
                        label.className = 'timeline-date-label';
                        label.style.left = position + '%';
                        label.textContent = tickDate.toLocaleDateString('en-US', { 
                            month: 'short', 
                            year: '2-digit' 
                        });
                        axisContainer.appendChild(label);
                    }
                });
                
                // Minor ticks
                minorTickMonths.forEach(monthOffset => {
                    if (monthOffset <= monthsTotal) {
                        const position = ((monthsTotal - monthOffset) / monthsTotal) * 100;
                        
                        const tick = document.createElement('div');
                        tick.className = 'timeline-tick';
                        tick.style.left = position + '%';
                        axisContainer.appendChild(tick);
                    }
                });

                // Add timeline events markers
                console.log('Adding timeline event markers, total events:', this.timelineEvents.length);
                console.log('Timeline range:', startDate.toLocaleDateString(), 'to', endDate.toLocaleDateString());
                
                
                this.timelineEvents.forEach(event => {
                    console.log('Processing event:', event.title_hebrew, 'Date:', event.eventDate);
                    if (event.eventDate) {
                        // Calculate position based on date (0% = endDate/today, 100% = startDate/oldest)
                        const daysDiff = Math.floor((endDate - event.eventDate) / (1000 * 60 * 60 * 24));
                        const position = (daysDiff / totalDays) * 100;
                        console.log(`Event position: ${position}% (${daysDiff} days from start, total days: ${totalDays})`);
                        
                        if (position >= 0 && position <= 100) {
                            // Create event marker
                            const marker = document.createElement('div');
                            marker.className = 'timeline-event-marker';
                            marker.style.position = 'absolute';
                            marker.style.left = position + '%';
                            marker.style.top = '0px';
                            marker.style.width = '8px';
                            marker.style.height = '8px';
                            marker.style.transform = 'translateX(-50%)'; // Center on position
                            // Set color based on category
                            let markerColor = '#ff4444'; // default red
                            switch(event.category) {
                                case 'military': markerColor = '#cc0000'; break; // dark red
                                case 'political': markerColor = '#ff4444'; break; // red  
                                case 'diplomatic': markerColor = '#0066cc'; break; // blue
                                case 'legal': markerColor = '#9900cc'; break; // purple
                                default: markerColor = '#666666'; // gray
                            }
                            marker.style.background = markerColor;
                            marker.style.border = '2px solid #ffffff';
                            marker.style.borderRadius = '50%';
                            marker.style.cursor = 'pointer';
                            marker.style.zIndex = '100';
                            // Remove shadow
                            // marker.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            marker.style.pointerEvents = 'auto';
                            
                            // Create custom immediate tooltip
                            let currentTooltip = null;
                            
                            marker.onmouseenter = (e) => {
                                // Remove any existing tooltips
                                document.querySelectorAll('.timeline-tooltip').forEach(t => t.remove());
                                
                                // Scale up marker
                                marker.style.transform = 'translateX(-50%) scale(1.5)';
                                marker.style.zIndex = '200';
                                
                                // Create tooltip
                                const tooltip = document.createElement('div');
                                tooltip.className = 'timeline-tooltip';
                                tooltip.innerHTML = `<strong>${event.title_hebrew}</strong>${event.description_hebrew}`;
                                currentTooltip = tooltip;
                                
                                // Append to body and set initial position
                                document.body.appendChild(tooltip);
                                tooltip.style.position = 'fixed';
                                tooltip.style.visibility = 'hidden';
                                tooltip.style.left = '0px';
                                tooltip.style.top = '0px';
                                
                                // Get marker position
                                const markerRect = marker.getBoundingClientRect();
                                const screenWidth = window.innerWidth;
                                
                                // Use setTimeout to ensure CSS is fully applied and text is wrapped
                                setTimeout(() => {
                                    // Get tooltip dimensions after everything is rendered
                                    const tooltipRect = tooltip.getBoundingClientRect();
                                    console.log('Tooltip dimensions:', tooltipRect.width, 'x', tooltipRect.height);
                                    
                                    // Position all tooltips at same distance from timeline track (not marker)
                                    // Find the timeline track position
                                    const timelineTrack = document.querySelector('.timeline-track');
                                    const trackRect = timelineTrack.getBoundingClientRect();
                                    
                                    // Position tooltip a fixed distance above the timeline track
                                    const fixedGapFromTrack = 120; // Fixed distance from timeline track
                                    const topPos = trackRect.top - fixedGapFromTrack;
                                    let leftPos = markerRect.left + markerRect.width / 2;
                                    let transform = 'translateX(-50%)';
                                    
                                    // Check left edge overflow
                                    if (leftPos - tooltipRect.width / 2 < 10) {
                                        leftPos = markerRect.left;
                                        transform = 'translateX(0%)';
                                    }
                                    // Check right edge overflow  
                                    else if (leftPos + tooltipRect.width / 2 > screenWidth - 10) {
                                        leftPos = markerRect.right;
                                        transform = 'translateX(-100%)';
                                    }
                                    
                                    // Apply final position
                                    tooltip.style.left = leftPos + 'px';
                                    tooltip.style.top = topPos + 'px';
                                    tooltip.style.transform = transform;
                                    tooltip.style.visibility = 'visible';
                                    console.log('Positioned tooltip at:', leftPos, topPos, 'for:', event.title_hebrew);
                                }, 0);
                            };
                            
                            marker.onmouseleave = () => {
                                // Remove the specific tooltip for this marker
                                if (currentTooltip && currentTooltip.parentNode) {
                                    currentTooltip.remove();
                                    currentTooltip = null;
                                }
                                
                                marker.style.transform = 'translateX(-50%) scale(1)';
                                marker.style.zIndex = '100';
                            };
                            
                            // Also add onclick for mobile/debugging
                            marker.onclick = () => {
                                alert(`${event.title_hebrew}\n\n${event.description_hebrew}`);
                            };
                            
                            axisContainer.appendChild(marker);
                            console.log('Added marker for:', event.title_hebrew, 'at position', position + '%');
                        }
                    }
                });
            }

            setupEventListeners() {
                const slider = document.getElementById('timelineSlider');
                
                slider.addEventListener('input', (e) => {
                    const days = parseInt(e.target.value);
                    
                    // Calculate end date going back from today
                    const newEndDate = new Date(this.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - days);
                    this.currentEndDate = newEndDate;
                    
                    // Update timeline progress (show war period from right, RTL)
                    const progress = ((643 - days) / 643) * 100;
                    document.getElementById('timelineProgress').style.width = progress + '%';
                    
                    // Update tooltip
                    this.updateTooltip(days, newEndDate);
                    
                    this.updateVisualization();
                });

                // Setup draggable container
                this.setupDraggableContainer();

                // Setup navigation CTAs
                this.setupNavigationCTAs();

                // Recalculate font size when window is resized with buffer
                window.addEventListener('resize', () => {
                    const container = document.getElementById('namesContainer');
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.oct26Date);
                    setTimeout(() => {
                        const availableWidth = container.clientWidth;
                        const availableHeight = container.clientHeight;
                        if (availableWidth > 0 && availableHeight > 0) {
                            this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                        }
                    }, 100);
                });
            }

            setupDraggableContainer() {
                const container = document.getElementById('draggableContainer');
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };

                container.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons directly
                    
                    isDragging = true;
                    
                    // Apply dragging class immediately for shadow feedback
                    container.classList.add('dragging');
                    
                    const rect = container.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    
                    // Keep container within viewport bounds
                    const maxX = window.innerWidth - container.offsetWidth;
                    const maxY = window.innerHeight - container.offsetHeight;
                    
                    const constrainedX = Math.max(0, Math.min(x, maxX));
                    const constrainedY = Math.max(0, Math.min(y, maxY));
                    
                    // Only change positioning method on first movement, not on mousedown
                    if (container.style.left === '' || container.style.left === 'auto') {
                        container.style.right = 'auto';
                        container.style.transform = 'none';
                    }
                    
                    container.style.left = constrainedX + 'px';
                    container.style.top = constrainedY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        container.classList.remove('dragging');
                    }
                });
            }

            setupNavigationCTAs() {
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');

                ctaBack.addEventListener('click', () => {
                    const prevPoint = this.narrative.getPrevPoint();
                    if (prevPoint) {
                        this.narrative.navigateToPoint(prevPoint.id);
                    }
                });

                ctaContinue.addEventListener('click', () => {
                    const nextPoint = this.narrative.getNextPoint();
                    if (nextPoint) {
                        this.narrative.navigateToPoint(nextPoint.id);
                    }
                });
            }

            updateTooltip(days, currentDate) {
                const tooltip = document.getElementById('timelineTooltip');
                const tooltipDate = document.getElementById('tooltipDate');
                const tooltipAlive = document.getElementById('tooltipAlive');
                const slider = document.getElementById('timelineSlider');
                const track = document.querySelector('.timeline-track');
                
                if (!tooltip || !tooltipDate || !tooltipAlive || !slider || !this.soldiers || !track) {
                    return; // Elements or data not ready yet
                }
                
                // Format date as dd/mm/yy
                const day = currentDate.getDate().toString().padStart(2, '0');
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const year = currentDate.getFullYear().toString().slice(-2);
                const formattedDate = `${day}/${month}/${year}`;
                
                // Calculate alive soldiers count
                const aliveSoldiers = this.soldiers.filter(s => 
                    s.death_date >= this.oct26Date && 
                    s.death_date > currentDate
                ).length;
                
                // Update tooltip content
                tooltipDate.textContent = formattedDate;
                tooltipAlive.textContent = `${aliveSoldiers} soldiers alive`;
                
                // Calculate handle position
                const sliderValue = parseInt(slider.value);
                const handlePercent = (sliderValue / 643) * 100;
                
                // Get tooltip dimensions
                const tooltipWidth = tooltip.offsetWidth;
                const trackWidth = track.offsetWidth;
                
                // Calculate ideal tooltip position (centered on handle)
                const idealLeft = (handlePercent / 100) * trackWidth - (tooltipWidth / 2);
                
                // Constrain tooltip within track bounds
                const minLeft = 0;
                const maxLeft = trackWidth - tooltipWidth;
                const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, idealLeft));
                
                // Position tooltip
                tooltip.style.left = constrainedLeft + 'px';
                tooltip.style.transform = 'none'; // Remove center transform since we're positioning manually
                
                // Calculate triangle position relative to tooltip
                const handlePixelPos = (handlePercent / 100) * trackWidth;
                const triangleOffset = handlePixelPos - constrainedLeft;
                const trianglePercent = (triangleOffset / tooltipWidth) * 100;
                
                // Update triangle position
                const triangleElement = tooltip.querySelector('::after') || tooltip;
                tooltip.style.setProperty('--triangle-left', Math.max(5, Math.min(95, trianglePercent)) + '%');
                
                // Update CSS custom property for triangle positioning
                const style = document.createElement('style');
                style.textContent = `
                    #timelineTooltip::after {
                        left: ${Math.max(5, Math.min(95, trianglePercent))}% !important;
                    }
                `;
                // Remove previous style if exists
                const oldStyle = document.getElementById('tooltip-triangle-style');
                if (oldStyle) oldStyle.remove();
                style.id = 'tooltip-triangle-style';
                document.head.appendChild(style);
            }


            renderAllNames() {
                const container = document.getElementById('namesContainer');
                
                // Filter soldiers who died after Oct 26, 2023
                const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.oct26Date);
                
                if (relevantSoldiers.length === 0) {
                    container.innerHTML = '<div class="loading">No memorial data found</div>';
                    return;
                }

                // Sort by death date
                relevantSoldiers.sort((a, b) => a.death_date - b.death_date);

                const namesHtml = relevantSoldiers.map(soldier => 
                    `<div class="soldier-name" data-death-date="${soldier.death_date.getTime()}" title="${soldier.rank} - ${soldier.unit} - ${soldier.death_date.toLocaleDateString()}">${soldier.name}</div>`
                ).join('');

                container.innerHTML = namesHtml;
                
                // Initialize tooltip now that data is loaded
                this.updateTooltip(0, this.todayDate);
                
                // Wait for DOM to settle then calculate optimal font size with buffer
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 50);
            }

            applySafeFontSize() {
                console.log('Applying safe fixed font size');
                const soldierNames = document.querySelectorAll('.soldier-name');
                const safeFontSize = 7; // 4px * 1.8 = 7.2px
                
                soldierNames.forEach(name => {
                    name.style.fontSize = safeFontSize + 'px';
                });
                
                console.log(`Applied safe font size: ${safeFontSize}px to ${soldierNames.length} names`);
                
                // Verify it works
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const isOverflowing = container.scrollHeight > container.clientHeight;
                    console.log(`Safe font check - overflowing: ${isOverflowing}, scrollHeight: ${container.scrollHeight}, clientHeight: ${container.clientHeight}`);
                }, 100);
            }

            calculateOptimalFontSize(totalNames) {
                // This function is now deprecated - redirect to the proper calculation
                const container = document.getElementById('namesContainer');
                console.log('calculateOptimalFontSize called - redirecting to performFontSizeCalculation');
                
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(totalNames, availableWidth, availableHeight);
                    }
                }, 50);
            }
            
            debugOverflow(container, soldierNames, checkNumber) {
                const isOverflowing = container.scrollHeight > container.clientHeight;
                console.log(`\n--- OVERFLOW CHECK ${checkNumber} ---`);
                console.log(`Container scrollHeight: ${container.scrollHeight}px`);
                console.log(`Container clientHeight: ${container.clientHeight}px`);
                console.log(`Is overflowing: ${isOverflowing}`);
                console.log(`Overflow amount: ${container.scrollHeight - container.clientHeight}px`);
                
                // Check last visible elements
                const containerRect = container.getBoundingClientRect();
                let lastVisibleIndex = -1;
                
                soldierNames.forEach((name, index) => {
                    const rect = name.getBoundingClientRect();
                    if (rect.bottom <= containerRect.bottom && rect.top >= containerRect.top) {
                        lastVisibleIndex = index;
                    }
                });
                
                console.log(`Last visible name index: ${lastVisibleIndex} out of ${soldierNames.length}`);
                console.log(`Names potentially hidden: ${soldierNames.length - lastVisibleIndex - 1}`);
                
                // Show details of names around the cutoff
                for (let i = Math.max(0, lastVisibleIndex - 2); i < Math.min(soldierNames.length, lastVisibleIndex + 10); i++) {
                    const name = soldierNames[i];
                    const rect = name.getBoundingClientRect();
                    const isVisible = rect.bottom <= containerRect.bottom && rect.top >= containerRect.top;
                    console.log(`[${i}] "${name.textContent.substring(0, 15)}..." visible: ${isVisible}, bottom: ${rect.bottom}, container bottom: ${containerRect.bottom}`);
                }
                
                if (isOverflowing && checkNumber === 3) {
                    console.log(`\n!!! FINAL ATTEMPT - SETTING TO 9PX !!!`);
                    soldierNames.forEach(name => {
                        name.style.fontSize = '9px';
                    });
                }
            }

            performFontSizeCalculation(totalNames, availableWidth, availableHeight) {
                const soldierNames = document.querySelectorAll('.soldier-name');
                
                console.log(`\n=== MATHEMATICAL FONT CALCULATION ===`);
                console.log(`Names: ${totalNames}, Available: ${availableWidth}x${availableHeight}px`);
                
                // Use mathematical approach instead of trial-and-error
                const optimalFontSize = this.calculateOptimalFontSizeMathematically(
                    Array.from(soldierNames).map(el => el.textContent),
                    availableWidth,
                    availableHeight
                );
                
                console.log(`Calculated optimal font size: ${optimalFontSize}px`);
                
                // Apply the calculated font size
                soldierNames.forEach(name => {
                    name.style.fontSize = optimalFontSize + 'px';
                });
                
                // Verify the result
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const scrollHeight = container.scrollHeight;
                    const clientHeight = container.clientHeight;
                    const fillRatio = scrollHeight / clientHeight;
                    
                    console.log(`Verification: scrollHeight=${scrollHeight}px, clientHeight=${clientHeight}px`);
                    console.log(`Fill ratio: ${(fillRatio * 100).toFixed(1)}% (target: 90-98%)`);
                    
                    if (fillRatio < 0.85) {
                        console.log('⚠️ Under-filled, could use larger font');
                    } else if (fillRatio > 1.02) {
                        console.log('⚠️ Overflowing, need smaller font');
                        // Auto-correct if overflowing
                        const correctedSize = optimalFontSize * 0.95;
                        console.log(`Auto-correcting to ${correctedSize.toFixed(1)}px`);
                        soldierNames.forEach(name => {
                            name.style.fontSize = correctedSize + 'px';
                        });
                    } else {
                        console.log('✅ Good fill ratio achieved');
                    }
                }, 100);
            }
            
            calculateOptimalFontSizeMathematically(names, availableWidth, availableHeight) {
                // Step 1: Analyze the actual content
                const totalCharacters = names.reduce((sum, name) => sum + name.length, 0);
                const avgNameLength = totalCharacters / names.length;
                
                console.log(`Content analysis: ${totalCharacters} chars, avg ${avgNameLength.toFixed(1)} per name`);
                
                // Step 2: Font and layout constants (measured from Handjet font)
                const charWidthRatio = 0.55; // Character width relative to font size
                const lineHeight = 1.1; // From CSS
                const padding = 8; // 2px + 4px horizontal padding
                const gap = 3.3; // Gap between names
                
                // Step 3: Target fill ratio - aim to fill 95% of available space
                const targetFillRatio = 0.95;
                const targetHeight = availableHeight * targetFillRatio;
                
                console.log(`Target height: ${targetHeight}px (${(targetFillRatio*100).toFixed(0)}% of ${availableHeight}px)`);
                
                // Step 4: Binary search for optimal font size (much more efficient than old method)
                let minFont = 8;
                let maxFont = Math.min(200, availableHeight / 5); // Reasonable upper bound
                let bestFont = minFont;
                
                console.log(`Binary search range: ${minFont}px - ${maxFont}px`);
                
                for (let iteration = 0; iteration < 20; iteration++) {
                    const testFont = (minFont + maxFont) / 2;
                    const predictedHeight = this.predictLayoutHeight(names, testFont, availableWidth, charWidthRatio, lineHeight, padding, gap);
                    
                    console.log(`  Test ${testFont.toFixed(1)}px → height ${predictedHeight.toFixed(1)}px`);
                    
                    if (predictedHeight <= targetHeight) {
                        bestFont = testFont;
                        minFont = testFont;
                    } else {
                        maxFont = testFont;
                    }
                    
                    // Stop if we're close enough
                    if (maxFont - minFont < 0.5) break;
                }
                
                console.log(`Binary search result: ${bestFont.toFixed(1)}px`);
                
                // Step 5: Ensure reasonable bounds
                return Math.max(8, Math.min(150, bestFont));
            }
            
            predictLayoutHeight(names, fontSize, containerWidth, charWidthRatio, lineHeight, padding, gap) {
                // Predict how tall the layout will be at a given font size
                let currentRowWidth = 0;
                let rowCount = 1;
                const effectiveWidth = containerWidth - 10; // Small margin for centering
                
                for (const name of names) {
                    const nameWidth = (name.length * fontSize * charWidthRatio) + padding;
                    
                    // Check if this name fits on current row
                    if (currentRowWidth > 0 && currentRowWidth + gap + nameWidth > effectiveWidth) {
                        // Start new row
                        rowCount++;
                        currentRowWidth = nameWidth;
                    } else {
                        // Add to current row
                        currentRowWidth += (currentRowWidth > 0 ? gap : 0) + nameWidth;
                    }
                }
                
                // Calculate total height
                const rowHeight = fontSize * lineHeight;
                const totalHeight = rowCount * rowHeight + (rowCount - 1) * gap;
                
                return totalHeight;
            }

            updateVisualization() {
                // Update all soldier name elements
                const soldierElements = document.querySelectorAll('.soldier-name');
                let aliveCount = 0;
                
                console.log('updateVisualization called, currentEndDate:', this.currentEndDate);
                
                // First pass: clear all dying timeouts when navigating
                this.dyingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                this.dyingTimeouts.clear();
                
                soldierElements.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const wasAlive = el.classList.contains('alive');
                    const elementId = el.dataset.deathDate; // Use as unique ID
                    
                    if (deathDate > this.currentEndDate) {
                        // This soldier would still be alive at currentEndDate
                        el.className = 'soldier-name alive';
                        aliveCount++;
                    } else {
                        // This soldier had already died by currentEndDate
                        if (wasAlive) {
                            // Transitioning from alive to dead - start red dying state
                            el.className = 'soldier-name dying';
                            aliveCount++; // Count as alive during transition
                            
                            // Set new timeout and track it
                            const timeoutId = setTimeout(() => {
                                // Only change if still dying (not interrupted)
                                if (el.classList.contains('dying')) {
                                    el.className = 'soldier-name fallen';
                                }
                                this.dyingTimeouts.delete(elementId);
                            }, 400);
                            
                            this.dyingTimeouts.set(elementId, timeoutId);
                        } else {
                            // Already dead, just apply fallen state
                            el.className = 'soldier-name fallen';
                        }
                    }
                });
                
                console.log('Alive count:', aliveCount, 'out of', soldierElements.length);
                
                // Update count in draggable container
                const aliveCountSpan = document.getElementById('aliveCount');
                if (aliveCountSpan) {
                    aliveCountSpan.textContent = aliveCount;
                }
                
                // Update narrative content to refresh placeholders
                if (this.narrative) {
                    this.narrative.updateNarrativeContent();
                }
            }
        }

        // Initialize the memorial
        new TimelineMemorial();
    </script>
</body>
</html>