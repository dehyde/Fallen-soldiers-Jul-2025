<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fallen Soldiers - Timeline Memorial</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Handjet:wght@100..900&family=Heebo:wght@100..900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Heebo', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #333;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .stats-header {
            display: none;
        }

        .total-count {
            font-size: 3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .count-label {
            font-size: 1.2em;
            opacity: 0.7;
            color: #666;
        }

        .names-container {
            position: fixed;
            top: 20px;
            bottom: 110px;
            left: 5px;
            right: 5px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            align-content: center;
            gap: 3.3px;
            overflow: hidden;
            justify-content: center;
            direction: rtl;
        }

        .soldier-name {
            font-family: 'Handjet', monospace;
            font-size: 1px; /* will be dynamically calculated */
            font-weight: 400;
            padding: 2px 4px;
            background: rgba(0,0,0,0.1);
            cursor: pointer;
            line-height: 1.1; /* This matches the calculation */
            text-decoration: none;
            -webkit-text-decoration-line: none;
            text-decoration-line: none;
            font-feature-settings: normal;
        }

        .soldier-name:hover {
            background: rgba(0,0,0,0.8) !important;
            color: white !important;
            z-index: 10;
            position: relative;
        }

        .soldier-name.fallen {
            opacity: 0.2;
            background: rgba(255,100,100,0.1);
        }

        .soldier-name.alive {
            opacity: 1;
            background: rgba(0,56,168,0.9);
            color: white;
        }

        .soldier-name.dying {
            opacity: 1;
            background: rgba(139, 0, 0, 0.8) !important; /* Dark red background */
            color: rgb(255, 69, 69) !important; /* Bright red text */
            font-weight: bold;
            z-index: 100;
            position: relative;
            /* No transition on initial red state - instant change from blue to red */
        }

        .soldier-name.dying-fade {
            opacity: 0.2;
            background: rgba(255,100,100,0.1) !important;
            color: inherit !important;
            font-weight: normal !important;
            z-index: auto !important;
            transition: opacity 0.6s ease-out, background-color 0.6s ease-out, color 0.6s ease-out;
        }

        .timeline-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 110px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(15px);
            /* Remove top border */
            /* border-top: 2px solid rgba(0,0,0,0.3); */
            /* Remove shadow */
            /* box-shadow: 0 -4px 20px rgba(0,0,0,0.1); */
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 10px 50px 30px 50px;
            z-index: 100;
        }

        .timeline-track {
            position: relative;
            height: 1px;
            background: #333;
            border-radius: 0;
            margin: 5px 0 15px 0;
            border: none;
        }

        .timeline-progress {
            position: absolute;
            top: -1.5px; /* Center the 4px progress bar on the 1px track */
            right: 0;
            height: 4px;
            width: 0%;
            background: #000;
            border-radius: 0;
            transition: none;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-axis {
            position: absolute;
            top: 5px;
            left: 0;
            right: 0;
            height: 10px;
            z-index: 5;
            pointer-events: none;
        }

        .timeline-tick {
            position: absolute;
            width: 1px;
            height: 2px;
            background: rgba(0,0,0,0.4);
            top: 0;
        }

        .timeline-tick.major {
            height: 3px;
            width: 1px;
            background: rgba(0,0,0,0.6);
        }

        .timeline-date-label {
            position: absolute;
            top: 5px;
            font-size: 8px;
            color: #666;
            white-space: nowrap;
            transform: translateX(-50%);
            font-weight: 500;
        }

        .timeline-slider {
            width: 100%;
            height: 4px;
            background: transparent;
            outline: none;
            position: absolute;
            top: -1.5px; /* Center slider on track to align thumb with progress bar */
            cursor: pointer;
            -webkit-appearance: none;
            z-index: 20;
        }

        .timeline-slider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333;
            border: none;
            outline: none;
        }

        #timelineSlider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #333 0%, #555 100%);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            opacity: 0;
            z-index: 30;
        }

        .timeline-container:hover .timeline-slider::-webkit-slider-thumb {
            opacity: 1;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(0,0,0,0.2);
        }

        .timeline-slider::-moz-range-track {
            height: 2px;
            background: #333;
            border: none;
            outline: none;
        }

        #timelineSlider::-moz-range-track {
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        #timelineSlider {
            background: transparent !important;
            border: none !important;
            outline: none !important;
        }

        .timeline-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #333 0%, #555 100%);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .timeline-container:hover .timeline-slider::-moz-range-thumb {
            opacity: 1;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }

        .timeline-handle-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 50;
            pointer-events: auto;
            opacity: 1;
            transform: translateX(-50%);
            bottom: 15px; /* Changed from top: -65px to grow upwards */
            font-family: 'Heebo', sans-serif;
            text-align: center;
            line-height: 1.3;
            max-width: 300px; /* Allow for wider content when showing events */
            white-space: normal; /* Allow text wrapping for event details */
            transition: opacity 0.2s ease-in-out; /* Smooth opacity transitions */
        }

        .timeline-handle-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px; /* Changed from top: 100% to bottom of tooltip */
            left: 50%;
            margin-left: -5px;
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9); /* Triangle points down from tooltip */
            transition: left 0.1s ease;
        }


        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.5em;
        }

        .draggable-container {
            position: fixed;
            top: 50%;
            right: 100px;
            transform: translateY(-50%);
            width: 280px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(15px);
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 200;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
        }

        .draggable-container:hover {
            cursor: grab;
            background: rgba(250,250,250,0.95);
        }

        .draggable-container:active {
            cursor: grabbing;
        }


        .draggable-container.dragging {
            box-shadow: 0 20px 64px rgba(0,0,0,0.15);
            transition: box-shadow 0.1s ease;
        }


        .draggable-content {
            padding: 20px;
            cursor: inherit;
            direction: rtl;
            text-align: right;
        }

        .content-text {
            font-size: 1.1em;
            line-height: 1.4;
            color: #333;
            margin-bottom: 20px;
            font-family: 'Heebo', sans-serif;
            cursor: inherit;
        }

        .cta-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            cursor: grab;
        }

        .cta-buttons:hover {
            cursor: grab;
        }

        .cta-buttons:active {
            cursor: grabbing;
        }

        .cta-primary {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 2px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            text-indent: -9999px;
            overflow: hidden;
            position: relative;
        }

        .cta-primary::before {
            content: '›';
            font-size: 18px;
            font-weight: bold;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-indent: 0;
        }

        .cta-primary:hover {
            background: #333333;
            transform: translateY(-1px);
        }

        .cta-tertiary {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 2px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            text-indent: -9999px;
            overflow: hidden;
            position: relative;
        }

        .cta-tertiary::after {
            content: '‹';
            font-size: 18px;
            font-weight: bold;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-indent: 0;
        }

        .cta-tertiary:hover {
            background: rgba(0,0,0,0.05);
            border-color: #bbb;
        }

        .timeline-tooltip {
            /* Reset inherited styles */
            all: initial;
            /* Apply our intended styles */
            position: absolute;
            background: rgba(0, 0, 0, 0.9) !important;
            color: white !important;
            padding: 12px 16px !important;
            border-radius: 4px !important;
            border-top-left-radius: 4px !important;
            border-top-right-radius: 4px !important;
            border-bottom-left-radius: 4px !important;
            border-bottom-right-radius: 4px !important;
            font-size: 13px !important;
            max-width: 400px !important;
            min-width: 250px !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            direction: rtl !important;
            text-align: right !important;
            font-family: 'Heebo', sans-serif !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            line-height: 1.4 !important;
            backdrop-filter: blur(10px) !important;
            display: block !important;
        }

        .timeline-tooltip strong {
            display: block !important;
            margin-bottom: 8px !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            font-family: 'Heebo', sans-serif !important;
        }

        .timeline-area-chart {
            position: absolute;
            top: -40px;
            left: 0;
            right: 0;
            height: 40px;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-area-chart svg {
            width: 100%;
            height: 100%;
        }

        .area-path {
            fill: rgba(180, 180, 180, 0.35);
            stroke: none;
        }

        .soldier-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.95) !important;
            color: #333 !important;
            padding: 6px 8px !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            width: auto !important;
            white-space: nowrap !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            text-align: center !important;
            font-family: 'Heebo', sans-serif !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            line-height: 1.2 !important;
            backdrop-filter: blur(5px) !important;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .soldier-tooltip.visible {
            display: block;
            opacity: 1;
        }

        .soldier-tooltip strong {
            display: block !important;
            margin-bottom: 2px !important;
            color: #333 !important;
            font-weight: 600 !important;
            font-size: 12px !important;
            font-family: 'Heebo', sans-serif !important;
        }

        .soldier-tooltip .soldier-details {
            font-size: 10px !important;
            color: #555 !important;
            line-height: 1.2 !important;
        }
    </style>

    <script>
        // Protocol-aware fetch wrapper for file:// support
        async function safeFetch(url) {
            try {
                // Try normal fetch first (works for localhost and https)
                const response = await fetch(url);
                if (response.ok) {
                    return response;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            } catch (error) {
                // If fetch fails and we're on file:// protocol, try alternative approaches
                if (window.location.protocol === 'file:') {
                    console.warn(`Fetch failed for ${url} on file:// protocol:`, error.message);
                    console.warn('Please use a local server (e.g., python -m http.server) for full functionality');
                    
                    // For file:// protocol, we need to inform the user
                    throw new Error(`File loading requires a local server. Please run:\npython -m http.server\nor\nnpx serve\nThen access via http://localhost:8000/`);
                }
                throw error;
            }
        }
    </script>
</head>
<body>
    <div class="draggable-container" id="draggableContainer">
        <div class="draggable-content">
            <div class="content-text" id="contentText">
                טוען נתונים...
            </div>
            <div class="cta-buttons">
                <button class="cta-tertiary" id="ctaBack">חזור</button>
                <button class="cta-primary" id="ctaContinue">המשך</button>
            </div>
        </div>
    </div>

    <div class="names-container" id="namesContainer">
        <div class="loading">Loading memorial data...</div>
    </div>

    <!-- Custom soldier tooltip -->
    <div class="soldier-tooltip" id="soldierTooltip">
        <strong id="soldierName"></strong>
        <div class="soldier-details" id="soldierDetails"></div>
    </div>

    <div class="timeline-container">
        <div class="timeline-track">
            <div class="timeline-area-chart" id="timelineAreaChart">
                <svg viewBox="0 0 100 40" preserveAspectRatio="none">
                    <path class="area-path" id="areaPath" d=""></path>
                </svg>
            </div>
            <div class="timeline-progress" id="timelineProgress"></div>
            <input type="range" id="timelineSlider" class="timeline-slider" min="0" max="1" value="0">
            <div class="timeline-axis" id="timelineAxis"></div>
            <div class="timeline-handle-tooltip" id="timelineTooltip">
                <div id="tooltipDate">27/07/25</div>
                <div id="tooltipAlive">0 soldiers alive</div>
            </div>
        </div>
        <!-- Removed timeline labels -->
    </div>

    <script>
        class NarrativeEngine {
            constructor(timeline) {
                this.timeline = timeline;
                this.narrativePoints = [];
                this.currentPointId = 'loaded';
                this.isNavigating = false; // Flag to prevent conflicting navigation
                this.currentAnimationId = null; // Track current animation
            }

            async loadNarrative() {
                try {
                    const response = await safeFetch('data/narrative.csv');
                    const csvText = await response.text();
                    console.log('CSV loaded:', csvText.substring(0, 200) + '...');
                    this.parseNarrativeCsv(csvText);
                    console.log(`Loaded ${this.narrativePoints.length} narrative points:`, this.narrativePoints);
                } catch (error) {
                    console.error('Error loading narrative:', error);
                    // Fallback content if CSV fails to load
                    document.getElementById('contentText').innerHTML = 'שגיאה בטעינת הנתונים';
                }
            }

            parseNarrativeCsv(csvText) {
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.parseCsvLine(line);
                    if (values.length === headers.length) {
                        const point = {};
                        headers.forEach((header, index) => {
                            point[header.trim()] = values[index].trim();
                        });
                        this.narrativePoints.push(point);
                    }
                }
            }

            parseCsvLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current);
                return result;
            }

            // Advanced placeholder parsing
            parseTemplate(content) {
                return content.replace(/\{\{([^}]+)\}\}/g, (match, placeholder) => {
                    return this.resolvePlaceholder(placeholder.trim());
                });
            }

            resolvePlaceholder(placeholder) {
                const [type, ...params] = placeholder.split(':');
                
                switch(type) {
                    case 'total_count':
                        return `<strong>${this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate).length}</strong>`;
                    
                    case 'alive_count':
                        return `<strong>${this.getAliveCount()}</strong>`;
                    
                    case 'fallen_count':
                        return `<strong>${this.getFallenCount()}</strong>`;
                    
                    case 'fallen_since_date':
                        const days = parseInt(params[0]) || 0;
                        return `<strong>${this.getFallenSince(days)}</strong>`;
                    
                    case 'fallen_on_date':
                        const targetDays = parseInt(params[0]) || 0;
                        return `<strong>${this.getFallenOnDate(targetDays)}</strong>`;
                    
                    case 'date_hebrew':
                        const daysBack = parseInt(params[0]) || 0;
                        return this.formatHebrewDate(daysBack);
                    
                    case 'days_since_start':
                        return `<strong>${Math.round((this.timeline.currentEndDate - this.timeline.startDate) / (1000 * 60 * 60 * 24))}</strong>`;
                    
                    case 'percentage_fallen':
                        const total = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate).length;
                        const fallen = this.getFallenCount();
                        return `<strong>${Math.round((fallen / total) * 100)}</strong>`;
                    
                    case 'soldier_name':
                        return this.getSoldierName(params[0]);
                    
                    case 'months_since_start':
                        return `<strong>${this.getMonthsSinceStart()}</strong>`;
                    
                    case 'average_monthly_casualties':
                        return `<strong>${this.getAverageMonthlycasualties()}</strong>`;
                    
                    case 'days_since_last_deaths':
                        return `<strong>${this.getDaysSinceLastDeaths()}</strong>`;
                    
                    case 'last_deaths_text':
                        return this.getLastDeathsText();
                    
                    case 'war_continuation_message':
                        return this.getWarContinuationMessage();
                    
                    case 'political_event_date':
                        return this.getPoliticalEventDate();
                    
                    case 'coalition_threat_date':
                        return this.getCoalitionThreatDate();
                    
                    case 'coalition_threat_person':
                        return this.getCoalitionThreatPerson();
                    
                    case 'coalition_threats_count':
                        return `<strong>${this.getCoalitionThreatsCount()}</strong>`;
                    
                    case 'days_since_decision':
                        return `<strong>${this.getDaysSinceDecision()}</strong>`;
                    
                    case 'could_be_alive_count':
                        return `<strong>${this.getCouldBeAliveCount()}</strong>`;
                    
                    case 'random_names':
                        return this.getRandomNames();
                    
                    case 'fallen_since_january':
                        return `<strong>${this.getFallenSinceJanuary()}</strong>`;
                    
                    case 'fallen_last_month':
                        return `<strong>${this.getFallenLastMonth()}</strong>`;
                    
                    case 'last_month_names':
                        return this.getLastMonthNames();
                    
                    case 'last_month_remaining_count':
                        return `<strong>${this.getLastMonthRemainingCount()}</strong>`;
                    
                    default:
                        return `{{${placeholder}}}`;
                }
            }

            getAliveCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > this.timeline.currentEndDate
                ).length;
            }

            getFallenCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate
                ).length;
            }

            getFallenSince(daysBack) {
                const sinceDate = new Date(this.timeline.currentEndDate);
                sinceDate.setDate(sinceDate.getDate() - daysBack);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate &&
                    s.death_date >= sinceDate
                ).length;
            }

            getFallenOnDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const startOfDay = new Date(targetDate);
                startOfDay.setHours(0, 0, 0, 0);
                const endOfDay = new Date(targetDate);
                endOfDay.setHours(23, 59, 59, 999);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= startOfDay && 
                    s.death_date <= endOfDay
                ).length;
            }

            formatHebrewDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${targetDate.getDate()} ${hebrewMonths[targetDate.getMonth()]} ${targetDate.getFullYear()}`;
            }

            getSoldierName(type) {
                const relevantSoldiers = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate);
                
                switch(type) {
                    case 'first':
                        const first = relevantSoldiers.sort((a, b) => a.death_date - b.death_date)[0];
                        return first ? `<strong>${first.name}</strong>` : 'לא ידוע';
                    
                    case 'latest':
                        const latest = relevantSoldiers
                            .filter(s => s.death_date <= this.timeline.currentEndDate)
                            .sort((a, b) => b.death_date - a.death_date)[0];
                        return latest ? `<strong>${latest.name}</strong>` : 'לא ידוע';
                    
                    default:
                        return 'לא ידוע';
                }
            }

            getMonthsSinceStart() {
                const startDate = this.timeline.startDate;
                const currentDate = this.timeline.todayDate; // Use today's date instead of timeline date
                
                const yearDiff = currentDate.getFullYear() - startDate.getFullYear();
                const monthDiff = currentDate.getMonth() - startDate.getMonth();
                const dayDiff = currentDate.getDate() - startDate.getDate();
                
                let totalMonths = yearDiff * 12 + monthDiff;
                
                // Add partial month if we've passed the start day
                if (dayDiff >= 0) {
                    totalMonths += Math.round(dayDiff / 30 * 10) / 10; // Round to 1 decimal
                }
                
                return Math.round(totalMonths);
            }

            getAverageMonthlycasualties() {
                const monthsSinceStart = this.getMonthsSinceStart();
                const totalFallen = this.getFallenCount();
                
                if (monthsSinceStart === 0) return 0;
                
                return Math.round(totalFallen / monthsSinceStart);
            }

            getDaysSinceLastDeaths() {
                // Use today's date, not currentEndDate, for this calculation
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                // Find the most recent death date from all soldiers
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Calculate days from today back to most recent death
                return Math.floor((this.timeline.todayDate - latestDeathDate) / (1000 * 60 * 60 * 24));
            }

            getLastDeathsText() {
                // Use all soldiers to find the most recent deaths (up to today)
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return '';
                
                // Find soldiers who died on the most recent death date
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                const soldiersOnLatestDate = relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000 // Same day
                );
                
                // Format Hebrew date
                const date = new Date(latestDeathDate);
                const hebrewDays = ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'];
                const hebrewMonths = ['בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני', 'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'];
                const dayOfWeek = hebrewDays[date.getDay()];
                const day = date.getDate();
                const month = hebrewMonths[date.getMonth()];
                const year = date.getFullYear();
                const hebrewDate = `יום ${dayOfWeek}, ${day} ${month}, ${year}`;
                
                // Format names
                let names = '';
                if (soldiersOnLatestDate.length === 1) {
                    names = `<strong>${soldiersOnLatestDate[0].name}</strong>`;
                } else if (soldiersOnLatestDate.length === 2) {
                    names = `<strong>${soldiersOnLatestDate[0].name}</strong> ו-<strong>${soldiersOnLatestDate[1].name}</strong>`;
                } else if (soldiersOnLatestDate.length > 2) {
                    const nameList = soldiersOnLatestDate.slice(0, -1).map(s => `<strong>${s.name}</strong>`).join(', ');
                    const lastName = `<strong>${soldiersOnLatestDate[soldiersOnLatestDate.length - 1].name}</strong>`;
                    names = `${nameList} ו-${lastName}`;
                }
                
                return `ביום ${hebrewDate}, נהרגו ${names}. באותו בוקר הם היו עוד חיים.`;
            }


            getWarContinuationMessage() {
                const lastDeathsCount = this.getLastDeathsOnMostRecentDate();
                
                if (lastDeathsCount === 1) {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הוא היה חוזר הביתה למשפחה שלו';
                } else {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הם היו חוזרים הביתה למשפחות שלהם';
                }
            }

            getLastDeathsOnMostRecentDate() {
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                return relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000
                ).length;
            }

            getPoliticalEventDate() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 'תאריך לא ידוע';
                
                const eventDate = new Date(netanyahuEvent.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatDate() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'תאריך לא ידוע';
                
                const firstThreat = threatEvents[0];
                const eventDate = new Date(firstThreat.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatPerson() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'לא ידוע';
                
                const firstThreat = threatEvents[0];
                if (firstThreat.id.includes('smotrich')) {
                    return 'סמוטריץ\'';
                } else if (firstThreat.id.includes('ben_gvir')) {
                    return 'בן גביר';
                }
                
                return 'לא ידוע';
            }

            getCoalitionThreatsCount() {
                return this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).length;
            }

            getDaysSinceDecision() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const eventDate = new Date(netanyahuEvent.date);
                return Math.round((this.timeline.todayDate - eventDate) / (1000 * 60 * 60 * 24));
            }

            getCouldBeAliveCount() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const decisionDate = new Date(netanyahuEvent.date);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date > decisionDate && 
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getRandomNames() {
                const couldBeAliveSoldiers = this.timeline.soldiers.filter(s => {
                    const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                        e.id === 'netanyahu_considers_ceasefire'
                    );
                    
                    if (!netanyahuEvent) return false;
                    
                    const decisionDate = new Date(netanyahuEvent.date);
                    return s.death_date > decisionDate && s.death_date >= this.timeline.startDate;
                });
                
                // Select 3 random names and make them bold
                const shuffled = couldBeAliveSoldiers.sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, 3);
                
                return selected.map(s => `- <strong>${s.name}</strong>`).join('<br>');
            }

            getFallenSinceJanuary() {
                const januaryDate = new Date('2024-01-07');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= januaryDate && 
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getFallenLastMonth() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getLastMonthNames() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                );
                
                // Get first 3 names and make them bold
                const names = lastMonthSoldiers.slice(0, 3).map(s => `<strong>${s.name}</strong>`);
                return names.join(', ');
            }

            getLastMonthRemainingCount() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                );
                
                // Return count of remaining soldiers beyond the first 3
                return Math.max(0, lastMonthSoldiers.length - 3);
            }

            // Navigation methods
            getCurrentPoint() {
                return this.narrativePoints.find(p => p.id === this.currentPointId) || this.narrativePoints[0];
            }

            navigateToPoint(pointId) {
                const point = this.narrativePoints.find(p => p.id === pointId);
                if (!point) return;
                
                // Cancel any ongoing animation immediately (allows override)
                if (this.currentAnimationId) {
                    clearTimeout(this.currentAnimationId);
                    this.currentAnimationId = null;
                    console.log('Previous navigation cancelled, starting new one');
                }
                
                this.isNavigating = true;
                this.currentPointId = pointId;
                
                // Get current and target timeline points
                const currentTimelinePoint = parseInt(document.getElementById('timelineSlider').value);
                let targetTimelinePoint = parseInt(point.timeline_point);
                
                // Special handling for recent_deaths: use actual days since last deaths
                if (pointId === 'recent_deaths') {
                    targetTimelinePoint = this.timeline.narrative.getDaysSinceLastDeaths() + 1;
                }
                
                // Update content immediately
                this.updateNarrativeContent();
                
                // Start gradual animation if there's a difference
                if (currentTimelinePoint !== targetTimelinePoint) {
                    this.animateToTimelinePoint(currentTimelinePoint, targetTimelinePoint);
                } else {
                    // If already at target, just update visualization and unlock navigation
                    this.timeline.updateVisualization();
                    this.isNavigating = false;
                }
            }

            animateToTimelinePoint(startPoint, endPoint) {
                const slider = document.getElementById('timelineSlider');
                const progressBar = document.getElementById('timelineProgress');
                
                // Mark timeline as animating
                this.timeline.isTimelineAnimating = true;
                
                // Determine direction and speed
                const isMovingBack = endPoint > startPoint; // Moving back in time (higher days back)
                const isMovingForward = endPoint < startPoint; // Moving forward in time (lower days back)
                
                // Set different speeds: slower for forward, faster for backward
                const forwardSpeed = 25; // ms per day when moving forward in time (SLOWER)
                const backwardSpeed = 15;  // ms per day when moving back in time (SLOWER)
                
                const speed = isMovingForward ? forwardSpeed : backwardSpeed;
                const step = isMovingBack ? 1 : -1;
                
                let current = startPoint;
                
                const animate = () => {
                    // Check if animation was cancelled
                    if (!this.isNavigating) {
                        console.log('Animation cancelled during execution');
                        return;
                    }
                    
                    // Update current timeline point
                    current += step;
                    
                    // Update slider
                    slider.value = current;
                    
                    // Update timeline progress
                    const totalDays = this.timeline.getTotalTimelineDays();
                    const progress = ((totalDays - current) / totalDays) * 100;
                    progressBar.style.width = progress + '%';
                    
                    // Update timeline date
                    const newEndDate = new Date(this.timeline.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - current);
                    this.timeline.currentEndDate = newEndDate;
                    
                    // Update tooltip during animation
                    this.timeline.updateTooltip(current, newEndDate);
                    
                    // Update visualization
                    this.timeline.updateVisualization();
                    
                    // Check if we've reached the target
                    const reachedTarget = isMovingBack ? (current >= endPoint) : (current <= endPoint);
                    
                    if (!reachedTarget) {
                        // Continue animation with tracked timeout
                        this.currentAnimationId = setTimeout(animate, speed);
                    } else {
                        // Animation complete - unlock navigation and stop animating
                        this.isNavigating = false;
                        this.currentAnimationId = null;
                        this.timeline.isTimelineAnimating = false;
                    }
                };
                
                // Start animation with tracked timeout
                this.currentAnimationId = setTimeout(animate, speed);
            }

            updateNarrativeContent() {
                const point = this.getCurrentPoint();
                if (!point) return;
                
                const contentText = document.getElementById('contentText');
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');
                
                // Parse and update content
                const parsedContent = this.parseTemplate(point.content_hebrew);
                contentText.innerHTML = parsedContent;
                
                // Update buttons
                ctaContinue.textContent = point.cta_continue_he || 'המשך';
                ctaBack.textContent = point.cta_back_he || 'חזור';
                
                // Show/hide buttons based on navigation - hide back button for first narrative point
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                ctaBack.style.display = (currentIndex > 0) ? 'inline-block' : 'none';
                ctaContinue.style.display = this.getNextPoint() ? 'inline-block' : 'none';
            }

            getNextPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex < this.narrativePoints.length - 1 ? this.narrativePoints[currentIndex + 1] : null;
            }

            getPrevPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex > 0 ? this.narrativePoints[currentIndex - 1] : null;
            }

        }

        class TimelineMemorial {
            constructor() {
                this.soldiers = [];
                this.timelineEvents = [];
                this.militaryEvents = [];
                this.startDate = new Date('2023-10-27');
                this.todayDate = new Date();
                this.currentEndDate = new Date(); // Start at today so all soldiers are "fallen"
                this.navigationState = 'month_back'; // 'month_back' or 'today'
                this.narrative = new NarrativeEngine(this);
                this.dyingTimeouts = new Map(); // Track timeouts for performance
                this.soldierStates = new Map(); // Track actual soldier states independently of CSS
                this.isTimelineAnimating = false; // Track if timeline is actively animating
                this.lastTooltipUpdate = 0; // Track last manual tooltip update
                this.init();
            }

            getTotalTimelineDays() {
                // Calculate days from start date (Oct 27, 2023) to today
                // Add 1 to include today as day 0 in the slider range
                return Math.floor((this.todayDate - this.startDate) / (1000 * 60 * 60 * 24)) + 1;
            }


            async init() {
                await this.loadData();
                await this.loadTimelineEvents(); // Load timeline events
                await this.loadMilitaryEvents(); // Load military events
                await this.narrative.loadNarrative(); // Load narrative data
                this.setupEventListeners();
                this.generateTimelineAxis();
                this.renderAllNames();
                
                // Set timeline slider max value dynamically
                const totalDays = this.getTotalTimelineDays();
                document.getElementById('timelineSlider').max = totalDays;
                
                // Initialize with recent deaths narrative point (at today - 7 days back)
                this.narrative.navigateToPoint('recent_deaths');
                
                // Initialize timeline progress bar (at current date - 0 days back)
                const initialDaysBack = 0;
                const initialProgress = ((totalDays - initialDaysBack) / totalDays) * 100;
                document.getElementById('timelineProgress').style.width = initialProgress + '%';
                
                // Recalculate font size after timeline changes with buffer
                setTimeout(() => {
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                    console.log('Forcing font recalculation for', relevantSoldiers.length, 'soldiers');
                    
                    // Force container dimensions update
                    const container = document.getElementById('namesContainer');
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    console.log('New container dimensions:', availableWidth, 'x', availableHeight);
                    
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 200);
            }

            async loadData() {
                try {
                    const response = await safeFetch('data/idf-url-increment.csv');
                    const csvText = await response.text();
                    this.parseCsvData(csvText);
                    console.log(`Loaded ${this.soldiers.length} soldiers`);
                    
                    if (this.soldiers.length > 0) {
                        const dates = this.soldiers.map(s => s.death_date).sort((a,b) => a - b);
                        console.log('Date range:', dates[0].toLocaleDateString(), 'to', dates[dates.length-1].toLocaleDateString());
                        
                        const afterOct26 = this.soldiers.filter(s => s.death_date >= this.startDate);
                        console.log(`${afterOct26.length} soldiers died after Oct 27, 2023`);
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    document.getElementById('namesContainer').innerHTML = '<div class="loading">Error loading memorial data</div>';
                }
            }

            async loadTimelineEvents() {
                try {
                    console.log('Attempting to load timeline-events.csv...');
                    const response = await safeFetch('data/timeline-events.csv');
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('CSV text loaded:', csvText.substring(0, 200) + '...');
                    this.parseTimelineEvents(csvText);
                    console.log(`Loaded ${this.timelineEvents.length} timeline events`);
                } catch (error) {
                    console.error('Error loading timeline events:', error);
                    // Create test events if CSV fails to load
                    console.log('Creating test timeline events...');
                    this.timelineEvents = [
                        {
                            id: 'test_event',
                            date: '2025-07-29',
                            title_hebrew: 'אירוע מבחן',
                            description_hebrew: 'זהו אירוע מבחן',
                            eventDate: new Date('2025-07-29')
                        }
                    ];
                    console.log('Test events created:', this.timelineEvents.length);
                }
            }
            
            async loadMilitaryEvents() {
                try {
                    console.log('Attempting to load military_events.csv...');
                    const response = await safeFetch('data/military_events.csv');
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('CSV text loaded:', csvText.substring(0, 200) + '...');
                    this.parseMilitaryEvents(csvText);
                    console.log(`Loaded ${this.militaryEvents.length} military events`);
                } catch (error) {
                    console.error('Error loading military events:', error);
                    this.militaryEvents = [];
                }
            }

            parseCsvData(csvText) {
                const lines = csvText.split('\n');
                let currentRecord = '';
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.match(/^"\d+-\d+"/)) {
                        if (currentRecord) {
                            const soldier = this.parseCsvLine(currentRecord);
                            if (soldier && soldier.death_date) {
                                this.soldiers.push(soldier);
                            }
                        }
                        currentRecord = line;
                    } else {
                        currentRecord += ' ' + line;
                    }
                }
                
                if (currentRecord) {
                    const soldier = this.parseCsvLine(currentRecord);
                    if (soldier && soldier.death_date) {
                        this.soldiers.push(soldier);
                    }
                }
            }

            parseCsvLine(line) {
                const deathDateField = line;
                
                const hebrewMonths = {
                    'באוקטובר': 9,
                    'בנובמבר': 10,
                    'בדצמבר': 11,
                    'בינואר': 0,
                    'בפברואר': 1,
                    'במרץ': 2,
                    'באפריל': 3,
                    'במאי': 4,
                    'ביוני': 5,
                    'ביולי': 6,
                    'באוגוסט': 7,
                    'בספטמבר': 8
                };

                let deathDate = null;
                let matchedDateStr = '';
                
                for (const [hebrewMonth, monthIndex] of Object.entries(hebrewMonths)) {
                    const pattern = new RegExp(`(\\d{1,2}) ${hebrewMonth} (\\d{4})`);
                    const match = deathDateField.match(pattern);
                    if (match) {
                        const day = parseInt(match[1]);
                        const year = parseInt(match[2]);
                        deathDate = new Date(year, monthIndex, day);
                        matchedDateStr = match[0];
                        break;
                    }
                }

                if (!deathDate) return null;

                // Simple approach: extract from the whole line using simpler patterns
                let name = 'Unknown';
                let rank = 'Unknown'; 
                let unit = 'Unknown';
                
                // IMPROVED: Better name extraction - include more Hebrew name characters
                const namePattern = /\s+([א-ת\s'\-\(\)׳״""]+?)\s+ז""ל/;
                const nameMatch = line.match(namePattern);
                if (nameMatch) {
                    const fullName = nameMatch[1].trim();
                    // Remove rank prefix if it exists - expanded list
                    const cleanName = fullName.replace(/^(רס""[א-ת]+|סמל|סרן|רב""ט|סמ""ר|רס""ל|רס""ם|אל""ם|רס""ן|תא""ל|אל""ף)\s*\([^)]*\)?\s*/, '').replace(/\s*\(במיל'\)\s*/g, '');
                    name = cleanName.trim();
                }
                
                // IMPROVED: Extract rank and unit from proper CSV fields instead of regex
                const fields = line.split('","');
                if (fields.length >= 4) {
                    // Field 3 contains rank
                    const rankField = fields[3];
                    if (rankField && rankField.trim()) {
                        rank = rankField.trim();
                    }
                }
                
                if (fields.length >= 5) {
                    // Field 4 contains unit
                    const unitField = fields[4];
                    if (unitField && unitField.trim()) {
                        unit = unitField.trim();
                    }
                }

                return {
                    name: name,
                    rank: rank,
                    unit: unit,
                    death_date: deathDate,
                    death_date_string: matchedDateStr
                };
            }

            parseTimelineEvents(csvText) {
                const lines = csvText.split('\n');
                const headers = this.narrative.parseCsvLine(lines[0]);
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.narrative.parseCsvLine(line);
                    const event = {};
                    
                    headers.forEach((header, index) => {
                        event[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    
                    
                    // Fix URLs that ended up in description field
                    if (event.description_hebrew && event.description_hebrew.includes('http')) {
                        const parts = event.description_hebrew.split('http');
                        if (parts.length > 1) {
                            event.description_hebrew = parts[0].trim();
                            event.source = 'http' + parts[1].trim();
                        }
                    }
                    
                    // Parse date - handle d/m/yyyy format correctly
                    if (event.date) {
                        // Convert d/m/yyyy to m/d/yyyy for proper JavaScript parsing
                        const [day, month, year] = event.date.split('/');
                        const correctedDateString = `${month}/${day}/${year}`;
                        event.eventDate = new Date(correctedDateString);
                        console.log('Timeline event parsed:', event.title_hebrew, 'Original date:', event.date, 'Parsed date:', event.eventDate);
                    }
                    
                    this.timelineEvents.push(event);
                }
                console.log('Total timeline events loaded:', this.timelineEvents.length);
            }
            
            parseMilitaryEvents(csvText) {
                const lines = csvText.split('\n');
                const headers = this.narrative.parseCsvLine(lines[0]);
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.narrative.parseCsvLine(line);
                    const event = {};
                    
                    headers.forEach((header, index) => {
                        event[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    
                    // Parse date
                    if (event.Date) {
                        event.eventDate = new Date(event.Date);
                    }
                    
                    // Parse penetration depth - use the numeric value
                    if (event.Penetration_km) {
                        event.penetrationKm = parseFloat(event.Penetration_km) || 0;
                    } else {
                        event.penetrationKm = 0;
                    }
                    
                    // Map qualitative levels to numeric intensity for better visualization
                    const qualitativeMap = {
                        'Low': 1,
                        'Medium': 2, 
                        'High': 3
                    };
                    event.intensityLevel = qualitativeMap[event.Penetration_qualitative] || 1;
                    
                    // Combine penetration depth and intensity for final combat intensity score
                    event.combatIntensity = event.penetrationKm + (event.intensityLevel * 2);
                    
                    console.log('Military event parsed:', event.Date, event.Event_Type, 'Intensity:', event.combatIntensity);
                    
                    this.militaryEvents.push(event);
                }
                console.log('Total military events loaded:', this.militaryEvents.length);
            }

            generateTimelineAxis() {
                const axisContainer = document.getElementById('timelineAxis');
                axisContainer.innerHTML = '';
                
                const startDate = this.startDate;
                const endDate = new Date();
                const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)); // From today back to Oct 27, 2023
                
                // Generate major ticks every 3 months and minor ticks every month
                const majorTickMonths = [0, 3, 6, 9, 12, 15, 18, 21]; // Every 3 months
                const minorTickMonths = [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20]; // Every month
                
                // Calculate date positions
                const monthsTotal = 21; // Approximately 21 months from Oct 2023 to Jul 2025
                
                // Major ticks with labels
                majorTickMonths.forEach(monthOffset => {
                    if (monthOffset <= monthsTotal) {
                        const tickDate = new Date(startDate);
                        tickDate.setMonth(tickDate.getMonth() + monthOffset);
                        
                        const position = ((monthsTotal - monthOffset) / monthsTotal) * 100;
                        
                        // Create tick mark
                        const tick = document.createElement('div');
                        tick.className = 'timeline-tick major';
                        tick.style.left = position + '%';
                        axisContainer.appendChild(tick);
                        
                        // Create date label
                        const label = document.createElement('div');
                        label.className = 'timeline-date-label';
                        label.style.left = position + '%';
                        label.textContent = tickDate.toLocaleDateString('en-US', { 
                            month: 'short', 
                            year: '2-digit' 
                        });
                        axisContainer.appendChild(label);
                    }
                });
                
                // Minor ticks
                minorTickMonths.forEach(monthOffset => {
                    if (monthOffset <= monthsTotal) {
                        const position = ((monthsTotal - monthOffset) / monthsTotal) * 100;
                        
                        const tick = document.createElement('div');
                        tick.className = 'timeline-tick';
                        tick.style.left = position + '%';
                        axisContainer.appendChild(tick);
                    }
                });

                // Add timeline events markers
                console.log('Adding timeline event markers, total events:', this.timelineEvents.length);
                console.log('Timeline range:', startDate.toLocaleDateString(), 'to', endDate.toLocaleDateString());
                console.log('Total timeline days:', totalDays);
                
                let markersAdded = 0;
                let markersSkipped = 0;
                
                this.timelineEvents.forEach(event => {
                    console.log('Processing event:', event.title_hebrew, 'Date:', event.eventDate);
                    if (event.eventDate && !isNaN(event.eventDate.getTime())) {
                        // Calculate position based on date (0% = endDate/today, 100% = startDate/oldest)
                        // Use same day scale as progress bar and slider for alignment
                        const daysDiff = Math.floor((endDate - event.eventDate) / (1000 * 60 * 60 * 24));
                        const totalDays = this.getTotalTimelineDays();
                        const position = (daysDiff / totalDays) * 100;
                        console.log(`Event "${event.title_hebrew}": eventDate=${event.eventDate.toISOString()}, daysDiff=${daysDiff}, position=${position.toFixed(1)}%`);
                        
                        if (position >= 0 && position <= 100) {
                            // Skip military category events from display
                            if (event.category === 'military') {
                                markersSkipped++;
                                return;
                            }
                            
                            // Create event marker
                            const marker = document.createElement('div');
                            marker.className = 'timeline-event-marker';
                            marker.style.position = 'absolute';
                            marker.style.left = position + '%';
                            
                            // Position all events below timeline
                            // Note: markers are positioned relative to the axis (which is 5px below track)
                            // So we need to adjust positions to align with the track itself
                            const trackOffsetFromAxis = -5; // Axis is 5px below track, so track is -5px from axis
                            const markerDistance = 15; // Distance from timeline track
                            
                            // All events below track: track position plus marker distance  
                            marker.style.top = `${trackOffsetFromAxis + markerDistance}px`;
                            marker.style.transform = 'translate(-50%, -50%)';
                            
                            marker.style.width = '8px';
                            marker.style.height = '8px';
                            
                            // Set color based on category
                            let markerColor = '#ff4444'; // default red
                            switch(event.category) {
                                case 'military': markerColor = '#808000'; break; // olive green
                                case 'political': markerColor = '#666666'; break; // gray
                                case 'diplomatic': markerColor = '#666666'; break; // gray
                                case 'legal': markerColor = '#9900cc'; break; // purple
                                default: markerColor = '#666666'; // gray
                            }
                            marker.style.background = markerColor;
                            marker.style.border = '2px solid #ffffff';
                            marker.style.borderRadius = '50%';
                            marker.style.cursor = 'pointer';
                            marker.style.zIndex = '100';
                            // Remove shadow
                            // marker.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            marker.style.pointerEvents = 'auto';
                            
                            // Create custom immediate tooltip
                            let currentTooltip = null;
                            let currentTooltipStyle = null;
                            
                            marker.onmouseenter = (e) => {
                                // Fade the main timeline handle tooltip to 15% opacity
                                const mainTooltip = document.getElementById('timelineTooltip');
                                if (mainTooltip) {
                                    mainTooltip.style.opacity = '0.15';
                                }
                                
                                // Remove any existing event tooltips
                                document.querySelectorAll('.timeline-tooltip').forEach(t => t.remove());
                                
                                // Scale up marker while maintaining Y position
                                marker.style.transform = 'translate(-50%, -50%) scale(1.5)';
                                marker.style.zIndex = '200';
                                
                                // Format event date
                                const eventDay = event.eventDate.getDate().toString().padStart(2, '0');
                                const eventMonth = (event.eventDate.getMonth() + 1).toString().padStart(2, '0');
                                const eventYear = event.eventDate.getFullYear().toString().slice(-2);
                                const formattedEventDate = `${eventDay}/${eventMonth}/${eventYear}`;
                                
                                // Create tooltip with timeline handle style - show title and date
                                const tooltip = document.createElement('div');
                                tooltip.className = 'timeline-handle-tooltip';
                                tooltip.innerHTML = `
                                    <div>${event.title_hebrew}</div>
                                    <div>${formattedEventDate}</div>
                                `;
                                // Start invisible to prevent flash
                                tooltip.style.opacity = '0';
                                currentTooltip = tooltip;
                                
                                // Position tooltip relative to the axis container (where markers are)
                                const axisContainer = document.getElementById('timelineAxis');
                                axisContainer.appendChild(tooltip);
                                
                                // Use the same position calculation as the marker
                                const eventPercent = position;
                                
                                // Use setTimeout to ensure CSS is applied and dimensions are calculated
                                setTimeout(() => {
                                    // Get dimensions
                                    const tooltipWidth = tooltip.offsetWidth;
                                    const axisWidth = axisContainer.offsetWidth;
                                    
                                    // Use absolute positioning relative to axis container
                                    tooltip.style.position = 'absolute';
                                    
                                    // Calculate ideal position (centered on event)
                                    const idealLeft = (eventPercent / 100) * axisWidth - (tooltipWidth / 2);
                                    
                                    // Constrain within bounds
                                    const minLeft = 0;
                                    const maxLeft = axisWidth - tooltipWidth;
                                    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, idealLeft));
                                    
                                    tooltip.style.left = constrainedLeft + 'px';
                                    tooltip.style.transform = 'none';
                                    
                                    // Make tooltip visible after positioning
                                    tooltip.style.opacity = '1';
                                }, 0);
                            };
                            
                            marker.onmouseleave = () => {
                                // Restore the main timeline handle tooltip to full opacity
                                const mainTooltip = document.getElementById('timelineTooltip');
                                if (mainTooltip) {
                                    mainTooltip.style.opacity = '1';
                                }
                                
                                // Remove the event tooltip
                                if (currentTooltip && currentTooltip.parentNode) {
                                    currentTooltip.remove();
                                    currentTooltip = null;
                                }
                                
                                // Reset marker scale and z-index
                                marker.style.transform = 'translate(-50%, -50%) scale(1)';
                                marker.style.zIndex = '100';
                            };
                            
                            // Click to jump to event date
                            marker.onclick = () => {
                                this.jumpToEventDate(event.eventDate);
                            };
                            
                            axisContainer.appendChild(marker);
                            console.log(`✅ Successfully added marker for: ${event.title_hebrew} (${event.stance}) at position ${position.toFixed(1)}% - BELOW timeline`);
                            markersAdded++;
                        } else {
                            console.log(`❌ Skipping event "${event.title_hebrew}" - position out of range: ${position.toFixed(1)}%`);
                            markersSkipped++;
                        }
                    } else {
                        console.log(`❌ Skipping event "${event.title_hebrew}" - invalid date:`, event.eventDate);
                        markersSkipped++;
                    }
                });
                
                console.log(`\n📊 Timeline markers summary: ${markersAdded} added, ${markersSkipped} skipped, ${this.timelineEvents.length} total`);
                
                // Generate area chart after timeline axis
                this.generateAreaChart();
            }

            getEventAtDate(currentDate) {
                // Find timeline event that matches the current date (within same day)
                const currentDateOnly = new Date(currentDate);
                currentDateOnly.setHours(0, 0, 0, 0);
                
                return this.timelineEvents.find(event => {
                    if (!event.eventDate) return false;
                    
                    // Skip military category events (same as display filter)
                    if (event.category === 'military') return false;
                    
                    const eventDateOnly = new Date(event.eventDate);
                    eventDateOnly.setHours(0, 0, 0, 0);
                    
                    return Math.abs(currentDateOnly - eventDateOnly) < 24 * 60 * 60 * 1000; // Same day
                });
            }

            jumpToEventDate(eventDate) {
                // Calculate days back from today to the event date
                const daysBack = Math.floor((this.todayDate - eventDate) / (1000 * 60 * 60 * 24));
                
                // Ensure the value is within slider bounds
                const totalDays = this.getTotalTimelineDays();
                const constrainedDays = Math.max(0, Math.min(totalDays, daysBack));
                
                // Update slider and timeline
                const slider = document.getElementById('timelineSlider');
                slider.value = constrainedDays;
                
                // Mark as manual input (not animating)
                this.isTimelineAnimating = false;
                this.lastTooltipUpdate = Date.now();
                
                // Calculate new end date
                const newEndDate = new Date(this.todayDate);
                newEndDate.setDate(newEndDate.getDate() - constrainedDays);
                this.currentEndDate = newEndDate;
                
                // Update timeline progress
                const progress = ((totalDays - constrainedDays) / totalDays) * 100;
                document.getElementById('timelineProgress').style.width = progress + '%';
                
                // Add small delay to ensure slider position is visually updated before tooltip positioning
                setTimeout(() => {
                    this.updateTooltip(constrainedDays, newEndDate);
                    this.updateVisualization();
                }, 10);
                
                console.log(`Jumped to event date: ${eventDate.toLocaleDateString()}, days back: ${constrainedDays}`);
            }

            generateAreaChart() {
                console.log('Generating area chart for fallen soldiers per week');
                
                const totalDays = this.getTotalTimelineDays();
                const weeklyData = [];
                
                // Add starting point at war beginning (Oct 7th) with 0 casualties
                weeklyData.push({
                    week: -1,
                    fallen: 0,
                    weekStart: new Date(this.startDate),
                    weekEnd: new Date(this.startDate),
                    displayDate: new Date(this.startDate)
                });
                
                // Group soldiers by week
                for (let week = 0; week < Math.ceil(totalDays / 7); week++) {
                    const weekStart = new Date(this.startDate);
                    weekStart.setDate(weekStart.getDate() + (week * 7));
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    
                    const weeklyFallen = this.soldiers.filter(soldier => {
                        return soldier.death_date >= weekStart && soldier.death_date <= weekEnd;
                    }).length;
                    
                    // Position this week's data at the END of the week (weekEnd) for chart alignment
                    weeklyData.push({
                        week: week,
                        fallen: weeklyFallen,
                        weekStart: weekStart,
                        weekEnd: weekEnd,
                        displayDate: weekEnd  // Use week end for positioning
                    });
                }
                
                // Find max value for scaling
                const maxFallen = Math.max(...weeklyData.map(d => d.fallen));
                if (maxFallen === 0) return; // No data to chart
                
                // Generate SVG path with smooth curves (RTL: newest weeks on left, oldest on right)
                const viewBoxWidth = 100;
                const viewBoxHeight = 40;
                
                // Create points array for smooth curve generation
                const points = [];
                weeklyData.forEach((week, index) => {
                    // Position each week's data at its display date for better alignment
                    const displayDaysFromToday = Math.floor((this.todayDate - week.displayDate) / (1000 * 60 * 60 * 24));
                    const x = (displayDaysFromToday / totalDays) * viewBoxWidth;
                    const y = viewBoxHeight - (week.fallen / maxFallen) * viewBoxHeight;
                    points.push({x, y, fallen: week.fallen, displayDate: week.displayDate});
                });
                
                // Sort points by X position for proper chart drawing
                points.sort((a, b) => a.x - b.x);
                
                // Start area path from bottom at first data point's X position
                let pathData = '';
                if (points.length > 0) {
                    pathData = `M ${points[0].x},${viewBoxHeight} L ${points[0].x},${points[0].y}`;
                }
                
                // Generate smooth curve using proper spline interpolation
                if (points.length > 1) {
                    for (let i = 1; i < points.length; i++) {
                        const prev = points[i-1];
                        const curr = points[i];
                        const next = points[i + 1] || curr;
                        const prevPrev = points[i - 2] || prev;
                        
                        // Calculate smooth control points using cardinal spline method
                        const tension = 0.3; // Controls curve tightness
                        
                        // Calculate tangent vectors for smooth flow
                        let cp1x, cp1y, cp2x, cp2y;
                        
                        if (i === 1) {
                            // First curve: control point 1 goes in direction toward current point
                            cp1x = prev.x + (curr.x - prev.x) * tension;
                            cp1y = prev.y + (curr.y - prev.y) * tension;
                        } else {
                            // Subsequent curves: control point 1 follows the flow from previous-previous to current
                            const tangentX = (curr.x - prevPrev.x) * tension;
                            const tangentY = (curr.y - prevPrev.y) * tension;
                            cp1x = prev.x + tangentX;
                            cp1y = prev.y + tangentY;
                        }
                        
                        if (i === points.length - 1) {
                            // Last curve: control point 2 comes from direction of previous point
                            cp2x = curr.x - (curr.x - prev.x) * tension;
                            cp2y = curr.y - (curr.y - prev.y) * tension;
                        } else {
                            // Other curves: control point 2 follows flow from previous to next
                            const tangentX = (next.x - prev.x) * tension;
                            const tangentY = (next.y - prev.y) * tension;
                            cp2x = curr.x - tangentX;
                            cp2y = curr.y - tangentY;
                        }
                        
                        pathData += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${curr.x},${curr.y}`;
                    }
                }
                
                // Close the path to form an area (go down to bottom at last point, then back to start)
                if (points.length > 0) {
                    const lastPoint = points[points.length - 1];
                    pathData += ` L ${lastPoint.x},${viewBoxHeight} L ${points[0].x},${viewBoxHeight} Z`;
                }
                
                // Update the SVG path
                const pathElement = document.getElementById('areaPath');
                if (pathElement) {
                    pathElement.setAttribute('d', pathData);
                }
                
                console.log(`RTL Area chart generated: ${weeklyData.length} weeks, max fallen: ${maxFallen}`);
                
                // Generate military events chart
                this.generateMilitaryEventsChart();
            }
            
            generateMilitaryEventsChart() {
                console.log('Generating military events combat intensity bar chart');
                
                if (!this.militaryEvents || this.militaryEvents.length === 0) {
                    console.log('No military events data available');
                    return;
                }
                
                const svg = document.querySelector('#timelineAreaChart svg');
                const totalDays = this.getTotalTimelineDays();
                const viewBoxWidth = 100;
                const viewBoxHeight = 40;
                
                // Clear existing military visualizations
                const existingMilitaryElements = svg.querySelectorAll('.military-bar, .military-path');
                existingMilitaryElements.forEach(element => element.remove());
                
                // Sort military events by date
                const sortedEvents = [...this.militaryEvents].sort((a, b) => a.eventDate - b.eventDate);
                
                // Create time periods for bar chart
                const timePeriods = [];
                let currentIntensity = 0; // Start with 0 intensity before first event
                
                // Add initial period from war start to first event
                if (sortedEvents.length > 0) {
                    const firstEventX = Math.floor((this.todayDate - sortedEvents[0].eventDate) / (1000 * 60 * 60 * 24));
                    const startX = Math.floor((this.todayDate - this.startDate) / (1000 * 60 * 60 * 24));
                    
                    timePeriods.push({
                        startDaysFromToday: startX,
                        endDaysFromToday: firstEventX,
                        intensity: 0, // No combat intensity before first event
                        startDate: this.startDate,
                        endDate: sortedEvents[0].eventDate
                    });
                }
                
                // Create periods between events
                sortedEvents.forEach((event, index) => {
                    const eventDaysFromToday = Math.floor((this.todayDate - event.eventDate) / (1000 * 60 * 60 * 24));
                    const nextEvent = sortedEvents[index + 1];
                    const endDaysFromToday = nextEvent ? 
                        Math.floor((this.todayDate - nextEvent.eventDate) / (1000 * 60 * 60 * 24)) : 0; // End at today if no next event
                    
                    currentIntensity = event.combatIntensity;
                    
                    timePeriods.push({
                        startDaysFromToday: eventDaysFromToday,
                        endDaysFromToday: endDaysFromToday,
                        intensity: currentIntensity,
                        startDate: event.eventDate,
                        endDate: nextEvent ? nextEvent.eventDate : this.todayDate,
                        event: event
                    });
                });
                
                // Create SVG rectangles for each time period
                timePeriods.forEach((period, index) => {
                    if (period.intensity === 0) return; // Skip zero-intensity periods for cleaner visualization
                    
                    // Calculate bar position and dimensions
                    const barStartX = (period.endDaysFromToday / totalDays) * viewBoxWidth;
                    const barEndX = (period.startDaysFromToday / totalDays) * viewBoxWidth;
                    const barWidth = barEndX - barStartX;
                    
                    // Calculate bar height based on intensity (scale to max 16km penetration)
                    // Leave more padding at top to ensure top border is always visible
                    const maxIntensity = 16;
                    const topPadding = 3; // Reserve 3px at top for border visibility
                    const availableHeight = viewBoxHeight - topPadding;
                    const barHeight = (period.intensity / maxIntensity) * availableHeight;
                    const barY = Math.max(topPadding, viewBoxHeight - barHeight); // Ensure minimum distance from top
                    
                    // Skip very narrow bars or bars that extend beyond viewbox
                    if (barWidth < 0.1 || barStartX < 0 || barEndX > viewBoxWidth) return;
                    
                    // Clamp bar boundaries to viewbox
                    const clampedStartX = Math.max(0, barStartX);
                    const clampedEndX = Math.min(viewBoxWidth, barEndX);
                    const clampedWidth = clampedEndX - clampedStartX;
                    
                    if (clampedWidth < 0.1) return; // Skip if clamped bar is too narrow
                    
                    // Create rectangle element using clamped coordinates
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('class', 'military-bar');
                    rect.setAttribute('x', clampedStartX);
                    rect.setAttribute('y', barY);
                    rect.setAttribute('width', clampedWidth);
                    rect.setAttribute('height', barHeight);
                    
                    // Style the bar with more transparent red
                    rect.style.fill = 'rgba(255, 100, 100, 0.06)'; // Even more transparent red
                    rect.style.stroke = 'none'; // No border on rectangle
                    rect.style.zIndex = '-1'; // Ensure behind area chart
                    
                    // Create top border line using clamped coordinates
                    const topBorder = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    topBorder.setAttribute('class', 'military-bar-border');
                    topBorder.setAttribute('x1', clampedStartX);
                    topBorder.setAttribute('y1', barY);
                    topBorder.setAttribute('x2', clampedEndX);
                    topBorder.setAttribute('y2', barY);
                    topBorder.style.stroke = 'rgba(255, 100, 100, 0.9)'; // Very opaque red border
                    topBorder.style.strokeWidth = '1'; // Thicker border for visibility
                    topBorder.style.zIndex = '-1'; // Ensure behind area chart
                    
                    // Add both elements behind the area chart
                    svg.insertBefore(rect, svg.firstChild);
                    svg.insertBefore(topBorder, svg.firstChild);
                    
                    console.log(`Bar ${index}: X=${barStartX}-${barEndX} (width=${barWidth}), Height=${barHeight}, Intensity=${period.intensity}`);
                });
                
                console.log(`Military events bar chart generated: ${timePeriods.length} periods, ${timePeriods.filter(p => p.intensity > 0).length} visible bars`);
            }

            setupEventListeners() {
                const slider = document.getElementById('timelineSlider');
                
                slider.addEventListener('input', (e) => {
                    const days = parseInt(e.target.value);
                    
                    // Mark as manual input (not animating)
                    this.isTimelineAnimating = false;
                    this.lastTooltipUpdate = Date.now();
                    
                    // Calculate end date going back from today
                    const newEndDate = new Date(this.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - days);
                    this.currentEndDate = newEndDate;
                    
                    // Update timeline progress (show war period from right, RTL)
                    const totalDays = this.getTotalTimelineDays();
                    const progress = ((totalDays - days) / totalDays) * 100;
                    document.getElementById('timelineProgress').style.width = progress + '%';
                    
                    // Update tooltip
                    this.updateTooltip(days, newEndDate);
                    
                    this.updateVisualization();
                });

                // Setup draggable container
                this.setupDraggableContainer();

                // Setup navigation CTAs
                this.setupNavigationCTAs();

                // Recalculate font size when window is resized with buffer
                window.addEventListener('resize', () => {
                    const container = document.getElementById('namesContainer');
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                    setTimeout(() => {
                        const availableWidth = container.clientWidth;
                        const availableHeight = container.clientHeight;
                        if (availableWidth > 0 && availableHeight > 0) {
                            this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                        }
                    }, 100);
                });
            }

            setupDraggableContainer() {
                const container = document.getElementById('draggableContainer');
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };

                container.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons directly
                    
                    isDragging = true;
                    
                    // Apply dragging class immediately for shadow feedback
                    container.classList.add('dragging');
                    
                    const rect = container.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    
                    // Keep container within viewport bounds
                    const maxX = window.innerWidth - container.offsetWidth;
                    const maxY = window.innerHeight - container.offsetHeight;
                    
                    const constrainedX = Math.max(0, Math.min(x, maxX));
                    const constrainedY = Math.max(0, Math.min(y, maxY));
                    
                    // Only change positioning method on first movement, not on mousedown
                    if (container.style.left === '' || container.style.left === 'auto') {
                        container.style.right = 'auto';
                        container.style.transform = 'none';
                    }
                    
                    container.style.left = constrainedX + 'px';
                    container.style.top = constrainedY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        container.classList.remove('dragging');
                    }
                });
            }

            setupNavigationCTAs() {
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');

                ctaBack.addEventListener('click', () => {
                    const prevPoint = this.narrative.getPrevPoint();
                    if (prevPoint) {
                        this.narrative.navigateToPoint(prevPoint.id);
                    }
                });

                ctaContinue.addEventListener('click', () => {
                    const nextPoint = this.narrative.getNextPoint();
                    if (nextPoint) {
                        this.narrative.navigateToPoint(nextPoint.id);
                    }
                });
            }

            updateTooltip(days, currentDate) {
                const tooltip = document.getElementById('timelineTooltip');
                const tooltipDate = document.getElementById('tooltipDate');
                const tooltipAlive = document.getElementById('tooltipAlive');
                const slider = document.getElementById('timelineSlider');
                const track = document.querySelector('.timeline-track');
                
                if (!tooltip || !tooltipDate || !tooltipAlive || !slider || !this.soldiers || !track) {
                    return; // Elements or data not ready yet
                }
                
                // Format date as dd/mm/yy
                const day = currentDate.getDate().toString().padStart(2, '0');
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const year = currentDate.getFullYear().toString().slice(-2);
                const formattedDate = `${day}/${month}/${year}`;
                
                // Calculate alive soldiers count
                const aliveSoldiers = this.soldiers.filter(s => 
                    s.death_date >= this.startDate && 
                    s.death_date > currentDate
                ).length;
                
                // Check if we're over a timeline event (when STOPPED, not transitioning)
                const eventAtDate = this.getEventAtDate(currentDate);
                const isStoppedOverEvent = eventAtDate && !this.isTimelineAnimating;
                
                if (isStoppedOverEvent) {
                    // Show event details in tooltip
                    const titleLink = eventAtDate.source && eventAtDate.source.startsWith('http')
                        ? `<a href="${eventAtDate.source}" target="_blank" style="color: #ffcc00; text-decoration: underline; cursor: pointer; font-weight: normal;">${eventAtDate.title_hebrew}</a>`
                        : `<span style="color: #ffcc00; font-weight: normal;">${eventAtDate.title_hebrew}</span>`;
                    tooltipDate.innerHTML = titleLink;
                    tooltipAlive.innerHTML = `
                        <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 6px;">
                            ${formattedDate}<br>${aliveSoldiers} soldiers alive
                        </div>
                    `;
                } else {
                    // Regular tooltip content
                    tooltipDate.textContent = formattedDate;
                    tooltipAlive.textContent = `${aliveSoldiers} soldiers alive`;
                }
                
                // Use setTimeout to ensure tooltip dimensions are updated after content change
                setTimeout(() => {
                    // Calculate handle position
                    const sliderValue = parseInt(slider.value);
                    const totalDays = this.getTotalTimelineDays();
                    const handlePercent = (sliderValue / totalDays) * 100;
                    
                    // Get tooltip dimensions (after content has been rendered)
                    const tooltipWidth = tooltip.offsetWidth;
                    const trackWidth = track.offsetWidth;
                    
                    // Use CSS centering method: position at handle location and let CSS center it
                    const handleLeft = (handlePercent / 100) * trackWidth;
                    
                    // Position tooltip at handle position (CSS translateX(-50%) will center it)
                    tooltip.style.left = handleLeft + 'px';
                    tooltip.style.transform = 'translateX(-50%)'; // Use CSS centering method
                    
                    // With CSS centering, triangle should be centered (50%)
                    tooltip.style.setProperty('--triangle-left', '50%');
                }, 0);
            }


            escapeHtml(text) {
                return text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;');
            }

            renderAllNames() {
                const container = document.getElementById('namesContainer');
                
                // Filter soldiers who died after Oct 27, 2023
                const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                
                if (relevantSoldiers.length === 0) {
                    container.innerHTML = '<div class="loading">No memorial data found</div>';
                    return;
                }

                // Sort by death date
                relevantSoldiers.sort((a, b) => a.death_date - b.death_date);

                const namesHtml = relevantSoldiers.map(soldier => {
                    return `<div class="soldier-name" data-death-date="${soldier.death_date.getTime()}" data-rank="${this.escapeHtml(soldier.rank)}" data-unit="${this.escapeHtml(soldier.unit)}">${soldier.name}</div>`;
                }).join('');

                container.innerHTML = namesHtml;
                
                // Setup custom tooltips for soldier names
                this.setupSoldierTooltips();
                
                // Initialize tooltip now that data is loaded
                this.updateTooltip(0, this.todayDate);
                
                // Wait for DOM to settle then calculate optimal font size with buffer
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 50);
            }

            setupSoldierTooltips() {
                const soldierNames = document.querySelectorAll('.soldier-name');
                const tooltip = document.getElementById('soldierTooltip');
                const soldierNameEl = document.getElementById('soldierName');
                const soldierDetailsEl = document.getElementById('soldierDetails');
                
                soldierNames.forEach(nameEl => {
                    nameEl.addEventListener('mouseenter', (e) => {
                        const name = nameEl.textContent;
                        const rank = nameEl.dataset.rank;
                        const unit = nameEl.dataset.unit;
                        const deathDate = new Date(parseInt(nameEl.dataset.deathDate));
                        
                        // Format date in Hebrew style
                        const formattedDate = deathDate.toLocaleDateString('he-IL');
                        
                        // Update tooltip content (compact format)
                        soldierNameEl.textContent = name;
                        soldierDetailsEl.innerHTML = `
                            <div>${rank}</div>
                            <div>${unit}</div>
                            <div style="opacity: 0.8;">${formattedDate}</div>
                        `;
                        
                        // Position tooltip
                        this.positionSoldierTooltip(e, tooltip);
                        
                        // Show tooltip
                        tooltip.classList.add('visible');
                    });
                    
                    nameEl.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('visible');
                    });
                    
                    nameEl.addEventListener('mousemove', (e) => {
                        if (tooltip.classList.contains('visible')) {
                            this.positionSoldierTooltip(e, tooltip);
                        }
                    });
                });
            }

            positionSoldierTooltip(mouseEvent, tooltip) {
                const mouseX = mouseEvent.clientX;
                const mouseY = mouseEvent.clientY;
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                // Position tooltip above the cursor with some offset
                let x = mouseX - tooltipWidth / 2;
                let y = mouseY - tooltipHeight - 15;
                
                // Adjust if tooltip would go off screen
                if (x < 10) x = 10;
                if (x + tooltipWidth > screenWidth - 10) x = screenWidth - tooltipWidth - 10;
                if (y < 10) y = mouseY + 15; // Show below cursor if no room above
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            applySafeFontSize() {
                console.log('Applying safe fixed font size');
                const soldierNames = document.querySelectorAll('.soldier-name');
                const safeFontSize = 7; // 4px * 1.8 = 7.2px
                
                soldierNames.forEach(name => {
                    name.style.fontSize = safeFontSize + 'px';
                });
                
                console.log(`Applied safe font size: ${safeFontSize}px to ${soldierNames.length} names`);
                
                // Verify it works
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const isOverflowing = container.scrollHeight > container.clientHeight;
                    console.log(`Safe font check - overflowing: ${isOverflowing}, scrollHeight: ${container.scrollHeight}, clientHeight: ${container.clientHeight}`);
                }, 100);
            }

            calculateOptimalFontSize(totalNames) {
                // This function is now deprecated - redirect to the proper calculation
                const container = document.getElementById('namesContainer');
                console.log('calculateOptimalFontSize called - redirecting to performFontSizeCalculation');
                
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(totalNames, availableWidth, availableHeight);
                    }
                }, 50);
            }
            
            debugOverflow(container, soldierNames, checkNumber) {
                const isOverflowing = container.scrollHeight > container.clientHeight;
                console.log(`\n--- OVERFLOW CHECK ${checkNumber} ---`);
                console.log(`Container scrollHeight: ${container.scrollHeight}px`);
                console.log(`Container clientHeight: ${container.clientHeight}px`);
                console.log(`Is overflowing: ${isOverflowing}`);
                console.log(`Overflow amount: ${container.scrollHeight - container.clientHeight}px`);
                
                // Check last visible elements
                const containerRect = container.getBoundingClientRect();
                let lastVisibleIndex = -1;
                
                soldierNames.forEach((name, index) => {
                    const rect = name.getBoundingClientRect();
                    if (rect.bottom <= containerRect.bottom && rect.top >= containerRect.top) {
                        lastVisibleIndex = index;
                    }
                });
                
                console.log(`Last visible name index: ${lastVisibleIndex} out of ${soldierNames.length}`);
                console.log(`Names potentially hidden: ${soldierNames.length - lastVisibleIndex - 1}`);
                
                // Show details of names around the cutoff
                for (let i = Math.max(0, lastVisibleIndex - 2); i < Math.min(soldierNames.length, lastVisibleIndex + 10); i++) {
                    const name = soldierNames[i];
                    const rect = name.getBoundingClientRect();
                    const isVisible = rect.bottom <= containerRect.bottom && rect.top >= containerRect.top;
                    console.log(`[${i}] "${name.textContent.substring(0, 15)}..." visible: ${isVisible}, bottom: ${rect.bottom}, container bottom: ${containerRect.bottom}`);
                }
                
                if (isOverflowing && checkNumber === 3) {
                    console.log(`\n!!! FINAL ATTEMPT - SETTING TO 9PX !!!`);
                    soldierNames.forEach(name => {
                        name.style.fontSize = '9px';
                    });
                }
            }

            performFontSizeCalculation(totalNames, availableWidth, availableHeight) {
                const soldierNames = document.querySelectorAll('.soldier-name');
                
                console.log(`\n=== MATHEMATICAL FONT CALCULATION ===`);
                console.log(`Names: ${totalNames}, Available: ${availableWidth}x${availableHeight}px`);
                
                // Use mathematical approach instead of trial-and-error
                const optimalFontSize = this.calculateOptimalFontSizeMathematically(
                    Array.from(soldierNames).map(el => el.textContent),
                    availableWidth,
                    availableHeight
                );
                
                console.log(`Calculated optimal font size: ${optimalFontSize}px`);
                
                // Apply the calculated font size
                soldierNames.forEach(name => {
                    name.style.fontSize = optimalFontSize + 'px';
                });
                
                // Verify the result
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const scrollHeight = container.scrollHeight;
                    const clientHeight = container.clientHeight;
                    const fillRatio = scrollHeight / clientHeight;
                    
                    console.log(`Verification: scrollHeight=${scrollHeight}px, clientHeight=${clientHeight}px`);
                    console.log(`Fill ratio: ${(fillRatio * 100).toFixed(1)}% (target: 90-98%)`);
                    
                    if (fillRatio < 0.85) {
                        console.log('⚠️ Under-filled, could use larger font');
                    } else if (fillRatio > 1.02) {
                        console.log('⚠️ Overflowing, need smaller font');
                        // Auto-correct if overflowing
                        const correctedSize = optimalFontSize * 0.95;
                        console.log(`Auto-correcting to ${correctedSize.toFixed(1)}px`);
                        soldierNames.forEach(name => {
                            name.style.fontSize = correctedSize + 'px';
                        });
                    } else {
                        console.log('✅ Good fill ratio achieved');
                    }
                }, 100);
            }
            
            calculateOptimalFontSizeMathematically(names, availableWidth, availableHeight) {
                // Step 1: Analyze the actual content
                const totalCharacters = names.reduce((sum, name) => sum + name.length, 0);
                const avgNameLength = totalCharacters / names.length;
                
                console.log(`Content analysis: ${totalCharacters} chars, avg ${avgNameLength.toFixed(1)} per name`);
                
                // Step 2: Font and layout constants (measured from Handjet font)
                const charWidthRatio = 0.55; // Character width relative to font size
                const lineHeight = 1.1; // From CSS
                const padding = 8; // 2px + 4px horizontal padding
                const gap = 3.3; // Gap between names
                
                // Step 3: Target fill ratio - aim to fill 95% of available space
                const targetFillRatio = 0.95;
                const targetHeight = availableHeight * targetFillRatio;
                
                console.log(`Target height: ${targetHeight}px (${(targetFillRatio*100).toFixed(0)}% of ${availableHeight}px)`);
                
                // Step 4: Binary search for optimal font size (much more efficient than old method)
                let minFont = 8;
                let maxFont = Math.min(200, availableHeight / 5); // Reasonable upper bound
                let bestFont = minFont;
                
                console.log(`Binary search range: ${minFont}px - ${maxFont}px`);
                
                for (let iteration = 0; iteration < 20; iteration++) {
                    const testFont = (minFont + maxFont) / 2;
                    const predictedHeight = this.predictLayoutHeight(names, testFont, availableWidth, charWidthRatio, lineHeight, padding, gap);
                    
                    console.log(`  Test ${testFont.toFixed(1)}px → height ${predictedHeight.toFixed(1)}px`);
                    
                    if (predictedHeight <= targetHeight) {
                        bestFont = testFont;
                        minFont = testFont;
                    } else {
                        maxFont = testFont;
                    }
                    
                    // Stop if we're close enough
                    if (maxFont - minFont < 0.5) break;
                }
                
                console.log(`Binary search result: ${bestFont.toFixed(1)}px`);
                
                // Step 5: Ensure reasonable bounds
                return Math.max(8, Math.min(150, bestFont));
            }
            
            predictLayoutHeight(names, fontSize, containerWidth, charWidthRatio, lineHeight, padding, gap) {
                // Predict how tall the layout will be at a given font size
                let currentRowWidth = 0;
                let rowCount = 1;
                const effectiveWidth = containerWidth - 10; // Small margin for centering
                
                for (const name of names) {
                    const nameWidth = (name.length * fontSize * charWidthRatio) + padding;
                    
                    // Check if this name fits on current row
                    if (currentRowWidth > 0 && currentRowWidth + gap + nameWidth > effectiveWidth) {
                        // Start new row
                        rowCount++;
                        currentRowWidth = nameWidth;
                    } else {
                        // Add to current row
                        currentRowWidth += (currentRowWidth > 0 ? gap : 0) + nameWidth;
                    }
                }
                
                // Calculate total height
                const rowHeight = fontSize * lineHeight;
                const totalHeight = rowCount * rowHeight + (rowCount - 1) * gap;
                
                return totalHeight;
            }

            updateVisualization() {
                // Update all soldier name elements
                const soldierElements = document.querySelectorAll('.soldier-name');
                let aliveCount = 0;
                
                console.log('updateVisualization called, currentEndDate:', this.currentEndDate);
                let dyingStarted = 0;
                
                // First pass: identify soldiers who should start dying
                const soldiersToStartDying = [];
                
                soldierElements.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    const previousState = this.soldierStates.get(elementId) || 'unknown';
                    
                    if (deathDate <= this.currentEndDate) {
                        // This soldier had already died by currentEndDate
                        if ((previousState === 'alive' || previousState === 'unknown') && !this.dyingTimeouts.has(elementId)) {
                            soldiersToStartDying.push(el);
                        }
                    }
                });
                
                // Second pass: start all dying animations simultaneously
                soldiersToStartDying.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    
                    el.className = 'soldier-name dying';
                    this.soldierStates.set(elementId, 'dying');
                    dyingStarted++;
                    
                    console.log(`Started dying animation for soldier ${el.textContent} (${deathDate.toDateString()})`);
                    
                    // Set timeout to start fade transition after initial highlight
                    const timeoutId = setTimeout(() => {
                        if (el.classList.contains('dying')) {
                            // Start gradual fade by adding dying-fade class
                            el.className = 'soldier-name dying dying-fade';
                        }
                        
                        // Set final timeout to complete transition
                        const finalTimeoutId = setTimeout(() => {
                            if (el.classList.contains('dying-fade')) {
                                el.className = 'soldier-name fallen';
                                this.soldierStates.set(elementId, 'fallen');
                            }
                        }, 600); // Match CSS transition duration
                        
                        this.dyingTimeouts.delete(elementId);
                    }, 100); // Hold red highlight for 100ms
                    
                    this.dyingTimeouts.set(elementId, timeoutId);
                });
                
                // Third pass: handle all other states
                soldierElements.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    const wasAlive = el.classList.contains('alive');
                    const isDying = el.classList.contains('dying');
                    const wasFallen = el.classList.contains('fallen');
                    const previousState = this.soldierStates.get(elementId) || 'unknown';
                    
                    if (deathDate > this.currentEndDate) {
                        // This soldier would still be alive at currentEndDate
                        this.soldierStates.set(elementId, 'alive');
                        if (!wasAlive) {
                            // Clear any dying timeout if soldier comes back to life
                            if (this.dyingTimeouts.has(elementId)) {
                                clearTimeout(this.dyingTimeouts.get(elementId));
                                this.dyingTimeouts.delete(elementId);
                            }
                            el.className = 'soldier-name alive';
                        }
                        aliveCount++;
                    } else {
                        // This soldier had already died by currentEndDate
                        if (isDying) {
                            // Currently dying, count as alive during highlight
                            aliveCount++;
                        } else if (!wasFallen && !isDying && previousState !== 'dying') {
                            // Should be fallen - handle case where soldier was never alive in this session
                            el.className = 'soldier-name fallen';
                            this.soldierStates.set(elementId, 'fallen');
                        }
                    }
                });
                
                console.log('Alive count:', aliveCount, 'out of', soldierElements.length, '| Dying animations started:', dyingStarted);
                
                // Update count in draggable container
                const aliveCountSpan = document.getElementById('aliveCount');
                if (aliveCountSpan) {
                    aliveCountSpan.textContent = aliveCount;
                }
                
                // Update narrative content to refresh placeholders
                if (this.narrative) {
                    this.narrative.updateNarrativeContent();
                }
            }
        }

        // Initialize the memorial
        new TimelineMemorial();
    </script>
</body>
</html>