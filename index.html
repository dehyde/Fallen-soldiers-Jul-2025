<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fallen Soldiers - Timeline Memorial</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Handjet:wght@100..900&family:Heebo:wght@100..900&family=Suez+One&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Heebo', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #333;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .stats-header {
            display: none;
        }

        .total-count {
            font-size: 3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .count-label {
            font-size: 1.2em;
            opacity: 0.7;
            color: #666;
        }

        .names-container {
            position: fixed;
            top: 200px;
            bottom: 170px; /* Stop 170px from bottom (130px timeline height + 40px margin) */
            left: 40px;
            right: 40px;
            z-index: 2000; /* Above timeline and other elements */
            overflow: visible; /* Make overflow visible instead of scrolling */
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            align-content: flex-start;
            gap: 3.3px;
            overflow: hidden;
            justify-content: center;
            direction: rtl;
        }

        .header-container {
            position: fixed;
            top: 50px;
            right: 50px;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
            z-index: 1000;
        }

        .timeline-description {
            font-family: 'Heebo', sans-serif;
            font-size: 14px;
            color: #888;
            width: 75%;
            max-width: 500px;
            text-align: right !important; /* Force right alignment */
            line-height: 1.4;
            opacity: 0.9;
            position: absolute;
            right: 560px;
            top: 50%;
            direction: rtl !important; /* Ensure RTL direction */
            transform: translateY(-50%);
            transition: opacity 0.3s ease;
            white-space: normal;
        }

        .timeline-description-text {
            text-align: right !important; /* Force right alignment for description text */
            direction: rtl !important; /* Ensure RTL direction */
        }
        
        .timeline-description span:not(.timeline-description-link),
        .timeline-description .timeline-description-text,
        span.timeline-description-text {
            text-align: right !important; /* Force right alignment for all child elements */
            direction: rtl !important; /* Force RTL direction */
        }

        .timeline-description-link {
            color: #666;
            text-decoration: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            display: inline;
            direction: ltr !important; /* Keep icon in normal LTR direction */
        }

        .timeline-description-link:hover {
            opacity: 1;
            color: #333;
        }

        .timeline-description-link .lucide {
            width: 16px;
            height: 16px;
        }

        .header-info {
            width: 250px;
            font-family: 'Heebo', sans-serif;
            font-size: 14px;
            color: #666;
            text-align: right;
            direction: rtl;
            line-height: 1.4;
            flex-shrink: 0;
            display: none;
        }

        /* Desktop status components positioning */
        .desktop-status-components-container {
            position: fixed;
            top: 120px;
            right: 50px;
            z-index: 1000;
        }

        /* Mobile status components inside header-container (hidden on desktop) */
        .status-components-container {
            display: none;
        }

        .mobile-title-cta-row {
            display: contents; /* On desktop, don't create flex container */
        }

        .status-components {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
            align-items: flex-end;
            justify-content: flex-start;
            min-width: 300px;
            width: 300px;
            text-align: right;
        }

        .status-component {
            height: 21px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            width: fit-content;
            margin-left: auto;
        }

        .alive-status {
            background: #E7F0FF; /* Same as living soldier background */
        }

        .fallen-status {
            background: rgba(0,0,0,0.1); /* Gray semi-transparent like fallen soldiers */
        }

        .status-text {
            font-family: 'Heebo', sans-serif;
            font-size: 14px;
            font-weight: 400;
            padding: 2px 4px;
            text-align: right;
            direction: rtl;
            white-space: nowrap;
        }

        .alive-status .status-text {
            color: #1168FF; /* Same as living soldier text */
        }

        .fallen-status .status-text {
            color: #666; /* Gray like fallen soldiers */
            opacity: 0.7; /* Semi-transparent like fallen soldiers */
        }

        .names-title {
            width: 400px;
            font-family: 'Suez One', serif;
            font-size: 24px;
            font-weight: 800;
            color: #4e4e4e;
            text-align: right;
            direction: rtl;
            line-height: 1.2;
            flex-shrink: 0;
            position: relative;
        }

        .selected-date-in-title {
            font-family: 'Heebo', sans-serif;
            font-size: 20px;
            font-weight: 300;
            color: #666666;
            letter-spacing: 0.06em;
            right: 12px;
        }

        .soldier-name {
            font-family: 'Handjet', monospace;
            font-size: 1px; /* will be dynamically calculated */
            font-weight: 400;
            padding: 2px 4px;
            background: rgba(0,0,0,0.1);
            cursor: pointer;
            line-height: 1.1; /* This matches the calculation */
            text-decoration: none;
            -webkit-text-decoration-line: none;
            text-decoration-line: none;
            overflow: visible; /* Ensure names aren't cut off */
            font-feature-settings: normal;
            transition: background-color 0.15s ease, color 0.15s ease;
        }

        .soldier-name:hover,
        .soldier-name.auto-hover-active {
            background: rgba(0,0,0,0.8) !important;
            color: white !important;
            z-index: 10;
            position: relative;
        }

        .soldier-name.fallen {
            opacity: 0.2;
            background: rgba(255,100,100,0.1);
        }

        .soldier-name.alive {
            opacity: 1;
            background: #E7F0FF;
            color: #1168FF;
        }

        .soldier-name.dying {
            opacity: 1;
            background: rgba(139, 0, 0, 0.8) !important; /* Dark red background */
            color: rgb(255, 69, 69) !important; /* Bright red text */
            font-weight: bold;
            z-index: 100;
            position: relative;
            /* No transition on initial red state - instant change from blue to red */
        }

        .soldier-name.dying-fade {
            opacity: 0.2;
            background: rgba(255,100,100,0.1) !important;
            color: inherit !important;
            font-weight: normal !important;
            z-index: auto !important;
            transition: opacity 0.6s ease-out, background-color 0.6s ease-out, color 0.6s ease-out;
        }

        .timeline-container {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            height: 130px; /* Reduced from 200px to 130px for more names space */
            background: transparent;
            cursor: default;
            /* Remove top border */
            /* border-top: 2px solid rgba(0,0,0,0.3); */
            /* Remove shadow */
            /* box-shadow: 0 -4px 20px rgba(0,0,0,0.1); */
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 20px 50px 30px 50px; /* Reduced top padding from 100px to 20px */
            z-index: 100;
        }

.timeline-track {
    position: relative;
    height: 1px;
    background: repeating-linear-gradient(
        to right,
        #1168FF 0px,
        #1168FF 4px,
        transparent 4px,
        transparent 6px
    );
    border-radius: 0;
    margin: 5px 0 15px 0;
    border: none;
    cursor: default;
    z-index: 0; /* Allow markers to be on top */
}

        .timeline-progress {
            position: absolute;
            top: -1.5px; /* Center the 4px progress bar on the 1px track */
            right: 0;
            height: 4px;
            width: 0%;
            background: #000;
            border-radius: 0;
            transition: none;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-axis {
            position: absolute;
            top: 5px;
            left: 0;
            right: 0;
            height: 10px;
            z-index: 5;
            pointer-events: auto;
        }

        .timeline-legend {
            position: absolute;
            top: -25px;
            left: 20px;
            display: flex;
            gap: 12px;
            font-family: 'Heebo', sans-serif;
            font-size: 9px;
            font-weight: 400;
            direction: rtl;
            z-index: 10;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
            direction: rtl;
        }

        .legend-color {
            width: 6px;
            height: 6px;
            border-radius: 1px;
            transform: rotate(45deg);
        }

        .legend-color.blue {
            background: #1168FF;
        }

        .legend-color.orange {
            background: #FF8800;
        }

        .legend-color.black {
            background: #000000;
        }

        .legend-text {
            color: #666;
            white-space: nowrap;
        }

        .timeline-tick {
            position: absolute;
            width: 1px;
            height: 2px;
            background: rgba(0,0,0,0.4);
            top: 0;
        }

        .timeline-tick.major {
            height: 3px;
            width: 1px;
            background: rgba(0,0,0,0.6);
        }

        .timeline-date-label {
            position: absolute;
            top: 5px;
            font-size: 9px;
            color: #666;
            white-space: nowrap;
            transform: translateX(-50%);
            font-weight: 500;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .timeline-slider {
            width: calc(100% + 16px);
            height: 4px;
            background: transparent;
            outline: none;
            position: absolute;
            left: -8px; /* Offset by half handle width to align handle center with track edges */
            top: -1.5px; /* Center slider on track to align thumb with progress bar */
            cursor: default;
            -webkit-appearance: none;
            z-index: 50; /* Higher than markers */
            pointer-events: none; /* Don't block markers */
        }

        .timeline-slider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333;
            border: none;
            outline: none;
            pointer-events: none; /* Don't block marker hover */
        }

        #timelineSlider::-webkit-slider-track {
            -webkit-appearance: none;
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--handle-background, linear-gradient(135deg, #333 0%, #555 100%));
            border: var(--handle-border, 2px solid #fff);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            opacity: 1;
            z-index: 10000; /* Extremely high z-index for handle */
            pointer-events: auto; /* Handle should be draggable */
        }
        
        .timeline-slider:active::-webkit-slider-thumb {
            cursor: grabbing;
        }

        .timeline-container:hover .timeline-slider::-webkit-slider-thumb {
            opacity: 1;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(0,0,0,0.2);
        }

        .timeline-slider::-moz-range-track {
            height: 2px;
            background: #333;
            border: none;
            outline: none;
            pointer-events: none; /* Don't block marker hover */
        }

        #timelineSlider::-moz-range-track {
            height: 2px;
            background: #333 !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        #timelineSlider {
            background: transparent !important;
            border: none !important;
            outline: none !important;
        }

        .timeline-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--handle-background, linear-gradient(135deg, #333 0%, #555 100%));
            border: var(--handle-border, 2px solid #fff);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            opacity: 1;
            transition: opacity 0.2s ease;
            z-index: 10000; /* Extremely high z-index for handle */
            pointer-events: auto; /* Handle should be draggable */
        }
        
        .timeline-slider:active::-moz-range-thumb {
            cursor: grabbing;
        }

        .timeline-container:hover .timeline-slider::-moz-range-thumb {
            opacity: 1;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }

        .timeline-handle-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px 12px;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 50;
            pointer-events: none; /* Don't block marker hover events */
            opacity: 0; /* Hidden by default, shown on timeline hover */
            transform: translateX(-50%);
            bottom: 15px; /* Changed from top: -65px to grow upwards */
            font-family: 'Heebo', sans-serif;
            text-align: center;
            line-height: 1.3;
            min-width: max-content; /* Ensure tooltip maintains natural width */
            max-width: 300px; /* Allow for wider content when showing events */
            box-sizing: border-box; /* Include padding in width calculations */
        }

        .timeline-handle-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px; /* Changed from top: 100% to bottom of tooltip */
            left: var(--triangle-left, 50%); /* Use custom property with 50% fallback */
            margin-left: -5px;
            border: 5px solid transparent;
            border-top-color: rgba(255, 255, 255, 0.98); /* Triangle points down from tooltip */
            transition: var(--triangle-transition, left 0.1s ease); /* Dynamic transition control */
        }

        /* Timeline handle tooltip hidden by default - only show on timeline hover */

        /* Timeline track hover states */
        .timeline-track.hovering .timeline-slider::-webkit-slider-thumb {
            opacity: 1;
        }

        .timeline-track.hovering .timeline-slider::-moz-range-thumb {
            opacity: 1;
        }

        .timeline-track.hovering .timeline-handle-tooltip {
            opacity: 1;
        }
        
        /* Show tooltip when hovering over timeline container */
        .timeline-container:hover .timeline-handle-tooltip {
            opacity: 1;
        }

        /* Timeline cursor states */
        .timeline-container.track-hovering {
            cursor: default;
        }

        .timeline-container.track-hovering.on-event {
            cursor: pointer;
        }


        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.5em;
        }

        .draggable-container {
            position: fixed;
            top: 50%;
            right: 100px;
            transform: translateY(-50%);
            width: 280px;
            background: rgba(255,255,255,0.45);
            backdrop-filter: blur(8px);
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 15000;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.8s ease;
            display: none;
        }

        .draggable-container.narrative-opaque {
            background: rgba(255,255,255,0.90);
        }

        .draggable-container:hover {
            cursor: grab;
            background: rgba(250,250,250,0.55);
        }

        .draggable-container.narrative-opaque:hover {
            background: rgba(250,250,250,0.95);
        }

        .draggable-container:active {
            cursor: grabbing;
        }


        .draggable-container.dragging {
            box-shadow: 0 20px 64px rgba(0,0,0,0.15);
            transition: box-shadow 0.1s ease;
        }


        .draggable-content {
            padding: 20px;
            cursor: inherit;
            direction: rtl;
            text-align: right;
        }

        .content-text {
            font-size: 1.1em;
            line-height: 1.4;
            color: #333;
            margin-bottom: 20px;
            font-family: 'Heebo', sans-serif;
            cursor: inherit;
        }

        .content-text p {
            margin-bottom: 12px;
        }

        .content-text p:last-child {
            margin-bottom: 0;
        }

        .cta-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            cursor: grab;
        }

        .cta-buttons:hover {
            cursor: grab;
        }

        .cta-buttons:active {
            cursor: grabbing;
        }

        .cta-primary {
            background: transparent;
            color: #333;
            border: 2px solid rgba(0,0,0,0.3);
            padding: 10px 20px;
            font-size: 0.9em;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .cta-primary::after {
            content: '›';
            font-size: 18px;
            margin-right: 8px;
            margin-top: 2px;
        }

        .cta-primary:hover {
            opacity: 0.7;
        }

        .cta-tertiary {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 2px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Heebo', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            text-indent: -9999px;
            overflow: hidden;
            position: relative;
        }

        .cta-tertiary::after {
            content: '‹';
            font-size: 18px;
            font-weight: bold;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-indent: 0;
        }

        .cta-tertiary:hover {
            background: rgba(0,0,0,0.05);
            border-color: #bbb;
        }

        /* Legacy .cta-skip-back styles removed - replaced with .header-cta-container */

        /* Header CTA container for icon and date separation */
        .header-cta-container {
            display: flex !important;
            align-items: center !important;
            gap: 12px !important;
            position: absolute !important;
            left: -120px !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            z-index: 1001 !important;
        }

        /* Icon-only button modifier */
        .cta-primary.icon-only {
            background: #000 !important;
            color: #fff !important;
            border: none !important;
            border-radius: 4px !important;
            padding: 8px !important;
            min-width: auto !important;
            width: auto !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }

        .cta-primary.icon-only::after {
            display: none !important;
        }

        .cta-primary.icon-only:hover {
            opacity: 0.8 !important;
            transform: scale(1.05) !important;
        }

        .cta-primary.icon-only svg {
            width: 16px !important;
            height: 16px !important;
            stroke-width: 2 !important;
        }

        /* Header date styling */
        .header-date {
            font-family: 'Heebo', sans-serif !important;
            font-size: 22px !important;
            font-weight: 200 !important;
            color: #4e4e4e !important;
            pointer-events: none !important;
            user-select: none !important;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 20000;
            pointer-events: auto;
        }

        /* Initial modal container - matches narrative container design */
        .initial-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            background: rgba(255,255,255,0.35);
            backdrop-filter: blur(5px);
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 20001;
            direction: rtl;
            transition: background 0.8s ease;
        }

        .initial-modal:hover {
            background: rgba(250,250,250,0.45);
        }

        .initial-modal-content {
            padding: 20px;
            text-align: right;
        }

        .initial-modal-text {
            font-size: 1.1em;
            line-height: 1.4;
            color: #333;
            margin-bottom: 20px;
            font-family: 'Heebo', sans-serif;
        }

        .initial-modal-cta {
            display: flex;
            justify-content: flex-end;
        }

        /* Override modal CTA button to original black design without chevron */
        .initial-modal-cta .cta-primary {
            background: #000 !important;
            color: #fff !important;
            border-radius: 4px;
        }

        .initial-modal-cta .cta-primary::after {
            display: none; /* Remove chevron */
        }

        /* Blur and fade specific elements when modal is open */
        .timeline-container,
        .header-container,
        .status-components-container,
        .desktop-status-components-container {
            transition: filter 0.4s ease, opacity 0.4s ease;
        }

        .modal-open .timeline-container,
        .modal-open .header-container,
        .modal-open .status-components-container,
        .modal-open .desktop-status-components-container {
            filter: blur(3px);
            opacity: 0.3;
        }

        .timeline-tooltip {
            /* Reset inherited styles */
            all: initial;
            /* Apply our intended styles */
            position: absolute;
            background: rgba(255, 255, 255, 0.98) !important;
            color: #333 !important;
            padding: 12px 16px !important;
            border-radius: 4px !important;
            border-top-left-radius: 4px !important;
            border-top-right-radius: 4px !important;
            border-bottom-left-radius: 4px !important;
            border-bottom-right-radius: 4px !important;
            font-size: 13px !important;
            max-width: 400px !important;
            min-width: 250px !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            direction: rtl !important;
            text-align: right !important;
            font-family: 'Heebo', sans-serif !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            line-height: 1.4 !important;
            backdrop-filter: blur(10px) !important;
            display: block !important;
        }

        .timeline-tooltip strong {
            display: block !important;
            margin-bottom: 8px !important;
            color: #000 !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            font-family: 'Heebo', sans-serif !important;
        }

        .timeline-living-chart {
            position: absolute;
            top: -40px;
            left: 0;
            right: 0;
            height: 40px;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-living-chart svg {
            width: 100%;
            height: 100%;
        }

        .timeline-area-chart {
            position: absolute;
            bottom: -40px;
            left: 0;
            right: 0;
            height: 40px;
            z-index: 1;
            pointer-events: none;
        }

        .timeline-area-chart svg {
            width: 100%;
            height: 100%;
        }

        .living-path-past {
            fill: rgba(17, 104, 255, 0.3);
            stroke: none;
            transition: fill 0.2s ease;
        }

        .living-path-future {
            fill: rgba(17, 104, 255, 0.15);
            stroke: none;
            transition: fill 0.2s ease;
        }

        .area-path-past {
            fill: rgba(180, 180, 180, 0.175);
            stroke: none;
            transition: fill 0.2s ease;
        }

        .area-path-future {
            fill: rgba(180, 180, 180, 0);
            stroke: none;
            transition: fill 0.2s ease;
        }



        .timeline-event-marker {
            width: 8px !important;
            height: 8px !important;
            display: block !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }

        .timeline-event-marker:hover,
        .could-have-ended-marker:hover {
            width: 14px !important;
            height: 14px !important;
            transform: translate(-50%, -50%) scale(1.2) !important;
            transition: all 0.2s ease !important;
        }

        .could-have-ended-marker.transform-to-triangle:hover {
            width: 12px !important;
            height: 12px !important;
            transform: translate(-50%, -50%) rotate(45deg) scale(1.3) !important;
            transition: all 0.2s ease !important;
        }
        .could-have-ended-marker {
            transition: all 0.2s ease;
            cursor: pointer !important;
        }

        
        /* Diamond style for transformed markers (persists across narrative points) */
        .could-have-ended-marker.transform-to-triangle {
            width: 8px !important;
            height: 8px !important;
            border: none !important;
            background: rgba(0,56,168,0.9) !important;
            border-radius: 2px !important;
            transform: translate(-50%, -50%) rotate(45deg) !important;
        }
        
        /* Hover effect for diamonds (works on all narrative points) */
        .timeline-container:hover .could-have-ended-marker.transform-to-triangle {
            width: 10px !important;
            height: 10px !important;
            background: rgba(0,56,168,1) !important;
            transform: translate(-50%, -50%) rotate(45deg) !important;
        }

        /* Regular event diamond styling (mustard color) */
        .regular-event-diamond {
            width: 8px !important;
            height: 8px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }

        .regular-event-diamond:hover {
            width: 14px !important;
            height: 14px !important;
            transform: translate(-50%, -50%) rotate(45deg) scale(1.2) !important;
        }

        /* Timeline event diagonal labels */
        .timeline-event-label {
            display: none; /* Hide completely */
            font-family: 'Heebo', sans-serif;
            font-size: 10px;
            color: #bbb;
            white-space: nowrap;
            z-index: 101;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            opacity: 0;
            visibility: hidden;
        }

        /* Hide labels even on timeline container hover */
        .timeline-container:hover .timeline-event-label {
            opacity: 0;
        }

        /* Priority styling for war-ending events (hidden) */
        .timeline-event-label.war-ending {
            opacity: 0;
            visibility: hidden;
        }

        .regular-event-diamond {
            background: #ff8800 !important;
            border: none !important;
            border-radius: 2px !important;
            transform: translate(-50%, -50%) rotate(45deg) !important;
            transition: all 0.4s ease;
        }

        /* Hover effect for regular diamonds */
        .timeline-container:hover .regular-event-diamond {
            width: 10px !important;
            height: 10px !important;
            background: #ff8800 !important;
            transform: translate(-50%, -50%) rotate(45deg) !important;
        }

        .military-bar {
            transition: fill 0.2s ease;
        }

        .timeline-container:not(:hover) .military-bar {
            fill: rgba(255, 100, 100, 0) !important;
        }

        .military-bar-border {
            transition: stroke 0.2s ease;
        }

        .timeline-container:not(:hover) .military-bar-border {
            stroke: rgba(255, 100, 100, 0) !important;
        }
        
        /* RESTORE VERY OLD SIMPLE CSS HOVER - this was the working approach! */
        .timeline-event-marker {
            width: 8px !important;
            height: 8px !important;
            transition: width 0.2s ease, height 0.2s ease;
        }
        
        .timeline-container:hover .timeline-event-marker {
            width: 12px !important;
            height: 12px !important;
        }

        .soldier-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.95) !important;
            color: #333 !important;
            padding: 4px !important;
            border-radius: 6px !important;
            z-index: 5000; /* Above names list (2000) and other elements */
            font-size: 11px !important;
            width: auto !important;
            white-space: normal !important;
            pointer-events: none !important;
            text-align: center !important;
            font-family: 'Heebo', sans-serif !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
            border: 1px solid rgba(0,0,0,0.15) !important;
            line-height: 1.2 !important;
            backdrop-filter: blur(5px) !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transform: translateY(5px) rotate(var(--tilt-angle, 0deg));
            --tilt-angle: 0deg;
            transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
        }

        .soldier-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) rotate(var(--tilt-angle, 0deg));
            transition: opacity 1s ease, visibility 1s ease, transform 1s ease;
        }
        
        .soldier-text {
            margin-top: 8px;
            text-align: right;
            padding-right: 2px;
            width: 120px;
            white-space: normal;
        }

        .soldier-tooltip strong {
            display: block !important;
            margin-bottom: 2px !important;
            color: #333 !important;
            font-weight: 600 !important;
            font-size: 12px !important;
            font-family: 'Heebo', sans-serif !important;
        }

        .soldier-tooltip .soldier-details {
            font-size: 10px !important;
            color: #555 !important;
            line-height: 1.2 !important;
        }

        /* Fallen soldier photo styling */
        .soldier-name.fallen:hover .soldier-tooltip img,
        .soldier-name.fallen + .soldier-tooltip img,
        .soldier-tooltip.fallen img {
            filter: grayscale(100%) opacity(0.6) contrast(1.3) brightness(1.2) !important;
        }

        /* Living soldier photo styling */
        .soldier-name.alive:hover .soldier-tooltip img,
        .soldier-name.alive + .soldier-tooltip img,
        .soldier-tooltip.alive img {
            filter: saturate(0.6) brightness(1.35) opacity(0.85) contrast(1.3) !important;
        }

        /* Living soldier photo container shadow */
        .soldier-name.alive:hover .soldier-tooltip,
        .soldier-name.alive + .soldier-tooltip,
        .soldier-tooltip.alive {
            box-shadow: 0 4px 12px rgba(17, 104, 255, 0.3) !important;
        }

        /* Ensure identical text styling for both living and fallen */
        .soldier-tooltip.alive .soldier-details,
        .soldier-tooltip.fallen .soldier-details {
            font-size: 10px !important;
            color: #555 !important;
            line-height: 1.2 !important;
        }

        .soldier-tooltip.alive strong,
        .soldier-tooltip.fallen strong {
            font-size: 12px !important;
            font-weight: 600 !important;
            color: #333 !important;
        }

        /* Mobile Layout */
        @media (max-width: 768px) {
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                overflow: hidden !important;
                background: white !important;
                font-family: 'Heebo', sans-serif !important;
            }

            /* Hide desktop-only elements */
            .draggable-container,
            .header-info,
            .timeline-living-chart {
                display: none !important;
            }

            /* Mobile header container */
            .header-container {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                padding: 12px 15px !important;
                background: white !important;
                border-bottom: none !important;
                z-index: 1000 !important;
                display: flex !important;
                height: auto !important;
                flex-direction: column !important;
                gap: 8px !important;
                box-sizing: border-box !important;
                overflow: hidden !important;
            }

            /* Mobile title and CTA container */
            .mobile-title-cta-row {
                display: flex !important;
                flex-direction: row-reverse !important;
                justify-content: flex-start !important;
                align-items: flex-start !important;
                gap: 10px !important;
                width: 100% !important;
            }

            /* Mobile title */
            .names-title {
                flex: 1 !important;
                font-size: 16px !important;
                line-height: 1.3 !important;
                text-align: right !important;
                margin-bottom: 0 !important;
                padding-right: 0 !important;
                margin-right: 0 !important;
                overflow-wrap: break-word !important;
                word-break: break-word !important;
                min-width: 0 !important;
            }

            /* Hide line break in mobile title */
            .names-title br {
                display: none !important;
            }

            /* Mobile timeline description */
            .timeline-description {
                display: block !important;
                position: fixed !important;
                top: 135px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: calc(100% - 30px) !important;
                max-width: calc(100vw - 30px) !important;
                font-size: 12px !important;
                line-height: 1.4 !important;
                color: #666 !important;
                margin: 0 !important;
                padding: 12px 15px !important;
                min-height: 45px !important;
                text-align: center !important;
                direction: rtl !important;
                z-index: 999 !important;
                background: transparent !important;
            }

            /* Mobile description link - make entire text clickable without visual link styling */
            .timeline-description-mobile-link {
                color: #666 !important;
                text-decoration: none !important;
                display: block !important;
                width: 100% !important;
                height: 100% !important;
            }

            .timeline-description-mobile-link:hover,
            .timeline-description-mobile-link:active {
                color: #333 !important;
                text-decoration: none !important;
            }

            /* Mobile timeline container */
            .timeline-container {
                display: block !important;
                position: fixed !important;
                top: 105px !important;
                left: 15px !important;
                right: 15px !important;
                height: 25px !important;
                z-index: 998 !important;
                margin: 0 !important;
                padding: 2px 0 !important;
            }

            /* Hide all tooltips on mobile */
            .timeline-tooltip,
            .timeline-handle-tooltip,
            .soldier-tooltip {
                display: none !important;
            }

            /* Mobile timeline track */
            .timeline-track {
                height: 1px !important;
                margin: 8px 0 !important;
            }

            /* Mobile timeline slider */
            .timeline-slider {
                height: 1px !important;
                margin: 0 !important;
            }

            /* Mobile timeline handle */
            .timeline-slider::-webkit-slider-thumb {
                width: 16px !important;
                height: 16px !important;
                border-radius: 50% !important;
            }

            .timeline-slider::-moz-range-thumb {
                width: 16px !important;
                height: 16px !important;
                border-radius: 50% !important;
            }

            /* Hide all event markers completely on mobile */
            .event-marker,
            .timeline-container .event-marker,
            .timeline-track .event-marker,
            .timeline-legend,
            .could-have-ended-marker,
            .war-ending-marker,
            [class*="marker"] {
                display: none !important;
            }

            /* Hide all timeline ticks and labels by default, then show specific ones */
            .timeline-tick,
            .timeline-date-label {
                display: none !important;
            }

            /* Show only specific timeline ticks and labels on mobile */
            .timeline-tick.mobile-show,
            .timeline-date-label.mobile-show {
                display: block !important;
            }

            /* Style mobile timeline ticks */
            .timeline-tick.mobile-show {
                height: 3px !important;
                width: 1px !important;
                background: rgba(0,0,0,0.6) !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
            }

            /* Style mobile timeline date labels - very close to timeline */
            .timeline-date-label.mobile-show {
                font-size: 10px !important;
                top: 5px !important;
                transform: translateX(-50%) !important;
                white-space: nowrap !important;
                color: #666 !important;
                background: transparent !important;
                padding: 1px 3px !important;
                border-radius: 2px !important;
                z-index: 1000 !important;
            }

            /* Hide desktop status components on mobile */
            .desktop-status-components-container {
                display: none !important;
            }

            /* Mobile status components */
            .status-components-container {
                position: relative !important;
                top: auto !important;
                right: auto !important;
                margin-top: 8px !important;
                display: block !important;
                width: 100% !important;
                flex: 1 !important;
            }

            .status-components {
                display: flex !important;
                flex-direction: row !important;
                width: 100% !important;
                gap: 4px !important;
                align-items: stretch !important;
                justify-content: space-between !important;
            }

            .status-component {
                flex: 1 !important;
                padding: 4px !important;
                border-radius: 4px !important;
                width: auto !important;
                margin: 0 !important;
                height: auto !important;
                text-align: center !important;
            }

            .status-text {
                font-size: 11px !important;
                text-align: center !important;
                white-space: normal !important;
                line-height: 1.3 !important;
            }

            /* Mobile header CTA container */
            .header-cta-container {
                position: relative !important;
                bottom: auto !important;
                left: auto !important;
                transform: none !important;
                top: auto !important;
                display: flex !important;
                align-items: center !important;
                gap: 8px !important;
                z-index: 999 !important;
                flex-shrink: 0 !important;
                white-space: nowrap !important;
            }

            /* Mobile icon button */
            .cta-primary.icon-only {
                background: #000 !important;
                color: #fff !important;
                border: none !important;
                border-radius: 4px !important;
                padding: 8px !important;
                font-size: 14px !important;
            }

            .cta-primary.icon-only:hover {
                opacity: 0.7 !important;
                transform: none !important;
            }

            .cta-primary.icon-only:active {
                transform: scale(0.95) !important;
            }

            /* Mobile date styling */
            .header-date {
                font-size: 14px !important;
                font-weight: 400 !important;
                margin-right: 8px !important;
                margin-left: 4px !important;
            }

            /* Mobile names container */
            .names-container {
                position: fixed !important;
                top: 210px !important;
                bottom: 20px !important;
                left: 10px !important;
                right: 10px !important;
                overflow: auto !important;
                -webkit-overflow-scrolling: touch !important;
                padding: 5px !important;
                display: flex !important;
                flex-wrap: wrap !important;
                align-content: flex-start !important;
                gap: 2px !important;
                justify-content: center !important;
                direction: rtl !important;
            }

            /* Mobile soldier names */
            .soldier-name {
                font-size: 9px !important;
                padding: 1px 3px !important;
                line-height: 1.2 !important;
            }

            /* Simplified tooltip for mobile */
            .soldier-tooltip {
                max-width: 250px !important;
                font-size: 10px !important;
                padding: 8px !important;
            }

            .soldier-tooltip .soldier-photo {
                display: none !important;
            }

            .soldier-tooltip strong {
                font-size: 11px !important;
            }

            .soldier-tooltip .soldier-details {
                font-size: 9px !important;
            }
        }
        
        /* Narrative number color classes */
        .fallen-soldiers-number {
            color: #8B0000 !important; /* Dark red for fallen soldiers */
            font-weight: 400 !important;
        }
        
        .alive-soldiers-number {
            color: #1168FF !important;
            background: #E7F0FF !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            font-weight: 600 !important;
        }
    </style>

    <script>
        // Protocol-aware fetch wrapper for file:// support
        async function safeFetch(url) {
            try {
                // Try normal fetch first (works for localhost and https)
                const response = await fetch(url);
                if (response.ok) {
                    return response;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            } catch (error) {
                // If fetch fails and we're on file:// protocol, try alternative approaches
                if (window.location.protocol === 'file:') {
                    console.warn(`Fetch failed for ${url} on file:// protocol:`, error.message);
                    console.warn('Please use a local server (e.g., python -m http.server) for full functionality');
                    
                    // For file:// protocol, we need to inform the user
                    throw new Error(`File loading requires a local server. Please run:\npython -m http.server\nor\nnpx serve\nThen access via http://localhost:8000/`);
                }
                throw error;
            }
        }
    </script>
</head>
<body>
    <!-- Initial Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="initial-modal" id="initialModal">
            <div class="initial-modal-content">
                <div class="initial-modal-text" id="initialModalText">
                    שבועיים אחרי השביעי באוקטובר צה״ל סיים את ההערכות למתקפה הקרקעית בעזה, שהייתה ירית הפתיחה למלחמה שמדינת ישראל מובילה עד היום.<br><br>
                    השלב הזה במלחמה שנמשך גם בימים אלו גבה עד היום את חייהם של <span id="modalTotalSoldiers">___</span> חיילים במשך <span id="modalMonthsOfFighting">___</span> חודשים של לחימה.<br><br>
                    את המחיר של אי-סיום המלחמה משלמים החיילים בחייהם.
                </div>
                <div class="initial-modal-cta">
                    <button class="cta-primary" id="modalContinueBtn">המשך</button>
                </div>
            </div>
        </div>
    </div>

    <div class="draggable-container" id="draggableContainer">
        <div class="draggable-content">
            <div class="content-text" id="contentText">
                טוען נתונים...
            </div>
            <div class="cta-buttons">
                <button class="cta-tertiary" id="ctaBack">חזור</button>
                <button class="cta-primary" id="ctaContinue">המשך (<span id="selectedDateInTitle">30.1.2024</span>)</button>
            </div>
        </div>
    </div>

    <div class="header-container">
        <div class="mobile-title-cta-row">
            <div class="names-title">
                הנופלים, ואלה שיכלו עוד להיות חיים<br>
                אם המלחמה הייתה מסתיימת
            </div>
            <div class="header-cta-container">
                <button class="cta-primary icon-only" id="ctaSkipBack">
                    <i data-lucide="skip-back"></i>
                </button>
                <span class="header-date" id="selectedDateInTitle">30.1.2024</span>
            </div>
        </div>
        <!-- Mobile status components - positioned inside header for mobile layout -->
        <div class="status-components-container">
            <div class="status-components">
                <div class="status-component alive-status">
                    <div class="status-text" id="aliveCount">0 היו יכולים להיות חיים</div>
                </div>
                <div class="status-component fallen-status">
                    <div class="status-text" id="fallenCount">0 חללים</div>
                </div>
            </div>
        </div>
        <div class="timeline-description" id="timelineDescription">
            <!-- Timeline description will be populated here -->
        </div>
    </div>
    
    <!-- Desktop status components -->
    <div class="desktop-status-components-container">
        <div class="status-components">
            <div class="status-component alive-status">
                <div class="status-text" id="desktopAliveCount">0 היו יכולים להיות חיים</div>
            </div>
            <div class="status-component fallen-status">
                <div class="status-text" id="desktopFallenCount">0 חללים</div>
            </div>
        </div>
    </div>
    
    <div class="header-info">
        <div id="selectedDate">27/10/2023</div>
        <div id="lastEvent">תחילת המלחמה</div>
    </div>
    
    
    <div class="timeline-container">
        <div class="timeline-track">
            <div class="timeline-living-chart" id="timelineLivingChart">
                <svg viewBox="0 0 100 40" preserveAspectRatio="none">
                    <path class="living-path-future" id="livingPathFuture" d=""></path>
                    <path class="living-path-past" id="livingPathPast" d=""></path>
                </svg>
            </div>
            <div class="timeline-area-chart" id="timelineAreaChart">
                <svg viewBox="0 0 100 40" preserveAspectRatio="none">
                    <path class="area-path-future" id="areaPathFuture" d=""></path>
                    <path class="area-path-past" id="areaPathPast" d=""></path>
                </svg>
            </div>
            <div class="timeline-progress" id="timelineProgress"></div>
            <input type="range" id="timelineSlider" class="timeline-slider" min="0" max="1" value="0">
            <div class="timeline-axis" id="timelineAxis"></div>
            <div class="timeline-legend">
                <div class="legend-item">
                    <span class="legend-text">הזדמנויות לסיום המלחמה</span>
                    <div class="legend-color blue"></div>
                </div>
                <div class="legend-item">
                    <span class="legend-text">לחץ פוליטי להמשיך את המלחמה</span>
                    <div class="legend-color orange"></div>
                </div>
                <div class="legend-item">
                    <span class="legend-text">אירועים משמעותיים במלחמה</span>
                    <div class="legend-color black"></div>
                </div>
            </div>
            <div class="timeline-handle-tooltip" id="timelineTooltip">
                <div id="tooltipDate">27/07/25</div>
                <div id="tooltipAlive" style="font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">היו יכולים להיות חיים היום: 0</div>
            </div>
        </div>
        <!-- Removed timeline labels -->
    </div>

    <div class="names-container" id="namesContainer">
        <div class="loading">Loading memorial data...</div>
    </div>

    <!-- Custom soldier tooltip -->
    <div class="soldier-tooltip" id="soldierTooltip">
        <div class="soldier-photo" id="soldierPhoto" style="display: none;">
            <div class="image-placeholder" style="width: 120px; height: 160px; background: #f0f0f0; border-radius: 3px; position: relative; overflow: hidden;">
                <img id="soldierImage" style="width: 100%; height: 100%; object-fit: cover; object-position: center top; border-radius: 3px; opacity: 0; transition: opacity 1.5s ease; position: absolute; top: 0; left: 0; filter: saturate(0.6) brightness(1.35) opacity(0.85);">
            </div>
        </div>
        <div class="soldier-text">
            <strong id="soldierName"></strong>
            <div class="soldier-details" id="soldierDetails"></div>
        </div>
    </div>

    <script>
        class NarrativeEngine {
            constructor(timeline) {
                this.timeline = timeline;
                this.narrativePoints = [];
                this.currentPointId = 'loaded';
                this.isNavigating = false; // Flag to prevent conflicting navigation
                this.currentAnimationId = null; // Track current animation
            }

            async loadNarrative() {
                try {
                    const response = await safeFetch('data/narrative.csv');
                    const csvText = await response.text();
                    // console.log('CSV loaded:', csvText.substring(0, 200) + '...');
                    this.parseNarrativeCsv(csvText);
                    // console.log(`Loaded ${this.narrativePoints.length} narrative points:`, this.narrativePoints);
                } catch (error) {
                    console.error('Error loading narrative:', error);
                    // Fallback content if CSV fails to load
                    document.getElementById('contentText').innerHTML = 'שגיאה בטעינת הנתונים';
                }
            }

            parseNarrativeCsv(csvText) {
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.parseCsvLine(line);
                    if (values.length === headers.length) {
                        const point = {};
                        headers.forEach((header, index) => {
                            point[header.trim()] = values[index].trim();
                        });
                        this.narrativePoints.push(point);
                    }
                }
            }

            parseCsvLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current);
                return result;
            }

            // Advanced placeholder parsing
            parseTemplate(content) {
                return content.replace(/\{\{([^}]+)\}\}/g, (match, placeholder) => {
                    return this.resolvePlaceholder(placeholder.trim());
                });
            }

            resolvePlaceholder(placeholder) {
                const [type, ...params] = placeholder.split(':');
                
                switch(type) {
                    case 'total_count':
                        return `<strong class="fallen-soldiers-number">${this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate).length}</strong>`;
                    
                    case 'alive_count':
                        return `<strong>${this.getAliveCount()}</strong>`;
                    
                    case 'fallen_count':
                        return `<strong class="fallen-soldiers-number">${this.getFallenCount()}</strong>`;
                    
                    case 'fallen_since_date':
                        const days = parseInt(params[0]) || 0;
                        return `<strong class="fallen-soldiers-number">${this.getFallenSince(days)}</strong>`;
                    
                    case 'fallen_on_date':
                        const targetDays = parseInt(params[0]) || 0;
                        return `<strong class="fallen-soldiers-number">${this.getFallenOnDate(targetDays)}</strong>`;
                    
                    case 'date_hebrew':
                        const daysBack = parseInt(params[0]) || 0;
                        return this.formatHebrewDate(daysBack);
                    
                    case 'days_since_start':
                        return `<strong>${Math.round((this.timeline.currentEndDate - this.timeline.startDate) / (1000 * 60 * 60 * 24))}</strong>`;
                    
                    case 'percentage_fallen':
                        const total = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate).length;
                        const fallen = this.getFallenCount();
                        return `<strong>${Math.round((fallen / total) * 100)}</strong>`;
                    
                    case 'soldier_name':
                        return this.getSoldierName(params[0]);
                    
                    case 'months_since_start':
                        return `<strong>${this.getMonthsSinceStart()}</strong>`;
                    
                    case 'average_monthly_casualties':
                        return `<strong class="fallen-soldiers-number">${this.getAverageMonthlycasualties()}</strong>`;
                    
                    case 'days_since_last_deaths':
                        return `<strong>${this.getDaysSinceLastDeaths()}</strong>`;
                    
                    case 'last_deaths_text':
                        return this.getLastDeathsText();
                    
                    case 'war_continuation_message':
                        return this.getWarContinuationMessage();
                    
                    case 'political_event_date':
                        return this.getPoliticalEventDate();
                    
                    case 'coalition_threat_date':
                        return this.getCoalitionThreatDate();
                    
                    case 'coalition_threat_person':
                        return this.getCoalitionThreatPerson();
                    
                    case 'coalition_threats_count':
                        return `<strong>${this.getCoalitionThreatsCount()}</strong>`;
                    
                    case 'days_since_decision':
                        return `<strong>${this.getDaysSinceDecision()}</strong>`;
                    
                    case 'could_be_alive_count':
                        return `<strong>${this.getCouldBeAliveCount()}</strong>`;
                    
                    case 'random_names':
                        return this.getRandomNames();
                    
                    case 'fallen_since_january':
                        return `<strong class="fallen-soldiers-number">${this.getFallenSinceJanuary()}</strong>`;
                    
                    case 'fallen_last_month':
                        return `<strong class="fallen-soldiers-number">${this.getFallenLastMonth()}</strong>`;
                    
                    case 'last_month_names':
                        return this.getLastMonthNames();
                    
                    case 'last_month_remaining_count':
                        return `<strong class="fallen-soldiers-number">${this.getLastMonthRemainingCount()}</strong>`;
                    
                    case 'soldiers_died_last_31_days':
                        return `<strong class="fallen-soldiers-number">${this.getFallenSinceTodayExcludingRecent(31)}</strong>`;
                    
                    case 'soldiers_died_month_before_last_death':
                        return `<strong class="alive-soldiers-number">${this.getFallenInMonthBeforeLastDeath()}</strong>`;
                    
                    case 'days_from_today_to_month_before_last_death':
                        return this.getDaysFromTodayToMonthBeforeLastDeath();
                    
                    case 'deaths_start_to_first_ceasefire':
                        return `<strong class="fallen-soldiers-number">${this.getDeathsFromStartToFirstCeasefire()}</strong>`;
                    
                    case 'weekly_average_to_first_ceasefire':
                        return `<strong class="fallen-soldiers-number">${this.getWeeklyAverageToFirstCeasefire()}</strong>`;
                    
                    case 'soldiers_could_be_alive_first_ceasefire':
                        return `<strong>${this.getSoldiersCouldBeAliveIfFirstCeasefireEnded()}</strong>`;
                    
                    case 'deaths_ceasefire_to_withdrawal':
                        return `<strong class="fallen-soldiers-number">${this.getDeathsFromFirstCeasefireToWithdrawal()}</strong>`;
                    
                    case 'soldiers_alive_at_withdrawal':
                        return `<strong>${this.getSoldiersAliveAtWithdrawal()}</strong>`;
                    
                    case 'deaths_withdrawal_to_khan_yunis':
                        return `<strong class="fallen-soldiers-number">${this.getDeathsFromWithdrawalToKhanYunis()}</strong>`;
                    
                    case 'soldiers_alive_after_khan_yunis':
                        return `<strong>${this.getSoldiersAliveAfterKhanYunis()}</strong>`;
                    
                    case 'timeline_event_days_from_today':
                        const eventId = params[0];
                        return this.getTimelineEventDaysFromToday(eventId);
                    
                    case 'timeline_event_title':
                        const titleEventId = params[0];
                        return this.getTimelineEventTitle(titleEventId);
                    
                    default:
                        return `{{${placeholder}}}`;
                }
            }

            getAliveCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > this.timeline.currentEndDate
                ).length;
            }

            getFallenCount() {
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate
                ).length;
            }

            getFallenSince(daysBack) {
                const sinceDate = new Date(this.timeline.currentEndDate);
                sinceDate.setDate(sinceDate.getDate() - daysBack);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate &&
                    s.death_date >= sinceDate
                ).length;
            }

            getFallenSinceToday(daysBack) {
                const sinceDate = new Date(this.timeline.todayDate);
                sinceDate.setDate(sinceDate.getDate() - daysBack);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= sinceDate
                ).length;
            }

            getFallenSinceTodayExcludingRecent(daysBack) {
                const sinceDate = new Date(this.timeline.todayDate);
                sinceDate.setDate(sinceDate.getDate() - daysBack);
                
                // Get all soldiers who died in the last 31 days
                const soldiersInPeriod = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= sinceDate
                );
                
                // Find the most recent death date
                if (soldiersInPeriod.length === 0) return 0;
                
                const latestDeathDate = soldiersInPeriod
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Count soldiers who died on the most recent date
                const soldiersOnLatestDate = soldiersInPeriod.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000 // Same day
                );
                
                // Return total minus recent deaths
                return soldiersInPeriod.length - soldiersOnLatestDate.length;
            }

            getFallenInMonthBeforeLastDeath() {
                // Find all soldiers who died since war start
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                // Find the most recent death date
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Calculate date range: 30 days before the most recent death
                const monthBeforeLatest = new Date(latestDeathDate);
                monthBeforeLatest.setDate(monthBeforeLatest.getDate() - 30);
                
                // Count soldiers who died in the 30 days before the most recent death
                return relevantSoldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date >= monthBeforeLatest &&
                    s.death_date < latestDeathDate
                ).length;
            }

            getFallenOnDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const startOfDay = new Date(targetDate);
                startOfDay.setHours(0, 0, 0, 0);
                const endOfDay = new Date(targetDate);
                endOfDay.setHours(23, 59, 59, 999);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= startOfDay && 
                    s.death_date <= endOfDay
                ).length;
            }

            formatHebrewDate(daysFromToday) {
                const targetDate = new Date(this.timeline.todayDate);
                targetDate.setDate(targetDate.getDate() - daysFromToday);
                
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${targetDate.getDate()} ${hebrewMonths[targetDate.getMonth()]} ${targetDate.getFullYear()}`;
            }

            getSoldierName(type) {
                const relevantSoldiers = this.timeline.soldiers.filter(s => s.death_date >= this.timeline.startDate);
                
                switch(type) {
                    case 'first':
                        const first = relevantSoldiers.sort((a, b) => a.death_date - b.death_date)[0];
                        return first ? `<strong>${first.name}</strong>` : 'לא ידוע';
                    
                    case 'latest':
                        const latest = relevantSoldiers
                            .filter(s => s.death_date <= this.timeline.currentEndDate)
                            .sort((a, b) => b.death_date - a.death_date)[0];
                        return latest ? `<strong>${latest.name}</strong>` : 'לא ידוע';
                    
                    default:
                        return 'לא ידוע';
                }
            }

            getMonthsSinceStart() {
                const startDate = this.timeline.startDate;
                const currentDate = this.timeline.todayDate; // Use today's date instead of timeline date
                
                const yearDiff = currentDate.getFullYear() - startDate.getFullYear();
                const monthDiff = currentDate.getMonth() - startDate.getMonth();
                const dayDiff = currentDate.getDate() - startDate.getDate();
                
                let totalMonths = yearDiff * 12 + monthDiff;
                
                // Add partial month if we've passed the start day
                if (dayDiff >= 0) {
                    totalMonths += Math.round(dayDiff / 30 * 10) / 10; // Round to 1 decimal
                }
                
                return Math.round(totalMonths);
            }

            getAverageMonthlycasualties() {
                const monthsSinceStart = this.getMonthsSinceStart();
                const totalFallen = this.getFallenCount();
                
                if (monthsSinceStart === 0) return 0;
                
                return Math.round(totalFallen / monthsSinceStart);
            }

            getDaysSinceLastDeaths() {
                // Use today's date, not currentEndDate, for this calculation
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                // Find the most recent death date from all soldiers
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Calculate days from today back to most recent death
                return Math.floor((this.timeline.todayDate - latestDeathDate) / (1000 * 60 * 60 * 24));
            }

            getDaysFromTodayToMonthBeforeLastDeath() {
                // Find all soldiers who died since war start
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return 31; // fallback
                
                // Find the most recent death date
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                // Calculate date 30 days before the most recent death
                const monthBeforeLatest = new Date(latestDeathDate);
                monthBeforeLatest.setDate(monthBeforeLatest.getDate() - 30);
                
                // Calculate days from today back to that date
                return Math.floor((this.timeline.todayDate - monthBeforeLatest) / (1000 * 60 * 60 * 24));
            }

            getDeathsFromStartToFirstCeasefire() {
                // First ceasefire was on 2023-11-22 (event ID 1)
                const firstCeasefireDate = new Date('2023-11-22');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= firstCeasefireDate
                ).length;
            }

            getWeeklyAverageToFirstCeasefire() {
                // Calculate days from operation start (2023-10-27) to first ceasefire (2023-11-22)
                const operationStart = new Date('2023-10-27');
                const firstCeasefire = new Date('2023-11-22');
                const daysInPeriod = Math.floor((firstCeasefire - operationStart) / (1000 * 60 * 60 * 24));
                const weeksInPeriod = daysInPeriod / 7;
                
                const deaths = this.getDeathsFromStartToFirstCeasefire();
                return Math.round(deaths / weeksInPeriod);
            }

            getSoldiersCouldBeAliveIfFirstCeasefireEnded() {
                // First ceasefire was on 2023-11-22
                const firstCeasefireDate = new Date('2023-11-22');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > firstCeasefireDate &&
                    s.death_date <= this.timeline.todayDate
                ).length;
            }

            getDeathsFromFirstCeasefireToWithdrawal() {
                // From end of first ceasefire (2023-11-22) to withdrawal (2024-01-01)
                const firstCeasefireDate = new Date('2023-11-22');
                const withdrawalDate = new Date('2024-01-01');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > firstCeasefireDate &&
                    s.death_date <= withdrawalDate
                ).length;
            }

            getSoldiersAliveAtWithdrawal() {
                // Soldiers still alive at withdrawal date (2024-01-01)
                const withdrawalDate = new Date('2024-01-01');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > withdrawalDate
                ).length;
            }

            getDeathsFromWithdrawalToKhanYunis() {
                // From withdrawal (2024-01-01) to Khan Yunis withdrawal (2024-04-07)
                const withdrawalDate = new Date('2024-01-01');
                const khanYunisDate = new Date('2024-04-07');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > withdrawalDate &&
                    s.death_date <= khanYunisDate
                ).length;
            }

            getSoldiersAliveAfterKhanYunis() {
                // Soldiers still alive after Khan Yunis withdrawal date (2024-04-07)
                const khanYunisDate = new Date('2024-04-07');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date > khanYunisDate
                ).length;
            }

            getLastDeathsText() {
                // Use all soldiers to find the most recent deaths (up to today)
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate
                );
                
                if (relevantSoldiers.length === 0) return '';
                
                // Find soldiers who died on the most recent death date
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                const soldiersOnLatestDate = relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000 // Same day
                );
                
                // Format Hebrew date
                const date = new Date(latestDeathDate);
                const hebrewDays = ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'];
                const hebrewMonths = ['בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני', 'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'];
                const dayOfWeek = hebrewDays[date.getDay()];
                const day = date.getDate();
                const month = hebrewMonths[date.getMonth()];
                const year = date.getFullYear();
                const hebrewDate = `יום ${dayOfWeek}, ${day} ${month}, ${year}`;
                
                // Format names
                let names = '';
                if (soldiersOnLatestDate.length === 1) {
                    names = `<strong>${soldiersOnLatestDate[0].name}</strong>`;
                } else if (soldiersOnLatestDate.length === 2) {
                    names = `<strong>${soldiersOnLatestDate[0].name}</strong> ו-<strong>${soldiersOnLatestDate[1].name}</strong>`;
                } else if (soldiersOnLatestDate.length > 2) {
                    const nameList = soldiersOnLatestDate.slice(0, -1).map(s => `<strong>${s.name}</strong>`).join(', ');
                    const lastName = `<strong>${soldiersOnLatestDate[soldiersOnLatestDate.length - 1].name}</strong>`;
                    names = `${nameList} ו-${lastName}`;
                }
                
                return `<p>ביום ${hebrewDate}, נהרגו ${names}.</p><p>באותו בוקר הם היו עוד חיים.</p>`;
            }


            getWarContinuationMessage() {
                const lastDeathsCount = this.getLastDeathsOnMostRecentDate();
                
                if (lastDeathsCount === 1) {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הוא היה חוזר הביתה למשפחה שלו';
                } else {
                    return 'אם המלחמה הייתה מסתיימת יום קודם, הם היו חוזרים הביתה למשפחות שלהם';
                }
            }

            getLastDeathsOnMostRecentDate() {
                const relevantSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= this.timeline.startDate && 
                    s.death_date <= this.timeline.currentEndDate
                );
                
                if (relevantSoldiers.length === 0) return 0;
                
                const latestDeathDate = relevantSoldiers
                    .map(s => s.death_date)
                    .sort((a, b) => b - a)[0];
                
                return relevantSoldiers.filter(s => 
                    Math.abs(s.death_date - latestDeathDate) < 24 * 60 * 60 * 1000
                ).length;
            }

            getPoliticalEventDate() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 'תאריך לא ידוע';
                
                const eventDate = new Date(netanyahuEvent.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatDate() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'תאריך לא ידוע';
                
                const firstThreat = threatEvents[0];
                const eventDate = new Date(firstThreat.date);
                const hebrewMonths = [
                    'בינואר', 'בפברואר', 'במרץ', 'באפריל', 'במאי', 'ביוני',
                    'ביולי', 'באוגוסט', 'בספטמבר', 'באוקטובר', 'בנובמבר', 'בדצמבר'
                ];
                
                return `${eventDate.getDate()} ${hebrewMonths[eventDate.getMonth()]} ${eventDate.getFullYear()}`;
            }

            getCoalitionThreatPerson() {
                const threatEvents = this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (threatEvents.length === 0) return 'לא ידוע';
                
                const firstThreat = threatEvents[0];
                if (firstThreat.id.includes('smotrich')) {
                    return 'סמוטריץ\'';
                } else if (firstThreat.id.includes('ben_gvir')) {
                    return 'בן גביר';
                }
                
                return 'לא ידוע';
            }

            getCoalitionThreatsCount() {
                return this.timeline.timelineEvents.filter(e => 
                    e.id.includes('coalition_threat')
                ).length;
            }

            getDaysSinceDecision() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const eventDate = new Date(netanyahuEvent.date);
                return Math.round((this.timeline.todayDate - eventDate) / (1000 * 60 * 60 * 24));
            }

            getCouldBeAliveCount() {
                const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                    e.id === 'netanyahu_considers_ceasefire'
                );
                
                if (!netanyahuEvent) return 0;
                
                const decisionDate = new Date(netanyahuEvent.date);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date > decisionDate && 
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getRandomNames() {
                const couldBeAliveSoldiers = this.timeline.soldiers.filter(s => {
                    const netanyahuEvent = this.timeline.timelineEvents.find(e => 
                        e.id === 'netanyahu_considers_ceasefire'
                    );
                    
                    if (!netanyahuEvent) return false;
                    
                    const decisionDate = new Date(netanyahuEvent.date);
                    return s.death_date > decisionDate && s.death_date >= this.timeline.startDate;
                });
                
                // Select 3 random names and make them bold
                const shuffled = couldBeAliveSoldiers.sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, 3);
                
                return selected.map(s => `- <strong>${s.name}</strong>`).join('<br>');
            }

            getFallenSinceJanuary() {
                const januaryDate = new Date('2024-01-07');
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= januaryDate && 
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getFallenLastMonth() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                return this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                ).length;
            }

            getLastMonthNames() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                );
                
                // Get first 3 names and make them bold
                const names = lastMonthSoldiers.slice(0, 3).map(s => `<strong>${s.name}</strong>`);
                return names.join(', ');
            }

            getLastMonthRemainingCount() {
                const oneMonthAgo = new Date(this.timeline.todayDate);
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                
                const lastMonthSoldiers = this.timeline.soldiers.filter(s => 
                    s.death_date >= oneMonthAgo && 
                    s.death_date <= this.timeline.todayDate &&
                    s.death_date >= this.timeline.startDate
                );
                
                // Return count of remaining soldiers beyond the first 3
                return Math.max(0, lastMonthSoldiers.length - 3);
            }

            getTimelineEventDaysFromToday(eventId) {
                const event = this.timeline.timelineEvents.find(e => e.id === eventId);
                if (!event) {
                    console.warn(`Timeline event with id ${eventId} not found`);
                    return 0;
                }
                
                // Calculate days from today using the actual event date
                const eventDate = new Date(event.date);
                const todayDate = this.timeline.todayDate;
                const daysFromToday = Math.floor((todayDate - eventDate) / (1000 * 60 * 60 * 24));
                
                // console.log(`Event ${eventId}: date=${event.date}, calculated days_from_today=${daysFromToday}`);
                return daysFromToday;
            }

            getTimelineEventTitle(eventId) {
                const event = this.timeline.timelineEvents.find(e => e.id === eventId);
                if (!event) {
                    console.warn(`Timeline event with id ${eventId} not found`);
                    return `Event ${eventId} not found`;
                }
                
                return event.title_hebrew || `Event ${eventId}`;
            }



            // Navigation methods
            getCurrentPoint() {
                return this.narrativePoints.find(p => p.id === this.currentPointId) || this.narrativePoints[0];
            }



            navigateToPoint(pointId) {
                const point = this.narrativePoints.find(p => p.id === pointId);
                if (!point) return;
                
                // Update narrative container opacity based on point
                const container = document.querySelector('.draggable-container');
                if (pointId !== 'current_date') {
                    container.classList.add('narrative-opaque');
                } else {
                    container.classList.remove('narrative-opaque');
                }
                
                // Cancel any ongoing animation immediately (allows override)
                if (this.currentAnimationId) {
                    clearTimeout(this.currentAnimationId);
                    this.currentAnimationId = null;
                    // console.log('Previous navigation cancelled, starting new one');
                }
                
                this.isNavigating = true;
                this.currentPointId = pointId;
                
                // Get current and target timeline points
                const currentTimelinePoint = parseInt(document.getElementById('timelineSlider').value);
                let targetTimelinePoint;
                
                // Handle different timeline_point types
                if (point.timeline_point === 'max') {
                    targetTimelinePoint = this.timeline.getTotalTimelineDays();
                } else if (point.timeline_point.includes('{{')) {
                    // Parse dynamic timeline_point with placeholders
                    const resolvedTimelinePoint = this.parseTemplate(point.timeline_point);
                    targetTimelinePoint = parseInt(resolvedTimelinePoint);
                } else {
                    targetTimelinePoint = parseInt(point.timeline_point);
                }
                
                // Special handling for recent_deaths: use actual days since last deaths
                if (pointId === 'recent_deaths') {
                    targetTimelinePoint = this.timeline.narrative.getDaysSinceLastDeaths() + 1;
                }
                

                
                // Update content immediately
                this.updateNarrativeContent();
                
                // Check if this is an opportunity point that should jump immediately
                const shouldJumpImmediately = pointId.startsWith('opportunity_');
                
                // Start gradual animation if there's a difference, unless it's an opportunity point
                if (currentTimelinePoint !== targetTimelinePoint) {
                    if (shouldJumpImmediately) {
                        // Immediate jump for opportunity points
                        const slider = document.getElementById('timelineSlider');
                        slider.value = targetTimelinePoint;
                        
                        // Update timeline immediately
                        const newEndDate = new Date(this.timeline.todayDate);
                        newEndDate.setDate(newEndDate.getDate() - targetTimelinePoint);
                        this.timeline.currentEndDate = newEndDate;
                        
                        // Update progress bar
                        const totalDays = this.timeline.getTotalTimelineDays();
                        const progress = ((totalDays - targetTimelinePoint) / totalDays) * 100;
                        document.getElementById('timelineProgress').style.width = progress + '%';
                        
                        // Update tooltip and visualization
                        this.timeline.updateTooltip(targetTimelinePoint, newEndDate);
                        this.timeline.updateVisualization();
                        this.isNavigating = false;
                    } else {
                        // Normal slow animation for other points
                        this.animateToTimelinePoint(currentTimelinePoint, targetTimelinePoint);
                    }
                } else {
                    // If already at target, just update visualization and unlock navigation
                    this.timeline.updateVisualization();
                    this.isNavigating = false;
                }
            }

            animateToTimelinePoint(startPoint, endPoint) {
                const slider = document.getElementById('timelineSlider');
                const progressBar = document.getElementById('timelineProgress');
                
                // Mark timeline as animating
                this.timeline.isTimelineAnimating = true;
                
                // Determine direction and speed
                const isMovingBack = endPoint > startPoint; // Moving back in time (higher days back)
                const isMovingForward = endPoint < startPoint; // Moving forward in time (lower days back)
                
                // Set different speeds: faster for forward, faster for backward
                const forwardSpeed = 5; // ms per day when moving forward in time (MUCH FASTER)
                let backwardSpeed = 10;  // ms per day when moving back in time (1.5x FASTER)
                
                // Special case: 2x faster animation for war_overview navigation
                if (this.currentPointId === 'war_overview') {
                    backwardSpeed = 5; // 2x faster for war_overview
                }
                
                const speed = isMovingForward ? forwardSpeed : backwardSpeed;
                const step = isMovingBack ? 1 : -1;
                
                let current = startPoint;
                
                const animate = () => {
                    // Check if animation was cancelled
                    if (!this.isNavigating) {
                        // console.log('Animation cancelled during execution');
                        return;
                    }
                    
                    // Update current timeline point
                    current += step;
                    
                    // Update slider
                    slider.value = current;
                    
                    // Update timeline progress
                    const totalDays = this.timeline.getTotalTimelineDays();
                    const progress = ((totalDays - current) / totalDays) * 100;
                    progressBar.style.width = progress + '%';
                    
                    // Update timeline date
                    const newEndDate = new Date(this.timeline.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - current);
                    this.timeline.currentEndDate = newEndDate;
                    
                    // Update tooltip during animation
                    this.timeline.updateTooltip(current, newEndDate);
                    
                    // Update visualization
                    this.timeline.updateVisualization();
                    
                    // Check if we've reached the target
                    const reachedTarget = isMovingBack ? (current >= endPoint) : (current <= endPoint);
                    
                    if (!reachedTarget) {
                        // Continue animation with tracked timeout
                        this.currentAnimationId = setTimeout(animate, speed);
                    } else {
                        // Animation complete - unlock navigation and stop animating
                        this.isNavigating = false;
                        this.currentAnimationId = null;
                        this.timeline.isTimelineAnimating = false;
                    }
                };
                
                // Start animation with tracked timeout
                this.currentAnimationId = setTimeout(animate, speed);
            }

            updateNarrativeContent() {
                const point = this.getCurrentPoint();
                if (!point) return;
                
                // Update body class for narrative-specific styling
                document.body.className = document.body.className.replace(/narrative-\S+/g, '').trim();
                document.body.classList.add(`narrative-${this.currentPointId}`);
                
                // Handle staggered triangle transformation for war_continuation
                if (this.currentPointId === 'war_continuation') {
                    this.animateTriangleTransformation();
                } else {
                    // Only reset triangles if we're going backwards to before war_continuation
                    const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                    const warContinuationIndex = this.narrativePoints.findIndex(p => p.id === 'war_continuation');
                    
                    if (currentIndex < warContinuationIndex) {
                        this.resetTriangleTransformation();
                    }
                }
                
                const contentText = document.getElementById('contentText');
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');
                
                // Parse and update content
                const parsedContent = this.parseTemplate(point.content_hebrew);
                contentText.innerHTML = parsedContent;
                
                // Update buttons
                ctaContinue.textContent = point.cta_continue_he || 'המשך';
                ctaBack.textContent = point.cta_back_he || 'חזור';
                
                // Show/hide buttons based on navigation - hide back button for first narrative point
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                ctaBack.style.display = (currentIndex > 0) ? 'inline-block' : 'none';
                ctaContinue.style.display = this.getNextPoint() ? 'inline-block' : 'none';
            }
            
            animateTriangleTransformation() {
                const couldHaveEndedMarkers = document.querySelectorAll('.could-have-ended-marker');
                couldHaveEndedMarkers.forEach((marker, index) => {
                    // Stagger the animations with 300ms delay between each
                    setTimeout(() => {
                        marker.classList.add('transform-to-triangle');
                    }, index * 300);
                });
            }
            
            resetTriangleTransformation() {
                const couldHaveEndedMarkers = document.querySelectorAll('.could-have-ended-marker');
                couldHaveEndedMarkers.forEach(marker => {
                    marker.classList.remove('transform-to-triangle');
                });
            }

            getNextPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex < this.narrativePoints.length - 1 ? this.narrativePoints[currentIndex + 1] : null;
            }

            getPrevPoint() {
                const currentIndex = this.narrativePoints.findIndex(p => p.id === this.currentPointId);
                return currentIndex > 0 ? this.narrativePoints[currentIndex - 1] : null;
            }

        }

        class TimelineMemorial {
            constructor() {
                // Mobile detection
                this.isMobile = window.innerWidth <= 768;
                if (this.isMobile) {
                    this.setupMobileLayout();
                }
                
                this.soldiers = [];
                this.timelineEvents = [];
                this.militaryEvents = [];
                this.startDate = new Date(2023, 9, 27, 12, 0, 0); // Oct 27, 2023 at noon
                this.todayDate = new Date(); // Dynamic current date
                this.todayDate.setHours(12, 0, 0, 0); // Normalize today to noon
                this.currentEndDate = new Date(); // Start at today so all soldiers are "fallen"
                
                this.navigationState = 'month_back'; // 'month_back' or 'today'
                this.narrative = new NarrativeEngine(this);
                this.dyingTimeouts = new Map(); // Track timeouts for performance
                this.soldierStates = new Map(); // Track actual soldier states independently of CSS
                this.isTimelineAnimating = false; // Track if timeline is actively animating
                this.lastTooltipUpdate = 0; // Track last manual tooltip update
                this.init();
            }

            setupMobileLayout() {
                // Mobile-specific elements are handled by CSS
                // Modal will appear normally on mobile
                
                // Show only specific timeline dates on mobile
                this.setupMobileTimelineDates();
                
                // Ensure timeline description gets populated on mobile
                setTimeout(() => {
                    const timelineDescriptionEl = document.getElementById('timelineDescription');
                    if (timelineDescriptionEl && !timelineDescriptionEl.innerHTML.trim()) {
                        // If description is empty, populate it with current timeline info
                        const currentSliderValue = parseInt(document.getElementById('timelineSlider').value) || 0;
                        const currentDate = new Date(this.todayDate);
                        currentDate.setDate(currentDate.getDate() - currentSliderValue);
                        const currentEvent = this.getEventAtDate(currentDate);
                        
                        if (currentEvent) {
                            this.updateTimelineDescription(currentEvent);
                        } else {
                            // Show default description if no event
                            timelineDescriptionEl.innerHTML = 'תחילת המלחמה';
                            timelineDescriptionEl.style.opacity = '1';
                        }
                    }
                }, 500); // Wait for data to load
            }

            setupMobileTimelineDates() {
                // Only run on mobile
                if (!this.isMobile) return;
                
                // Wait for timeline axis to be generated
                setTimeout(() => {
                    const ticks = document.querySelectorAll('.timeline-tick');
                    const labels = document.querySelectorAll('.timeline-date-label');
                    
                    // Target dates we want to show
                    const targetLabels = ['27 אוק׳ 2023', 'לפני שנה', 'היום'];
                    
                    // Find and mark the specific labels and their corresponding ticks
                    labels.forEach((label, index) => {
                        const labelText = label.textContent.trim();
                        
                        // Check if this label matches any of our target labels
                        const isTarget = targetLabels.some(target => {
                            if (target === 'לפני שנה') {
                                // More flexible matching for "year ago" variations
                                return labelText.includes('לפני שנה') || labelText.includes('שנה');
                            }
                            return labelText.includes(target) || target.includes(labelText);
                        });
                        
                        if (isTarget) {
                            label.classList.add('mobile-show');
                            // Find corresponding tick (usually same index or close)
                            if (ticks[index]) {
                                ticks[index].classList.add('mobile-show');
                            }
                        }
                    });
                    
                    // If we couldn't find exact matches, try to manually create the 3 key dates
                    const shownLabels = document.querySelectorAll('.timeline-date-label.mobile-show');
                    if (shownLabels.length < 3) {
                        this.createMobileKeyDates();
                    }
                }, 1000); // Wait longer for timeline to be fully generated
            }

            createMobileKeyDates() {
                const axisContainer = document.querySelector('.timeline-axis');
                if (!axisContainer) return;
                
                const totalDays = this.getTotalTimelineDays();
                const startDate = new Date(2023, 9, 27); // Oct 27, 2023
                const oneYearAgo = new Date();
                oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                const today = new Date();
                
                // Calculate positions
                const oneYearAgoDays = Math.floor((today - oneYearAgo) / (1000 * 60 * 60 * 24));
                const oneYearAgoPosition = Math.max(0, Math.min(100, (oneYearAgoDays / totalDays) * 100));
                
                const keyDates = [
                    { position: 100, label: '27 אוק׳ 2023' },
                    { position: oneYearAgoPosition, label: 'לפני שנה' },
                    { position: 0, label: 'היום' }
                ];
                
                keyDates.forEach(date => {
                    // Create tick
                    const tick = document.createElement('div');
                    tick.className = 'timeline-tick major mobile-show';
                    tick.style.left = date.position + '%';
                    axisContainer.appendChild(tick);
                    
                    // Create label
                    const label = document.createElement('div');
                    label.className = 'timeline-date-label mobile-show';
                    label.style.left = date.position + '%';
                    label.textContent = date.label;
                    axisContainer.appendChild(label);
                });
            }


            scrollToMostRecentFallen(fallenElement) {
                // Only scroll on mobile devices
                if (!this.isMobile) return;
                
                const container = document.getElementById('namesContainer');
                if (!container || !fallenElement) return;
                
                // Use smooth scrolling to bring the fallen soldier into view
                // Position it roughly in the center of the viewport
                const elementTop = fallenElement.offsetTop;
                const containerHeight = container.clientHeight;
                const scrollTop = elementTop - (containerHeight / 2);
                
                // Smooth scroll to position
                container.scrollTo({
                    top: Math.max(0, scrollTop),
                    behavior: 'smooth'
                });
            }

            scrollToMostRecentAlive(aliveElement) {
                // Only scroll on mobile devices
                if (!this.isMobile) return;
                
                const container = document.getElementById('namesContainer');
                if (!container || !aliveElement) return;
                
                // For alive soldiers, find the boundary between alive and fallen
                // and scroll to show the transition area
                const allSoldiers = Array.from(container.querySelectorAll('.soldier-name'));
                
                // Find the last alive soldier (soldiers are sorted by death date)
                let lastAliveIndex = -1;
                for (let i = allSoldiers.length - 1; i >= 0; i--) {
                    if (allSoldiers[i].classList.contains('alive')) {
                        lastAliveIndex = i;
                        break;
                    }
                }
                
                if (lastAliveIndex >= 0) {
                    const lastAliveElement = allSoldiers[lastAliveIndex];
                    const elementTop = lastAliveElement.offsetTop;
                    const containerHeight = container.clientHeight;
                    
                    // Position the last alive soldier in the bottom third of viewport
                    // This shows the alive/fallen transition area
                    const scrollTop = elementTop - (containerHeight * 0.7);
                    
                    container.scrollTo({
                        top: Math.max(0, scrollTop),
                        behavior: 'smooth'
                    });
                }
            }

            scrollToBeginning() {
                // Only scroll on mobile devices
                if (!this.isMobile) return;
                
                const container = document.getElementById('namesContainer');
                if (!container) return;
                
                // Scroll to the very top to show the beginning (alive soldiers)
                container.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }

            getTotalTimelineDays() {
                // Calculate days from start date (Oct 27, 2023) to today using normalized dates
                const todayNormalized = new Date(this.todayDate);
                todayNormalized.setHours(12, 0, 0, 0);
                
                const startNormalized = new Date(this.startDate);
                startNormalized.setHours(12, 0, 0, 0);
                
                const msPerDay = 1000 * 60 * 60 * 24;
                return Math.round((todayNormalized - startNormalized) / msPerDay);
            }


            async init() {
                await this.loadData();
                await this.loadTimelineEvents(); // Load timeline events
                await this.loadMilitaryEvents(); // Load military events
                await this.narrative.loadNarrative(); // Load narrative data
                this.setupEventListeners();
                this.generateTimelineAxis();
                this.renderAllNames();
                
                // Set timeline slider max value dynamically
                const totalDays = this.getTotalTimelineDays();
                document.getElementById('timelineSlider').max = totalDays;
                
                // Initialize with current date narrative point (today)
                this.narrative.navigateToPoint('current_date');
                
                // Initialize timeline progress bar (at current date - today)
                const initialDaysBack = 0;
                const initialProgress = ((totalDays - initialDaysBack) / totalDays) * 100;
                document.getElementById('timelineProgress').style.width = initialProgress + '%';
                
                // Recalculate font size after timeline changes with buffer
                setTimeout(() => {
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                    // console.log('Forcing font recalculation for', relevantSoldiers.length, 'soldiers');
                    
                    // Force container dimensions update
                    const container = document.getElementById('namesContainer');
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    // console.log('New container dimensions:', availableWidth, 'x', availableHeight);
                    
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 200);
            }

            async loadData() {
                try {
                    const response = await safeFetch('data/idf-url-increment.csv');
                    const csvText = await response.text();
                    this.parseCsvData(csvText);
                    // console.log(`Loaded ${this.soldiers.length} soldiers`);
                    
                    if (this.soldiers.length > 0) {
                        const dates = this.soldiers.map(s => s.death_date).sort((a,b) => a - b);
                        // console.log('Date range:', dates[0].toLocaleDateString(), 'to', dates[dates.length-1].toLocaleDateString());
                        
                        const afterOct26 = this.soldiers.filter(s => s.death_date >= this.startDate);
                        // console.log(`${afterOct26.length} soldiers died after Oct 27, 2023`);
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    document.getElementById('namesContainer').innerHTML = '<div class="loading">Error loading memorial data</div>';
                }
            }

            async loadTimelineEvents() {
                try {
                    // console.log('Attempting to load events-new2.csv...');
                    const response = await safeFetch('data/events-new2.csv?v=' + Date.now());
                    // console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    // console.log('CSV text loaded:', csvText.substring(0, 200) + '...');
                    this.parseTimelineEvents(csvText);
                    // console.log(`Loaded ${this.timelineEvents.length} timeline events`);
                } catch (error) {
                    console.error('Error loading timeline events:', error);
                    // Create test events if CSV fails to load
                    // console.log('Creating test timeline events...');
                    this.timelineEvents = [
                        {
                            id: 'test_event',
                            date: '2025-07-29',
                            title_hebrew: 'אירוע מבחן',
                            description_hebrew: 'זהו אירוע מבחן',
                            eventDate: new Date('2025-07-29')
                        }
                    ];
                    // console.log('Test events created:', this.timelineEvents.length);
                }
            }
            
            async loadMilitaryEvents() {
                try {
                    // console.log('Attempting to load military_events.csv...');
                    const response = await safeFetch('data/military_events.csv');
                    // console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    // console.log('CSV text loaded:', csvText.substring(0, 200) + '...');
                    this.parseMilitaryEvents(csvText);
                    // console.log(`Loaded ${this.militaryEvents.length} military events`);
                } catch (error) {
                    console.error('Error loading military events:', error);
                    this.militaryEvents = [];
                }
            }

            parseCsvData(csvText) {
                const lines = csvText.split('\n');
                let currentRecord = '';
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.match(/^"\d+-\d+"/)) {
                        if (currentRecord) {
                            const soldier = this.parseCsvLine(currentRecord);
                            if (soldier && soldier.death_date) {
                                this.soldiers.push(soldier);
                            }
                        }
                        currentRecord = line;
                    } else {
                        currentRecord += ' ' + line;
                    }
                }
                
                if (currentRecord) {
                    const soldier = this.parseCsvLine(currentRecord);
                    if (soldier && soldier.death_date) {
                        this.soldiers.push(soldier);
                    }
                }
            }

            parseCsvLine(line) {
                const deathDateField = line;
                
                const hebrewMonths = {
                    'באוקטובר': 9,
                    'בנובמבר': 10,
                    'בדצמבר': 11,
                    'בינואר': 0,
                    'בפברואר': 1,
                    'במרץ': 2,
                    'באפריל': 3,
                    'במאי': 4,
                    'ביוני': 5,
                    'ביולי': 6,
                    'באוגוסט': 7,
                    'בספטמבר': 8
                };

                let deathDate = null;
                let matchedDateStr = '';
                
                for (const [hebrewMonth, monthIndex] of Object.entries(hebrewMonths)) {
                    const pattern = new RegExp(`(\\d{1,2}) ${hebrewMonth} (\\d{4})`);
                    const match = deathDateField.match(pattern);
                    if (match) {
                        const day = parseInt(match[1]);
                        const year = parseInt(match[2]);
                        deathDate = new Date(year, monthIndex, day);
                        matchedDateStr = match[0];
                        break;
                    }
                }

                if (!deathDate) return null;

                // Simple approach: extract from the whole line using simpler patterns
                let name = 'Unknown';
                let rank = 'Unknown'; 
                let unit = 'Unknown';
                
                // IMPROVED: Better name extraction - include more Hebrew name characters
                const namePattern = /\s+([א-ת\s'\-\(\)׳״""]+?)\s+ז""ל/;
                const nameMatch = line.match(namePattern);
                if (nameMatch) {
                    const fullName = nameMatch[1].trim();
                    // Remove rank prefix if it exists - expanded list
                    const cleanName = fullName.replace(/^(רס""[א-ת]+|סמל|סרן|רב""ט|סמ""ר|רס""ל|רס""ם|אל""ם|רס""ן|תא""ל|אל""ף)\s*\([^)]*\)?\s*/, '').replace(/\s*\(במיל'\)\s*/g, '');
                    name = cleanName.trim();
                }
                
                // IMPROVED: Extract rank and unit from proper CSV fields instead of regex
                const fields = line.split('","');
                if (fields.length >= 4) {
                    // Field 3 contains rank
                    const rankField = fields[3];
                    if (rankField && rankField.trim()) {
                        rank = rankField.trim();
                    }
                }
                
                if (fields.length >= 5) {
                    // Field 4 contains unit
                    const unitField = fields[4];
                    if (unitField && unitField.trim()) {
                        unit = unitField.trim();
                    }
                }

                // Extract image URL from field 8 (0-based index, so field 8)
                let imageUrl = null;
                if (fields.length >= 9) {
                    const imageField = fields[8];
                    if (imageField && imageField.trim()) {
                        // Clean up the image URL (remove quotes and extra characters)
                        imageUrl = imageField.replace(/"/g, '').trim();
                        // If it's a relative URL, make it absolute
                        if (imageUrl.startsWith('/media/')) {
                            imageUrl = 'https://www.idf.il' + imageUrl;
                        }
                    }
                }

                return {
                    name: name,
                    rank: rank,
                    unit: unit,
                    death_date: deathDate,
                    death_date_string: matchedDateStr,
                    image_url: imageUrl
                };
            }

            parseTimelineEvents(csvText) {
                const lines = csvText.split('\n');
                const headers = this.narrative.parseCsvLine(lines[0]);
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.narrative.parseCsvLine(line);
                    const event = {};
                    
                    headers.forEach((header, index) => {
                        event[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    
                    
                    // Fix URLs that ended up in description field
                    if (event.description_hebrew && event.description_hebrew.includes('http')) {
                        const parts = event.description_hebrew.split('http');
                        if (parts.length > 1) {
                            event.description_hebrew = parts[0].trim();
                            event.source = 'http' + parts[1].trim();
                        }
                    }
                    
                    // Parse date - handle YYYY-MM-DD format correctly
                    if (event.date) {
                        // Remove quotes and parse YYYY-MM-DD format directly
                        const cleanDate = event.date.replace(/"/g, '');
                        const [year, month, day] = cleanDate.split('-').map(n => parseInt(n));
                        event.eventDate = new Date(year, month - 1, day, 12, 0, 0); // Parse at noon
                        // console.log('Timeline event parsed:', event.title_hebrew, 'Original date:', event.date, 'Parsed date:', event.eventDate);
                    }
                    
                    // Store days_from_start for accurate slider positioning
                    if (event.days_from_start) {
                        event.daysFromStart = parseInt(event.days_from_start);
                    }
                    
                    // Filter out hidden events
                    if (event.show && event.show.toLowerCase() === 'hide') {
                        continue;
                    }
                    
                    
                    // Load all events - filtering will be done during rendering
                    this.timelineEvents.push(event);
                }
            }
            
            parseMilitaryEvents(csvText) {
                const lines = csvText.split('\n');
                const headers = this.narrative.parseCsvLine(lines[0]);
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = this.narrative.parseCsvLine(line);
                    const event = {};
                    
                    headers.forEach((header, index) => {
                        event[header.trim()] = values[index] ? values[index].trim() : '';
                    });
                    
                    // Parse date
                    if (event.Date) {
                        event.eventDate = new Date(event.Date);
                    }
                    
                    // Parse penetration depth - use the numeric value
                    if (event.Penetration_km) {
                        event.penetrationKm = parseFloat(event.Penetration_km) || 0;
                    } else {
                        event.penetrationKm = 0;
                    }
                    
                    // Map qualitative levels to numeric intensity for better visualization
                    const qualitativeMap = {
                        'Low': 1,
                        'Medium': 2, 
                        'High': 3
                    };
                    event.intensityLevel = qualitativeMap[event.Penetration_qualitative] || 1;
                    
                    // Combine penetration depth and intensity for final combat intensity score
                    event.combatIntensity = event.penetrationKm + (event.intensityLevel * 2);
                    
                    // console.log('Military event parsed:', event.Date, event.Event_Type, 'Intensity:', event.combatIntensity);
                    
                    this.militaryEvents.push(event);
                }
                // console.log('Total military events loaded:', this.militaryEvents.length);
            }

            generateTimelineAxis() {
                const axisContainer = document.getElementById('timelineAxis');
                axisContainer.innerHTML = '';
                
                const startDate = this.startDate; // Oct 27, 2023
                const endDate = this.todayDate;
                const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                // Define countdown dates from today
                const countdownDates = [
                    {
                        date: endDate,
                        label: 'היום',
                        position: 0 // Leftmost (newest)
                    },
                    {
                        date: new Date(endDate.getTime() - (2 * 30 * 24 * 60 * 60 * 1000)), // 2 months ago
                        label: 'לפני חודשיים',
                        position: null
                    },
                    {
                        date: new Date(endDate.getTime() - (6 * 30 * 24 * 60 * 60 * 1000)), // 6 months ago
                        label: 'לפני חצי שנה',
                        position: null
                    },
                    {
                        date: new Date(endDate.getTime() - (365 * 24 * 60 * 60 * 1000)), // 1 year ago
                        label: 'לפני שנה',
                        position: null
                    },
                    {
                        date: new Date(endDate.getTime() - (1.5 * 365 * 24 * 60 * 60 * 1000)), // 1.5 years ago
                        label: 'לפני שנה וחצי',
                        position: null
                    },
                    {
                        date: startDate, // Oct 27, 2023
                        label: '27 באוקטובר 2023',
                        position: 100 // Rightmost (oldest)
                    }
                ];
                
                // Calculate positions and filter dates within range
                const validDates = countdownDates.filter(dateObj => {
                    if (dateObj.position !== null) return true; // Keep fixed positions
                    
                    // Check if date is within our timeline range
                    if (dateObj.date >= startDate && dateObj.date <= endDate) {
                        const daysFromStart = Math.ceil((dateObj.date - startDate) / (1000 * 60 * 60 * 24));
                        // Position from right (oldest=100%) to left (newest=0%)
                        dateObj.position = 100 - (daysFromStart / totalDays) * 100;
                        return true;
                    }
                    return false; // Filter out dates outside our range
                });
                
                // Create ticks and labels for the countdown dates
                validDates.forEach((dateObj, index) => {
                    // Create tick mark
                    const tick = document.createElement('div');
                    tick.className = 'timeline-tick major';
                    tick.style.left = dateObj.position + '%';
                    axisContainer.appendChild(tick);
                    
                    // Create countdown label
                    const label = document.createElement('div');
                    label.className = 'timeline-date-label';
                    label.style.left = dateObj.position + '%';
                    label.textContent = dateObj.label;
                    label.style.fontFamily = "'Heebo', sans-serif";
                    label.style.direction = 'rtl';
                    
                    // Set alignment based on position: first (rightmost) left-aligned, last (leftmost) right-aligned, others center-aligned
                    if (index === 0) {
                        // First label (rightmost) - left aligned to tick
                        label.style.transform = 'translateX(0%)';
                    } else if (index === validDates.length - 1) {
                        // Last label (leftmost) - right aligned to tick
                        label.style.transform = 'translateX(-100%)';
                    } else {
                        // Middle labels - center aligned to tick
                        label.style.transform = 'translateX(-50%)';
                    }
                    
                    axisContainer.appendChild(label);
                });

                // Add timeline events markers
                console.log('Adding timeline event markers, total events:', this.timelineEvents.length);
                // console.log('Timeline range:', startDate.toLocaleDateString(), 'to', endDate.toLocaleDateString());
                // console.log('Total timeline days:', totalDays);
                
                let markersAdded = 0;
                let markersSkipped = 0;
                
                // Sort events: war-ending events first, then by date (newest first)
                const sortedEvents = this.timelineEvents.slice().sort((a, b) => {
                    // War-ending events (could_have_ended: 'yes' or 'ended_war') come first
                    const aIsWarEnding = (a.could_have_ended === 'yes' || a.could_have_ended === 'ended_war');
                    const bIsWarEnding = (b.could_have_ended === 'yes' || b.could_have_ended === 'ended_war');
                    if (aIsWarEnding && !bIsWarEnding) return -1;
                    if (bIsWarEnding && !aIsWarEnding) return 1;
                    
                    // Within same priority, sort by date (newest first)
                    return b.eventDate - a.eventDate;
                });
                
                sortedEvents.forEach(event => {
                    console.log('Processing event:', event.title_hebrew, 'Date:', event.eventDate);
                    if (event.eventDate && !isNaN(event.eventDate.getTime())) {
                        // Calculate position based on date (0% = endDate/today, 100% = startDate/oldest)
                        // Use same day scale as progress bar and slider for alignment
                        const daysDiff = Math.floor((endDate - event.eventDate) / (1000 * 60 * 60 * 24));
                        const totalDays = this.getTotalTimelineDays();
                        const position = (daysDiff / totalDays) * 100;
                        if (position >= 0 && position <= 100) {
                            // Only show events that have show='show' (skip hide events)
                            if (event.show !== 'show') {
                                markersSkipped++;
                                return;
                            }
                            
                            markersAdded++;
                            
                            // Create event marker
                            const marker = document.createElement('div');
                            marker.className = 'timeline-event-marker';
                            marker.style.position = 'absolute';
                            marker.style.left = position + '%';
                            
                            // Position markers ON the timeline track - layering is now fixed!
                            const trackOffsetFromAxis = -4.5; // Track is 5px above axis  
                            marker.style.top = `${trackOffsetFromAxis}px`; // ON the timeline track
                            marker.style.transform = 'translate(-50%, -50%)';
                            
                            // Original marker size
                            marker.style.width = '8px';
                            marker.style.height = '8px';
                            
                            // Set color based on category
                            let markerColor;
                            const isMilitaryCategory = event.category === 'military' || 
                                                      event.category === 'military_withdrawal' || 
                                                      event.category === 'military_operation';
                            
                            // Debug military events specifically
                            if (isMilitaryCategory) {
                                console.log(`Military event: "${event.title_hebrew}" - category: ${event.category}, could_have_ended: ${event.could_have_ended}`);
                            }
                            const isPoliticalCategory = event.category === 'coalition_threat' ||
                                                       event.category === 'extremist_statement' ||
                                                       event.category === 'political_admission' ||
                                                       event.category === 'coalition_departure' ||
                                                       event.category === 'political_manipulation';
                            
                            if (event.could_have_ended === 'yes' || event.could_have_ended === 'ended_war') {
                                markerColor = '#1168FF'; // Blue for war-ending events ONLY
                                if (event.title_hebrew.includes('הקלות חמאס')) {
                                    console.log(`DEBUG: ${event.title_hebrew} - could_have_ended: "${event.could_have_ended}" - should be BLUE`);
                                }
                            } else if (isPoliticalCategory) {
                                markerColor = '#FF8800'; // Orange for political events
                                if (event.title_hebrew.includes('הקלות חמאס')) {
                                    console.log(`DEBUG: ${event.title_hebrew} - isPoliticalCategory: true - should be ORANGE`);
                                }
                            } else {
                                markerColor = '#000000'; // Black for all other events (military, etc.)
                            }
                            marker.style.background = markerColor;
                            marker.style.border = '2px solid #ffffff';
                            marker.style.borderRadius = '50%';
                            
                            // Restore original marker design (no debug colors)
                            // marker.style.background = markerColor; (set above)
                            // marker.style.border = '2px solid #ffffff'; (set above)
                            // marker.style.borderRadius = '50%'; (set above)
                            
                            // All events use the same circular style
                            marker.classList.add('could-have-ended-marker');
                            
                            marker.style.cursor = 'pointer';
                            marker.style.zIndex = '10'; // Lower than slider's 30/1000
                            // Remove shadow
                            // marker.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            marker.style.pointerEvents = 'auto';
                            
                            // Create diagonal label
                            const label = document.createElement('div');
                            label.className = 'timeline-event-label war-ending';
                            label.textContent = event.title_hebrew;
                            
                            // Position label so its RIGHT side is above and to the left of the marker
                            // The label's right edge should be to the left of the point
                            label.style.position = 'absolute';
                            label.style.right = `calc(${100 - position}% + 10px)`; // Position from right side
                            label.style.top = `${trackOffsetFromAxis - 18}px`; // Above the marker
                            label.style.transform = 'rotate(30deg)';
                            label.style.transformOrigin = 'right bottom';
                            
                            axisContainer.appendChild(label);
                            
                            // Create custom immediate tooltip
                            let currentTooltip = null;
                            let currentTooltipStyle = null;
                            
                            // CSS handles the hover scaling now - no JavaScript needed for basic hover
                            // Use regular timeline tooltip when hovering over event markers
                            marker.onmouseenter = (e) => {
                                // Set flag to prevent timeline hover interference
                                if (typeof isHoveringEventMarker !== 'undefined') {
                                    isHoveringEventMarker = true;
                                }
                                
                                // Calculate days from today to this event date
                                const totalDays = this.getTotalTimelineDays();
                                const eventDays = Math.round((this.todayDate - event.eventDate) / (1000 * 60 * 60 * 24));
                                
                                // Update ONLY the tooltip without affecting persistent UI elements
                                this.updateTooltipOnly(eventDays, event.eventDate);
                                
                                // Manually position tooltip at the event marker location
                                const tooltip = document.getElementById('timelineTooltip');
                                const track = document.querySelector('.timeline-track');
                                
                                // Ensure tooltip is visible when hovering event marker
                                if (tooltip) {
                                    tooltip.style.opacity = '1';
                                }
                                if (tooltip && track) {
                                    const trackWidth = track.offsetWidth;
                                    const tooltipWidth = tooltip.offsetWidth;
                                    const markerLeft = (position / 100) * trackWidth;
                                    
                                    // Calculate ideal tooltip position (centered on marker)
                                    const idealLeft = markerLeft - (tooltipWidth / 2);
                                    const minLeft = 0;
                                    const maxLeft = trackWidth - tooltipWidth;
                                    const wouldOverflow = idealLeft < minLeft || idealLeft > maxLeft;
                                    
                                    if (wouldOverflow) {
                                        // Use constrained positioning with dynamic triangle
                                        const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, idealLeft));
                                        tooltip.style.left = constrainedLeft + 'px';
                                        tooltip.style.transform = 'none';
                                        
                                        // Calculate triangle position relative to tooltip
                                        const triangleOffset = markerLeft - constrainedLeft;
                                        const trianglePercent = (triangleOffset / tooltipWidth) * 100;
                                        const constrainedTrianglePercent = Math.max(5, Math.min(95, trianglePercent));
                                        tooltip.style.setProperty('--triangle-left', constrainedTrianglePercent + '%');
                                    } else {
                                        // Use CSS centering method when tooltip fits comfortably
                                        tooltip.style.left = markerLeft + 'px';
                                        tooltip.style.transform = 'translateX(-50%)';
                                        tooltip.style.setProperty('--triangle-left', '50%');
                                    }
                                }
                            };
                            
                            marker.onmouseleave = () => {
                                // Clear flag to allow timeline hover again
                                if (typeof isHoveringEventMarker !== 'undefined') {
                                    isHoveringEventMarker = false;
                                }
                                
                                // Restore tooltip to current timeline position without affecting description
                                const slider = document.getElementById('timelineSlider');
                                if (slider) {
                                    const currentSliderValue = parseInt(slider.value);
                                    const currentDate = new Date(this.todayDate);
                                    currentDate.setDate(currentDate.getDate() - currentSliderValue);
                                    this.updateTooltipOnly(currentSliderValue, currentDate);
                                }
                                
                                // CSS handles scaling reset automatically - just manage z-index
                                marker.style.zIndex = '100';
                            };
                            
                            // Click to jump to event date
                            marker.onclick = () => {
                                this.jumpToEventDate(event.eventDate);
                            };
                            
                            axisContainer.appendChild(marker);
                            console.log(`✅ Created marker for: ${event.title} at ${position}% with hover handlers`);
                            // console.log(`✅ Successfully added marker for: ${event.title_hebrew} (${event.stance}) at position ${position.toFixed(1)}% - BELOW timeline`);
                            markersAdded++;
                        } else {
                            // console.log(`❌ Skipping event "${event.title_hebrew}" - position out of range: ${position.toFixed(1)}%`);
                            markersSkipped++;
                        }
                    } else {
                        // console.log(`❌ Skipping event "${event.title_hebrew}" - invalid date:`, event.eventDate);
                        markersSkipped++;
                    }
                });
                
                // console.log(`\n📊 Timeline markers summary: ${markersAdded} added, ${markersSkipped} skipped, ${this.timelineEvents.length} total`);
                
                // Generate area chart after timeline axis
                this.generateAreaChart();
            }

            getEventAtDate(currentDate) {
                // Find timeline event that matches the current date exactly
                const currentNormalized = new Date(currentDate);
                currentNormalized.setHours(12, 0, 0, 0);
                
                const result = this.timelineEvents.find(event => {
                    if (!event.eventDate) return false;
                    
                    // Only show events that are marked as visible
                    if (event.show !== 'show') return false;
                    
                    const eventNormalized = new Date(event.eventDate);
                    eventNormalized.setHours(12, 0, 0, 0);
                    
                    const isMatch = currentNormalized.getTime() === eventNormalized.getTime();
                    
                    return isMatch;
                });
                
                return result;
            }

            updateTimelineDescription(event, isNext = false) {
                const timelineDescriptionEl = document.getElementById('timelineDescription');
                if (!timelineDescriptionEl) {
                    return;
                }
                
                if (!event) {
                    timelineDescriptionEl.style.opacity = '0';
                    setTimeout(() => {
                        timelineDescriptionEl.innerHTML = '';
                    }, 300);
                    return;
                }
                
                const descriptionText = event.description_hebrew || event.title_hebrew;
                const prefix = isNext ? 'הבא: ' : '';
                
                // Fade out current content
                timelineDescriptionEl.style.opacity = '0';
                
                setTimeout(() => {
                    console.log('🔧 DEBUG: Setting content after 300ms delay');
                    // Update content - different behavior for mobile vs desktop
                    let content;
                    
                    if (this.isMobile && event.source && event.source.startsWith('http')) {
                        // Mobile: Make entire text clickable without icon
                        content = `<a href="${event.source}" target="_blank" class="timeline-description-mobile-link" title="קישור למקור">${prefix}${descriptionText}</a>`;
                    } else if (event.source && event.source.startsWith('http')) {
                        // Desktop: Text + icon link
                        content = `${prefix}${descriptionText} <a href="${event.source}" target="_blank" class="timeline-description-link" title="קישור למקור">
                             <i data-lucide="link"></i>
                         </a>`;
                    } else {
                        // No link: just text
                        content = `${prefix}${descriptionText}`;
                    }
                    
                    console.log('🔧 DEBUG: Setting innerHTML:', content);
                    timelineDescriptionEl.innerHTML = content;
                    console.log('🔧 DEBUG: innerHTML after setting:', timelineDescriptionEl.innerHTML);
                    
                    // Initialize Lucide icons
                    if (window.lucide) {
                        lucide.createIcons({
                    'skip-back': {
                        width: 16,
                        height: 16
                    }
                });
                    }
                    
                    // Fade in new content
                    console.log('🔧 DEBUG: Setting opacity to 1');
                    timelineDescriptionEl.style.opacity = '1';
                    console.log('🔧 DEBUG: Final element state:', {
                        opacity: timelineDescriptionEl.style.opacity,
                        display: getComputedStyle(timelineDescriptionEl).display,
                        visibility: getComputedStyle(timelineDescriptionEl).visibility,
                        position: getComputedStyle(timelineDescriptionEl).position,
                        left: getComputedStyle(timelineDescriptionEl).left,
                        top: getComputedStyle(timelineDescriptionEl).top
                    });
                }, 300);
            }

            jumpToEventDate(eventOrDate) {
                // Handle both event objects and date objects
                const eventDate = eventOrDate.eventDate || eventOrDate;
                
                // Calculate days back from today to the event date using normalized dates
                const todayNormalized = new Date(this.todayDate);
                todayNormalized.setHours(12, 0, 0, 0);
                
                const eventNormalized = new Date(eventDate);
                eventNormalized.setHours(12, 0, 0, 0);
                
                const msPerDay = 1000 * 60 * 60 * 24;
                const daysBack = Math.round((todayNormalized - eventNormalized) / msPerDay);
                
                
                // Ensure the value is within slider bounds
                const totalDays = this.getTotalTimelineDays();
                const constrainedDays = Math.max(0, Math.min(totalDays, daysBack));
                
                // Update slider and timeline
                const slider = document.getElementById('timelineSlider');
                slider.value = constrainedDays;
                
                // Mark as manual input (not animating)
                this.isTimelineAnimating = false;
                this.lastTooltipUpdate = Date.now();
                
                // Calculate new end date
                const newEndDate = new Date(this.todayDate);
                newEndDate.setDate(newEndDate.getDate() - constrainedDays);
                this.currentEndDate = newEndDate;
                
                // Update timeline progress
                const progress = ((totalDays - constrainedDays) / totalDays) * 100;
                document.getElementById('timelineProgress').style.width = progress + '%';
                
                // Add small delay to ensure slider position is visually updated before tooltip positioning
                setTimeout(() => {
                    this.updateTooltip(constrainedDays, this.currentEndDate);
                    this.updateVisualization();
                }, 10);
                
                // console.log(`Jumped to event date: ${eventDate.toLocaleDateString()}, days back: ${constrainedDays}`);
            }

            generateAreaChart() {
                // console.log('Generating area chart for cumulative fallen soldiers');
                
                this.generateFallenChart();
                this.generateLivingChart();
            }

            generateFallenChart() {
                // console.log('Generating area chart for cumulative fallen soldiers');
                
                const totalDays = this.getTotalTimelineDays();
                const weeklyData = [];
                
                // Add starting point at war beginning (Oct 7th) with 0 casualties
                weeklyData.push({
                    week: -1,
                    cumulativeFallen: 0,
                    weekStart: new Date(this.startDate),
                    weekEnd: new Date(this.startDate),
                    displayDate: new Date(this.startDate)
                });
                
                // Group soldiers by week and calculate cumulative totals
                let cumulativeTotal = 0;
                for (let week = 0; week < Math.ceil(totalDays / 7); week++) {
                    const weekStart = new Date(this.startDate);
                    weekStart.setDate(weekStart.getDate() + (week * 7));
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    
                    // Count soldiers who died up to the end of this week
                    const totalFallenUpToThisWeek = this.soldiers.filter(soldier => {
                        return soldier.death_date <= weekEnd && soldier.death_date >= this.startDate;
                    }).length;
                    
                    // Position this week's data at the END of the week (weekEnd) for chart alignment
                    weeklyData.push({
                        week: week,
                        cumulativeFallen: totalFallenUpToThisWeek,
                        weekStart: weekStart,
                        weekEnd: weekEnd,
                        displayDate: weekEnd  // Use week end for positioning
                    });
                }
                
                // Find max value for scaling (use cumulative values)
                const maxFallen = Math.max(...weeklyData.map(d => d.cumulativeFallen));
                if (maxFallen === 0) return; // No data to chart
                
                // Generate SVG path with smooth curves (RTL: newest weeks on left, oldest on right)
                const viewBoxWidth = 100;
                const viewBoxHeight = 40;
                
                // Create points array for smooth curve generation
                const points = [];
                weeklyData.forEach((week, index) => {
                    // Position each week's data at its display date for better alignment
                    const displayDaysFromToday = Math.floor((this.todayDate - week.displayDate) / (1000 * 60 * 60 * 24));
                    const x = (displayDaysFromToday / totalDays) * viewBoxWidth;
                    // Flip the chart: higher fallen count = hanging down more (lower Y = more down)
                    const y = (week.cumulativeFallen / maxFallen) * viewBoxHeight;
                    points.push({x, y, cumulativeFallen: week.cumulativeFallen, displayDate: week.displayDate});
                });
                
                // Sort points by X position for proper chart drawing
                points.sort((a, b) => a.x - b.x);
                
                // Start area path from bottom at first data point's X position
                let pathData = '';
                if (points.length > 0) {
                    pathData = `M ${points[0].x},${viewBoxHeight} L ${points[0].x},${points[0].y}`;
                }
                
                // Generate smooth curve using proper spline interpolation
                if (points.length > 1) {
                    for (let i = 1; i < points.length; i++) {
                        const prev = points[i-1];
                        const curr = points[i];
                        const next = points[i + 1] || curr;
                        const prevPrev = points[i - 2] || prev;
                        
                        // Calculate smooth control points using cardinal spline method
                        const tension = 0.3; // Controls curve tightness
                        
                        // Calculate tangent vectors for smooth flow
                        let cp1x, cp1y, cp2x, cp2y;
                        
                        if (i === 1) {
                            // First curve: control point 1 goes in direction toward current point
                            cp1x = prev.x + (curr.x - prev.x) * tension;
                            cp1y = prev.y + (curr.y - prev.y) * tension;
                        } else {
                            // Subsequent curves: control point 1 follows the flow from previous-previous to current
                            const tangentX = (curr.x - prevPrev.x) * tension;
                            const tangentY = (curr.y - prevPrev.y) * tension;
                            cp1x = prev.x + tangentX;
                            cp1y = prev.y + tangentY;
                        }
                        
                        if (i === points.length - 1) {
                            // Last curve: control point 2 comes from direction of previous point
                            cp2x = curr.x - (curr.x - prev.x) * tension;
                            cp2y = curr.y - (curr.y - prev.y) * tension;
                        } else {
                            // Other curves: control point 2 follows flow from previous to next
                            const tangentX = (next.x - prev.x) * tension;
                            const tangentY = (next.y - prev.y) * tension;
                            cp2x = curr.x - tangentX;
                            cp2y = curr.y - tangentY;
                        }
                        
                        pathData += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${curr.x},${curr.y}`;
                    }
                }
                
                // Close the path to form an area (go down to bottom at last point, then back to start)
                if (points.length > 0) {
                    const lastPoint = points[points.length - 1];
                    pathData += ` L ${lastPoint.x},${viewBoxHeight} L ${points[0].x},${viewBoxHeight} Z`;
                }
                
                // Get current timeline position (progress bar position)
                // The timeline runs from right (100% = start) to left (0% = today)
                const daysFromToday = this.currentEndDate ? 
                    Math.ceil((this.todayDate - this.currentEndDate) / (1000 * 60 * 60 * 24)) : 0;
                const currentTimelineProgress = (daysFromToday / totalDays) * 100;
                
                // console.log('Timeline split calculation:', {
                //     totalDays,
                //     daysFromToday,
                //     currentTimelineProgress,
                //     currentEndDate: this.currentEndDate
                // });
                
                // Split the chart at the current timeline position
                this.generateSplitAreaChart(points, viewBoxHeight, currentTimelineProgress);
                
                // console.log(`RTL Area chart generated: ${weeklyData.length} weeks, max fallen: ${maxFallen}`);
                
                // Generate military events chart
                // this.generateMilitaryEventsChart(); // Hidden as requested
            }


            generateSplitAreaChart(points, viewBoxHeight, splitPosition) {
                if (points.length === 0) return;
                
                // console.log('Splitting chart at position:', splitPosition, 'with', points.length, 'points');
                // console.log('Points X positions:', points.map(p => p.x.toFixed(1)));
                
                // Split points into past (right of split) and future (left of split) 
                const pastPoints = points.filter(p => p.x >= splitPosition);
                const futurePoints = points.filter(p => p.x <= splitPosition);
                
                // console.log('Past points:', pastPoints.length, 'Future points:', futurePoints.length);
                
                // Add split point if needed to connect the two sections
                if (pastPoints.length > 0 && futurePoints.length > 0) {
                    // Find the interpolated value at the split position
                    const leftPoint = points.find(p => p.x <= splitPosition) || points[0];
                    const rightPoint = points.find(p => p.x >= splitPosition) || points[points.length - 1];
                    
                    if (leftPoint && rightPoint && leftPoint !== rightPoint) {
                        const ratio = (splitPosition - leftPoint.x) / (rightPoint.x - leftPoint.x);
                        const interpolatedY = leftPoint.y + (rightPoint.y - leftPoint.y) * ratio;
                        const splitPoint = { x: splitPosition, y: interpolatedY, cumulativeFallen: 0 };
                        
                        // Add split point to both arrays
                        if (!futurePoints.find(p => p.x === splitPosition)) {
                            futurePoints.push(splitPoint);
                        }
                        if (!pastPoints.find(p => p.x === splitPosition)) {
                            pastPoints.unshift(splitPoint);
                        }
                    }
                }
                
                // Generate path for past section (visible) - flipped for fallen chart
                const pastPath = this.generateFlippedPathData(pastPoints, viewBoxHeight);
                const pastPathElement = document.getElementById('areaPathPast');
                if (pastPathElement) {
                    pastPathElement.setAttribute('d', pastPath);
                }
                
                // Generate path for future section (transparent) - flipped for fallen chart
                const futurePath = this.generateFlippedPathData(futurePoints, viewBoxHeight);
                const futurePathElement = document.getElementById('areaPathFuture');
                if (futurePathElement) {
                    futurePathElement.setAttribute('d', futurePath);
                }
            }

            generateLivingChart() {
                try {
                    console.log('Generating living chart...');
                    
                    const viewBoxWidth = 100;
                    const viewBoxHeight = 40;
                    
                    // Calculate total soldiers
                    const totalSoldiers = this.soldiers ? this.soldiers.filter(soldier => 
                        soldier.death_date >= this.startDate
                    ).length : 0;
                    
                    if (totalSoldiers === 0) {
                        console.warn('No soldiers data for living chart');
                        return;
                    }
                    
                    // Get current timeline position for splitting (same logic as fallen chart)
                    const totalDays = this.getTotalTimelineDays();
                    const daysFromToday = this.currentEndDate ? 
                        Math.ceil((this.todayDate - this.currentEndDate) / (1000 * 60 * 60 * 24)) : 0;
                    const currentTimelineProgress = daysFromToday / totalDays;
                    const splitX = currentTimelineProgress * viewBoxWidth;
                    
                    // Calculate living soldiers at the selected date
                    const selectedDate = this.currentEndDate || this.todayDate;
                    const fallenAtSelectedDate = this.soldiers.filter(soldier => {
                        return soldier.death_date <= selectedDate && soldier.death_date >= this.startDate;
                    }).length;
                    const livingAtSelectedDate = totalSoldiers - fallenAtSelectedDate;
                    
                    // Calculate Y position for living count (higher count = lower Y = further up)
                    const selectedY = viewBoxHeight - (livingAtSelectedDate / totalSoldiers) * viewBoxHeight;
                    
                    console.log(`Living chart: ${livingAtSelectedDate}/${totalSoldiers} alive at selected date, Y=${selectedY}`);
                    
                    // Create declining line from start (all alive) to selected date
                    const pastPath = `M ${viewBoxWidth} ${viewBoxHeight} L ${viewBoxWidth} 0 L ${splitX} ${selectedY} L ${splitX} ${viewBoxHeight} Z`;
                    const pastPathElement = document.getElementById('livingPathPast');
                    if (pastPathElement) {
                        pastPathElement.setAttribute('d', pastPath);
                        console.log('Past path set:', pastPath);
                    } else {
                        console.error('livingPathPast element not found!');
                    }
                    
                    // Create flat future projection at the living count from selected date
                    const futurePath = `M ${splitX} ${viewBoxHeight} L ${splitX} ${selectedY} L 0 ${selectedY} L 0 ${viewBoxHeight} Z`;
                    const futurePathElement = document.getElementById('livingPathFuture');
                    if (futurePathElement) {
                        futurePathElement.setAttribute('d', futurePath);
                        console.log('Future path set:', futurePath);
                    } else {
                        console.error('livingPathFuture element not found!');
                    }
                    
                    console.log('Living chart generation completed. SplitX:', splitX);
                    
                } catch (error) {
                    console.error('Error in generateLivingChart:', error);
                }
            }

            generatePathData(points, viewBoxHeight) {
                if (points.length === 0) return '';
                
                // Sort points by X position for proper chart drawing
                points.sort((a, b) => a.x - b.x);
                
                // Start area path from bottom at first data point's X position
                let pathData = '';
                if (points.length > 0) {
                    pathData = `M ${points[0].x},${viewBoxHeight} L ${points[0].x},${points[0].y}`;
                }
                
                // Generate smooth curve using proper spline interpolation
                if (points.length > 1) {
                    for (let i = 1; i < points.length; i++) {
                        const prev = points[i-1];
                        const curr = points[i];
                        const next = points[i + 1] || curr;
                        const prevPrev = points[i - 2] || prev;
                        
                        // Calculate smooth control points using cardinal spline method
                        const tension = 0.3; // Controls curve tightness
                        
                        // Calculate tangent vectors for smooth flow
                        let cp1x, cp1y, cp2x, cp2y;
                        
                        if (i === 1) {
                            // First curve: control point 1 goes in direction toward current point
                            cp1x = prev.x + (curr.x - prev.x) * tension;
                            cp1y = prev.y + (curr.y - prev.y) * tension;
                        } else {
                            // Subsequent curves: control point 1 follows the flow from previous-previous to current
                            const tangentX = (curr.x - prevPrev.x) * tension;
                            const tangentY = (curr.y - prevPrev.y) * tension;
                            cp1x = prev.x + tangentX;
                            cp1y = prev.y + tangentY;
                        }
                        
                        if (i === points.length - 1) {
                            // Last curve: control point 2 comes from direction of previous point
                            cp2x = curr.x - (curr.x - prev.x) * tension;
                            cp2y = curr.y - (curr.y - prev.y) * tension;
                        } else {
                            // Other curves: control point 2 follows flow from previous to next
                            const tangentX = (next.x - prev.x) * tension;
                            const tangentY = (next.y - prev.y) * tension;
                            cp2x = curr.x - tangentX;
                            cp2y = curr.y - tangentY;
                        }
                        
                        pathData += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${curr.x},${curr.y}`;
                    }
                }
                
                // Close the path to form an area (go down to bottom at last point, then back to start)
                if (points.length > 0) {
                    const lastPoint = points[points.length - 1];
                    pathData += ` L ${lastPoint.x},${viewBoxHeight} L ${points[0].x},${viewBoxHeight} Z`;
                }
                
                return pathData;
            }

            generateFlatProjectionPath(startX, endX, flatY, viewBoxHeight) {
                // Generate a flat horizontal line from startX to endX at flatY height
                // This represents "how many would still be alive today if war ended at selected time"
                const pathData = `M ${startX},${viewBoxHeight} L ${startX},${flatY} L ${endX},${flatY} L ${endX},${viewBoxHeight} Z`;
                return pathData;
            }

            generateFlippedPathData(points, viewBoxHeight) {
                if (points.length === 0) return '';
                
                // Sort points by X position for proper chart drawing
                points.sort((a, b) => a.x - b.x);
                
                // Start area path from top at first data point's X position (flipped)
                let pathData = '';
                if (points.length > 0) {
                    pathData = `M ${points[0].x},0 L ${points[0].x},${points[0].y}`;
                }
                
                // Generate smooth curve using proper spline interpolation
                if (points.length > 1) {
                    for (let i = 1; i < points.length; i++) {
                        const prev = points[i-1];
                        const curr = points[i];
                        const next = points[i + 1] || curr;
                        const prevPrev = points[i - 2] || prev;
                        
                        // Calculate smooth control points using cardinal spline method
                        const tension = 0.3; // Controls curve tightness
                        
                        // Calculate tangent vectors for smooth flow
                        let cp1x, cp1y, cp2x, cp2y;
                        
                        if (i === 1) {
                            // First curve: control point 1 goes in direction toward current point
                            cp1x = prev.x + (curr.x - prev.x) * tension;
                            cp1y = prev.y + (curr.y - prev.y) * tension;
                        } else {
                            // Subsequent curves: control point 1 follows the flow from previous-previous to current
                            const tangentX = (curr.x - prevPrev.x) * tension;
                            const tangentY = (curr.y - prevPrev.y) * tension;
                            cp1x = prev.x + tangentX;
                            cp1y = prev.y + tangentY;
                        }
                        
                        if (i === points.length - 1) {
                            // Last curve: control point 2 comes from direction of previous point
                            cp2x = curr.x - (curr.x - prev.x) * tension;
                            cp2y = curr.y - (curr.y - prev.y) * tension;
                        } else {
                            // Other curves: control point 2 follows flow from previous to next
                            const tangentX = (next.x - prev.x) * tension;
                            const tangentY = (next.y - prev.y) * tension;
                            cp2x = curr.x - tangentX;
                            cp2y = curr.y - tangentY;
                        }
                        
                        pathData += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${curr.x},${curr.y}`;
                    }
                }
                
                // Close the path to form an area (go up to top at last point, then back to start) - flipped
                if (points.length > 0) {
                    const lastPoint = points[points.length - 1];
                    pathData += ` L ${lastPoint.x},0 L ${points[0].x},0 Z`;
                }
                
                return pathData;
            }
            
            generateMilitaryEventsChart() {
                // console.log('Generating military events combat intensity bar chart');
                
                if (!this.militaryEvents || this.militaryEvents.length === 0) {
                    // console.log('No military events data available');
                    return;
                }
                
                const svg = document.querySelector('#timelineAreaChart svg');
                const totalDays = this.getTotalTimelineDays();
                const viewBoxWidth = 100;
                const viewBoxHeight = 40;
                
                // Clear existing military visualizations
                const existingMilitaryElements = svg.querySelectorAll('.military-bar, .military-path');
                existingMilitaryElements.forEach(element => element.remove());
                
                // Sort military events by date
                const sortedEvents = [...this.militaryEvents].sort((a, b) => a.eventDate - b.eventDate);
                
                // Create time periods for bar chart
                const timePeriods = [];
                let currentIntensity = 0; // Start with 0 intensity before first event
                
                // Add initial period from war start to first event
                if (sortedEvents.length > 0) {
                    const firstEventX = Math.floor((this.todayDate - sortedEvents[0].eventDate) / (1000 * 60 * 60 * 24));
                    const startX = Math.floor((this.todayDate - this.startDate) / (1000 * 60 * 60 * 24));
                    
                    timePeriods.push({
                        startDaysFromToday: startX,
                        endDaysFromToday: firstEventX,
                        intensity: 0, // No combat intensity before first event
                        startDate: this.startDate,
                        endDate: sortedEvents[0].eventDate
                    });
                }
                
                // Create periods between events
                sortedEvents.forEach((event, index) => {
                    const eventDaysFromToday = Math.floor((this.todayDate - event.eventDate) / (1000 * 60 * 60 * 24));
                    const nextEvent = sortedEvents[index + 1];
                    const endDaysFromToday = nextEvent ? 
                        Math.floor((this.todayDate - nextEvent.eventDate) / (1000 * 60 * 60 * 24)) : 0; // End at today if no next event
                    
                    currentIntensity = event.combatIntensity;
                    
                    timePeriods.push({
                        startDaysFromToday: eventDaysFromToday,
                        endDaysFromToday: endDaysFromToday,
                        intensity: currentIntensity,
                        startDate: event.eventDate,
                        endDate: nextEvent ? nextEvent.eventDate : this.todayDate,
                        event: event
                    });
                });
                
                // Create SVG rectangles for each time period
                timePeriods.forEach((period, index) => {
                    if (period.intensity === 0) return; // Skip zero-intensity periods for cleaner visualization
                    
                    // Calculate bar position and dimensions
                    const barStartX = (period.endDaysFromToday / totalDays) * viewBoxWidth;
                    const barEndX = (period.startDaysFromToday / totalDays) * viewBoxWidth;
                    const barWidth = barEndX - barStartX;
                    
                    // Calculate bar height based on intensity (scale to max 16km penetration)
                    // Leave more padding at top to ensure top border is always visible
                    const maxIntensity = 16;
                    const topPadding = 3; // Reserve 3px at top for border visibility
                    const availableHeight = viewBoxHeight - topPadding;
                    const barHeight = (period.intensity / maxIntensity) * availableHeight;
                    const barY = Math.max(topPadding, viewBoxHeight - barHeight); // Ensure minimum distance from top
                    
                    // Skip very narrow bars or bars that extend beyond viewbox
                    if (barWidth < 0.1 || barStartX < 0 || barEndX > viewBoxWidth) return;
                    
                    // Clamp bar boundaries to viewbox
                    const clampedStartX = Math.max(0, barStartX);
                    const clampedEndX = Math.min(viewBoxWidth, barEndX);
                    const clampedWidth = clampedEndX - clampedStartX;
                    
                    if (clampedWidth < 0.1) return; // Skip if clamped bar is too narrow
                    
                    // Create rectangle element using clamped coordinates
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('class', 'military-bar');
                    rect.setAttribute('x', clampedStartX);
                    rect.setAttribute('y', barY);
                    rect.setAttribute('width', clampedWidth);
                    rect.setAttribute('height', barHeight);
                    
                    // Style the bar with more transparent red
                    rect.style.fill = 'rgba(255, 100, 100, 0.06)'; // Even more transparent red
                    rect.style.stroke = 'none'; // No border on rectangle
                    rect.style.zIndex = '-1'; // Ensure behind area chart
                    
                    // Create top border line using clamped coordinates
                    const topBorder = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    topBorder.setAttribute('class', 'military-bar-border');
                    topBorder.setAttribute('x1', clampedStartX);
                    topBorder.setAttribute('y1', barY);
                    topBorder.setAttribute('x2', clampedEndX);
                    topBorder.setAttribute('y2', barY);
                    topBorder.style.stroke = 'rgba(255, 100, 100, 0.9)'; // Very opaque red border
                    topBorder.style.strokeWidth = '1'; // Thicker border for visibility
                    topBorder.style.zIndex = '-1'; // Ensure behind area chart
                    
                    // Add both elements behind the area chart
                    svg.insertBefore(rect, svg.firstChild);
                    svg.insertBefore(topBorder, svg.firstChild);
                    
                    // console.log(`Bar ${index}: X=${barStartX}-${barEndX} (width=${barWidth}), Height=${barHeight}, Intensity=${period.intensity}`);
                });
                
                // console.log(`Military events bar chart generated: ${timePeriods.length} periods, ${timePeriods.filter(p => p.intensity > 0).length} visible bars`);
            }

            setupEventListeners() {
                const slider = document.getElementById('timelineSlider');
                
                slider.addEventListener('input', (e) => {
                    const days = parseInt(e.target.value);
                    
                    // Mark as manual input (not animating)
                    this.isTimelineAnimating = false;
                    this.lastTooltipUpdate = Date.now();
                    
                    // Calculate end date going back from today
                    const newEndDate = new Date(this.todayDate);
                    newEndDate.setDate(newEndDate.getDate() - days);
                    this.currentEndDate = newEndDate;
                    
                    // Update timeline progress (show war period from right, RTL)
                    const totalDays = this.getTotalTimelineDays();
                    const progress = ((totalDays - days) / totalDays) * 100;
                    document.getElementById('timelineProgress').style.width = progress + '%';
                    
                    // Update tooltip
                    this.updateTooltip(days, newEndDate);
                    
                    this.updateVisualization();
                });

                // Setup draggable container
                this.setupDraggableContainer();

                // Setup navigation CTAs
                this.setupNavigationCTAs();
                
                // Setup timeline track hover functionality
                this.setupTimelineTrackHover();

                // Recalculate font size when window is resized with buffer
                window.addEventListener('resize', () => {
                    // Check if we switched between mobile and desktop
                    const wasIsMobile = this.isMobile;
                    this.isMobile = window.innerWidth <= 768;
                    
                    if (wasIsMobile !== this.isMobile) {
                        // Reload page on mobile/desktop switch
                        window.location.reload();
                    }
                    
                    const container = document.getElementById('namesContainer');
                    const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                    setTimeout(() => {
                        const availableWidth = container.clientWidth;
                        const availableHeight = container.clientHeight;
                        if (availableWidth > 0 && availableHeight > 0) {
                            this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                        }
                    }, 100);
                });
            }

            setupDraggableContainer() {
                const container = document.getElementById('draggableContainer');
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };

                container.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons directly
                    
                    isDragging = true;
                    
                    // Apply dragging class immediately for shadow feedback
                    container.classList.add('dragging');
                    
                    const rect = container.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    
                    // Keep container within viewport bounds
                    const maxX = window.innerWidth - container.offsetWidth;
                    const maxY = window.innerHeight - container.offsetHeight;
                    
                    const constrainedX = Math.max(0, Math.min(x, maxX));
                    const constrainedY = Math.max(0, Math.min(y, maxY));
                    
                    // Only change positioning method on first movement, not on mousedown
                    if (container.style.left === '' || container.style.left === 'auto') {
                        container.style.right = 'auto';
                        container.style.transform = 'none';
                    }
                    
                    container.style.left = constrainedX + 'px';
                    container.style.top = constrainedY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        container.classList.remove('dragging');
                    }
                });
            }

            setupTimelineTrackHover() {
                const track = document.querySelector('.timeline-track');
                const tooltip = document.getElementById('timelineTooltip');
                const slider = document.getElementById('timelineSlider');
                const container = document.querySelector('.timeline-container');
                
                if (!track || !tooltip || !slider || !container) return;
                
                let isHoveringHandle = false;
                let isTrackHovering = false;
                let isHoveringEventMarker = false;
                
                // Check if mouse is over the slider handle
                const isMouseOverHandle = (e) => {
                    const sliderRect = slider.getBoundingClientRect();
                    const trackRect = track.getBoundingClientRect();
                    
                    // Calculate current handle position
                    const sliderValue = parseInt(slider.value);
                    const totalDays = this.getTotalTimelineDays();
                    const handlePercent = (sliderValue / totalDays) * 100;
                    const handleLeft = (handlePercent / 100) * trackRect.width;
                    const handleCenterX = trackRect.left + handleLeft;
                    
                    // Check if mouse is within handle bounds (8px radius)
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    const handleRadius = 8;
                    
                    return Math.abs(mouseX - handleCenterX) <= handleRadius && 
                           mouseY >= sliderRect.top - handleRadius && 
                           mouseY <= sliderRect.bottom + handleRadius;
                };
                
                // Check if mouse is close to the timeline track (not just anywhere in container)
                const isMouseNearTrack = (e) => {
                    const trackRect = track.getBoundingClientRect();
                    const mouseY = e.clientY;
                    const trackCenterY = trackRect.top + (trackRect.height / 2);
                    const proximityThreshold = 30; // 30px tolerance around track
                    
                    return Math.abs(mouseY - trackCenterY) <= proximityThreshold;
                };
                
                container.addEventListener('mouseenter', (e) => {
                    // Start tracking
                });
                
                container.addEventListener('mousemove', (e) => {
                    // IGNORE if mouse is over a timeline marker - let markers handle their own hover
                    if (e.target && e.target.classList.contains('timeline-event-marker')) {
                        return;
                    }
                    
                    // IGNORE if we're currently hovering over an event marker
                    if (isHoveringEventMarker) {
                        return;
                    }
                    
                    const wasHoveringHandle = isHoveringHandle;
                    isHoveringHandle = isMouseOverHandle(e);
                    
                    if (isHoveringHandle) {
                        // Mouse is over handle - disable track hover
                        if (isTrackHovering) {
                            track.classList.remove('hovering');
                            container.classList.remove('track-hovering', 'on-event');
                            isTrackHovering = false;
                            
                            // Restore tooltip to current slider position
                            const currentSliderValue = parseInt(slider.value);
                            const currentDate = new Date(this.todayDate);
                            currentDate.setDate(currentDate.getDate() - currentSliderValue);
                            this.updateTooltip(currentSliderValue, currentDate);
                        }
                        
                        // Ensure tooltip is visible when hovering handle
                        tooltip.style.opacity = '1';
                    } else if (isMouseNearTrack(e)) {
                        // Mouse is near track but not handle - enable track hover
                        if (!isTrackHovering) {
                            track.classList.add('hovering');
                            container.classList.add('track-hovering');
                            isTrackHovering = true;
                        }
                        
                        // Ensure tooltip is visible when hovering track
                        tooltip.style.opacity = '1';
                        
                        const rect = track.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const trackWidth = rect.width;
                        
                        // Calculate percentage position along track
                        const percentage = (x / trackWidth) * 100;
                        const clampedPercentage = Math.max(0, Math.min(100, percentage));
                        
                        // Calculate corresponding timeline date
                        const totalDays = this.getTotalTimelineDays();
                        const daysBack = Math.round((clampedPercentage / 100) * totalDays);
                        const hoverDate = new Date(this.todayDate);
                        hoverDate.setDate(hoverDate.getDate() - daysBack);
                        
                        // Update tooltip position and content
                        const handleLeft = (clampedPercentage / 100) * trackWidth;
                        
                        // Calculate tooltip positioning with triangle adjustment
                        const tooltipWidth = tooltip.offsetWidth;
                        const idealLeft = handleLeft - (tooltipWidth / 2);
                        const minLeft = 0;
                        const maxLeft = trackWidth - tooltipWidth;
                        const wouldOverflow = idealLeft < minLeft || idealLeft > maxLeft;
                        
                        if (wouldOverflow) {
                            // Use constrained positioning with dynamic triangle
                            const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, idealLeft));
                            tooltip.style.left = constrainedLeft + 'px';
                            tooltip.style.transform = 'none';
                            
                            // Calculate triangle position relative to tooltip
                            const triangleOffset = handleLeft - constrainedLeft;
                            const trianglePercent = (triangleOffset / tooltipWidth) * 100;
                            const constrainedTrianglePercent = Math.max(5, Math.min(95, trianglePercent));
                            tooltip.style.setProperty('--triangle-left', constrainedTrianglePercent + '%');
                        } else {
                            // Use CSS centering method when tooltip fits comfortably
                            tooltip.style.left = handleLeft + 'px';
                            tooltip.style.transform = 'translateX(-50%)';
                            tooltip.style.setProperty('--triangle-left', '50%');
                        }
                        
                        // Update tooltip date
                        const day = hoverDate.getDate().toString().padStart(2, '0');
                        const month = (hoverDate.getMonth() + 1).toString().padStart(2, '0');
                        const year = hoverDate.getFullYear().toString().slice(-2);
                        const formattedDate = `${day}/${month}/${year}`;
                        
                        const tooltipDate = document.getElementById('tooltipDate');
                        if (tooltipDate) {
                            tooltipDate.textContent = formattedDate;
                        }
                        
                        // Calculate alive soldiers for hover date
                        const aliveSoldiers = this.soldiers.filter(s => s.death_date > hoverDate).length;
                        const tooltipAlive = document.getElementById('tooltipAlive');
                        if (tooltipAlive) {
                            tooltipAlive.innerHTML = `<div style="font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">היו יכולים להיות חיים היום: ${aliveSoldiers.toLocaleString()}</div>`;
                        }
                        
                        // Check if hover date matches any timeline event for cursor state
                        const eventAtHoverDate = this.getEventAtDate(hoverDate);
                        if (eventAtHoverDate) {
                            container.classList.add('on-event');
                        } else {
                            container.classList.remove('on-event');
                        }
                    } else {
                        // Mouse is not near track - disable track hover but show handle tooltip
                        if (isTrackHovering) {
                            track.classList.remove('hovering');
                            container.classList.remove('track-hovering', 'on-event');
                            isTrackHovering = false;
                            
                            // Restore tooltip to current slider position
                            const currentSliderValue = parseInt(slider.value);
                            const currentDate = new Date(this.todayDate);
                            currentDate.setDate(currentDate.getDate() - currentSliderValue);
                            this.updateTooltip(currentSliderValue, currentDate);
                        }
                        
                        // Show handle tooltip when hovering anywhere in timeline container
                        tooltip.style.opacity = '1';
                    }
                });
                
                container.addEventListener('mouseleave', () => {
                    // Don't interfere if we're hovering over an event marker
                    if (isHoveringEventMarker) {
                        return;
                    }
                    
                    if (isTrackHovering) {
                        track.classList.remove('hovering');
                        container.classList.remove('track-hovering', 'on-event');
                        isTrackHovering = false;
                        
                        // Restore tooltip to current slider position
                        const currentSliderValue = parseInt(slider.value);
                        const currentDate = new Date(this.todayDate);
                        currentDate.setDate(currentDate.getDate() - currentSliderValue);
                        this.updateTooltip(currentSliderValue, currentDate);
                    }
                    isHoveringHandle = false;
                    
                    // Force hide the tooltip when leaving the timeline container
                    tooltip.style.opacity = '0';
                });
            }

            setupNavigationCTAs() {
                const ctaBack = document.getElementById('ctaBack');
                const ctaContinue = document.getElementById('ctaContinue');

                ctaBack.addEventListener('click', () => {
                    const prevEvent = this.getPrevTimelineEvent();
                    if (prevEvent) {
                        this.jumpToEventDate(prevEvent);
                    }
                });

                ctaContinue.addEventListener('click', () => {
                    console.log('המשך button clicked');
                    const nextEvent = this.getNextTimelineEvent();
                    console.log('Next event found:', nextEvent);
                    if (nextEvent) {
                        console.log('Jumping to event:', nextEvent.title_hebrew);
                        this.jumpToEventDate(nextEvent);
                    } else {
                        console.log('No next event found');
                    }
                });
            }

            getNextTimelineEvent() {
                if (!this.timelineEvents) {
                    console.log('No timelineEvents available');
                    return null;
                }
                
                // Get all visible events sorted by days_from_start (oldest first)
                const visibleEvents = this.timelineEvents
                    .filter(event => event.show === 'show')
                    .sort((a, b) => parseInt(a.days_from_start) - parseInt(b.days_from_start));
                
                console.log('Visible events:', visibleEvents.map(e => ({id: e.id, title: e.title_hebrew, show: e.show})));
                console.log('Total visible events found:', visibleEvents.length);
                
                if (visibleEvents.length === 0) {
                    console.log('No visible events found');
                    return null;
                }
                
                // Calculate current timeline position
                const timelineSlider = document.getElementById('timelineSlider');
                const currentSliderValue = parseInt(timelineSlider.value);
                
                // Calculate current date from slider position
                const currentDaysBack = currentSliderValue;
                const currentDate = new Date(this.todayDate);
                currentDate.setDate(currentDate.getDate() - currentDaysBack);
                
                console.log('Current date:', currentDate.toDateString(), 'Slider value:', currentSliderValue);
                
                // Find the next visible event chronologically AFTER current date
                let nextEvent = visibleEvents.find(event => {
                    console.log('Checking event:', event.title_hebrew, 'Date:', event.eventDate, 'After current?', event.eventDate > currentDate);
                    return event.eventDate > currentDate;
                });
                
                // If no event found after current position, loop back to the first event
                if (!nextEvent) {
                    console.log('No next event found, looping to first');
                    nextEvent = visibleEvents[0];
                }
                
                return nextEvent;
            }

            getPrevTimelineEvent() {
                if (!this.timelineEvents) return null;
                
                // Get all visible events sorted by days_from_start (newest first)
                const visibleEvents = this.timelineEvents
                    .filter(event => event.show === 'show')
                    .sort((a, b) => parseInt(b.days_from_start) - parseInt(a.days_from_start));
                
                if (visibleEvents.length === 0) return null;
                
                // Calculate current timeline position
                const timelineSlider = document.getElementById('timelineSlider');
                const currentSliderValue = parseInt(timelineSlider.value);
                
                // Calculate current date from slider position
                const currentDaysBack = currentSliderValue;
                const currentDate = new Date(this.todayDate);
                currentDate.setDate(currentDate.getDate() - currentDaysBack);
                
                // Find the previous visible event chronologically BEFORE current date
                let prevEvent = visibleEvents.find(event => {
                    return event.eventDate < currentDate;
                });
                
                // If no event found before current position, loop back to the last event
                if (!prevEvent) {
                    prevEvent = visibleEvents[0]; // This is the newest event due to reverse sort
                }
                
                return prevEvent;
            }

            updateTooltipOnly(days, currentDate) {
                // This function ONLY updates the timeline tooltip, not persistent UI elements
                // Used for hover previews without affecting selected date display
                const tooltip = document.getElementById('timelineTooltip');
                const tooltipDate = document.getElementById('tooltipDate');
                const tooltipAlive = document.getElementById('tooltipAlive');
                const slider = document.getElementById('timelineSlider');
                const track = document.querySelector('.timeline-track');
                
                if (!tooltip || !tooltipDate || !tooltipAlive || !slider || !this.soldiers || !track) {
                    return; // Elements or data not ready yet
                }
                
                // Format date as dd/mm/yy
                const day = currentDate.getDate().toString().padStart(2, '0');
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const year = currentDate.getFullYear().toString().slice(-2);
                const formattedDate = `${day}/${month}/${year}`;
                
                // Calculate alive soldiers for this date
                const aliveSoldiers = this.soldiers.filter(s => s.death_date > currentDate).length;
                
                // Check if there's an event on this date
                const eventAtDate = this.getEventAtDate(currentDate);
                const isStoppedOverEvent = eventAtDate && !this.isTimelineAnimating;
                
                if (isStoppedOverEvent) {
                    // Show event details in tooltip
                    const titleLink = eventAtDate.source && eventAtDate.source.startsWith('http')
                        ? `<a href="${eventAtDate.source}" target="_blank" style="color: inherit; text-decoration: none;">${eventAtDate.title_hebrew}</a>`
                        : eventAtDate.title_hebrew;
                    
                    tooltipDate.innerHTML = titleLink;
                    tooltipAlive.innerHTML = `
                        <div style="font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px; margin-top: 4px;">
                            היו יכולים להיות חיים היום: ${aliveSoldiers.toLocaleString()}
                        </div>
                    `;
                } else {
                    // Regular tooltip content
                    tooltipDate.textContent = formattedDate;
                    tooltipAlive.innerHTML = `<div style="font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">היו יכולים להיות חיים היום: ${aliveSoldiers}</div>`;
                }
                
                // Force layout recalculation
                tooltip.offsetWidth; // Force layout recalculation
                
                // Update tooltip positioning (same logic as main updateTooltip)
                const handleLeft = (days / this.getTotalTimelineDays()) * track.offsetWidth;
                const tooltipWidth = tooltip.offsetWidth;
                const trackWidth = track.offsetWidth;
                
                // Calculate ideal tooltip position (centered on handle)
                const idealLeft = handleLeft - (tooltipWidth / 2);
                const minLeft = 0;
                const maxLeft = trackWidth - tooltipWidth;
                const wouldOverflow = idealLeft < minLeft || idealLeft > maxLeft;
                
                if (wouldOverflow) {
                    // Position tooltip at constrained position
                    tooltip.style.left = Math.max(minLeft, Math.min(maxLeft, idealLeft)) + 'px';
                    tooltip.style.transform = 'none'; // Remove CSS centering
                    
                    // Calculate triangle position relative to tooltip
                    const triangleOffset = handleLeft - Math.max(minLeft, Math.min(maxLeft, idealLeft));
                    const trianglePercent = (triangleOffset / tooltipWidth) * 100;
                    const constrainedTrianglePercent = Math.max(5, Math.min(95, trianglePercent));
                    
                    tooltip.style.setProperty('--triangle-left', constrainedTrianglePercent + '%');
                } else {
                    // Use CSS centering method when tooltip fits comfortably
                    tooltip.style.left = handleLeft + 'px';
                    tooltip.style.transform = 'translateX(-50%)';
                    
                    tooltip.style.setProperty('--triangle-left', '50%');
                }
            }

            updateTooltip(days, currentDate) {
                const tooltip = document.getElementById('timelineTooltip');
                const tooltipDate = document.getElementById('tooltipDate');
                const tooltipAlive = document.getElementById('tooltipAlive');
                const slider = document.getElementById('timelineSlider');
                const track = document.querySelector('.timeline-track');
                
                // Header info elements
                const selectedDateEl = document.getElementById('selectedDate');
                const selectedDateInTitleEl = document.getElementById('selectedDateInTitle');
                const lastEventEl = document.getElementById('lastEvent');
                const aliveCountEl = document.getElementById('aliveCount');
                const fallenCountEl = document.getElementById('fallenCount');
                
                if (!tooltip || !tooltipDate || !tooltipAlive || !slider || !this.soldiers || !track) {
                    return; // Elements or data not ready yet
                }
                
                // Format date as dd/mm/yy
                const day = currentDate.getDate().toString().padStart(2, '0');
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const year = currentDate.getFullYear().toString().slice(-2);
                const formattedDate = `${day}/${month}/${year}`;
                
                // Calculate alive and fallen soldiers count based on current timeline position
                // Alive = soldiers who died after the current date (would still be alive at currentDate)
                const aliveSoldiers = this.soldiers.filter(s => 
                    s.death_date > currentDate
                ).length;
                
                // Fallen = soldiers who died on or before the current date (since war start)
                const fallenSoldiers = this.soldiers.filter(s => 
                    s.death_date >= this.startDate && 
                    s.death_date <= currentDate
                ).length;
                
                // Update header info
                if (selectedDateEl) {
                    selectedDateEl.textContent = formattedDate;
                }
                
                // Update date in title
                if (selectedDateInTitleEl) {
                    selectedDateInTitleEl.textContent = formattedDate;
                }
                
                // Find the last timeline event before or on the current date
                const lastEvent = this.timelineEvents
                    .filter(event => event.eventDate <= currentDate)
                    .sort((a, b) => b.eventDate - a.eventDate)[0];
                    
                if (lastEventEl && lastEvent) {
                    lastEventEl.textContent = lastEvent.title_hebrew;
                }
                
                // Update timeline description - ONLY when NOT animating
                const timelineDescriptionEl = document.getElementById('timelineDescription');
                if (timelineDescriptionEl && !this.isTimelineAnimating) {
                    // Only update description when timeline is not animating
                    const currentSliderValue = parseInt(document.getElementById('timelineSlider').value);
                    const sliderDate = new Date(this.todayDate);
                    sliderDate.setDate(sliderDate.getDate() - currentSliderValue);
                    const eventAtSliderDate = this.getEventAtDate(sliderDate);
                    
                    console.log('🔧 DEBUG: Updating description - NOT animating');
                    console.log('🔧 DEBUG: currentSliderValue:', currentSliderValue);
                    console.log('🔧 DEBUG: todayDate:', this.todayDate.toDateString());
                    console.log('🔧 DEBUG: sliderDate calculation:', sliderDate.toDateString());
                    console.log('🔧 DEBUG: eventAtSliderDate:', eventAtSliderDate ? eventAtSliderDate.title_hebrew : 'none');
                    
                    if (eventAtSliderDate) {
                        // Show event at slider position
                        this.updateTimelineDescription(eventAtSliderDate, false);
                    } else {
                        // No event at slider position - hide
                        this.updateTimelineDescription(null);
                    }
                } else if (timelineDescriptionEl && this.isTimelineAnimating) {
                    console.log('🔧 DEBUG: Skipping description update - timeline is animating');
                }
                
                // Update mobile status components
                if (aliveCountEl) {
                    aliveCountEl.textContent = `${aliveSoldiers} היו יכולים להיות חיים היום`;
                }
                
                if (fallenCountEl) {
                    fallenCountEl.textContent = `${fallenSoldiers} חללים מאז תחילת התמרון`;
                }

                // Update desktop status components  
                const desktopAliveCountEl = document.getElementById('desktopAliveCount');
                const desktopFallenCountEl = document.getElementById('desktopFallenCount');
                
                if (desktopAliveCountEl) {
                    desktopAliveCountEl.textContent = `${aliveSoldiers} היו יכולים להיות חיים היום`;
                }
                
                if (desktopFallenCountEl) {
                    desktopFallenCountEl.textContent = `${fallenSoldiers} חללים מאז תחילת התמרון`;
                }
                
                // Hide mobile status components when their value is 0
                const aliveStatusComponent = document.querySelector('.status-components-container .alive-status');
                const fallenStatusComponent = document.querySelector('.status-components-container .fallen-status');
                
                if (aliveStatusComponent) {
                    aliveStatusComponent.style.display = aliveSoldiers === 0 ? 'none' : 'block';
                }
                
                if (fallenStatusComponent) {
                    fallenStatusComponent.style.display = fallenSoldiers === 0 ? 'none' : 'block';
                }

                // Hide desktop status components when their value is 0
                const desktopAliveStatusComponent = document.querySelector('.desktop-status-components-container .alive-status');
                const desktopFallenStatusComponent = document.querySelector('.desktop-status-components-container .fallen-status');
                
                if (desktopAliveStatusComponent) {
                    desktopAliveStatusComponent.style.display = aliveSoldiers === 0 ? 'none' : 'block';
                }
                
                if (desktopFallenStatusComponent) {
                    desktopFallenStatusComponent.style.display = fallenSoldiers === 0 ? 'none' : 'block';
                }
                
                // Check if slider is over a timeline event (when STOPPED, not transitioning)
                // Use slider position, not hover position, for tooltip event detection
                const currentSliderValue = parseInt(slider.value);
                const sliderDate = new Date(this.todayDate);
                sliderDate.setDate(sliderDate.getDate() - currentSliderValue);
                const eventAtSliderDate = this.getEventAtDate(sliderDate);
                const isStoppedOverEvent = eventAtSliderDate && !this.isTimelineAnimating;
                
                if (isStoppedOverEvent) {
                    // Show event details in tooltip
                    const titleLink = eventAtSliderDate.source && eventAtSliderDate.source.startsWith('http')
                        ? `<a href="${eventAtSliderDate.source}" target="_blank" style="color: #333; text-decoration: none; cursor: pointer; font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">${eventAtSliderDate.title_hebrew}</a>`
                        : `<span style="color: #333; font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">${eventAtSliderDate.title_hebrew}</span>`;
                    tooltipDate.innerHTML = titleLink;
                    tooltipAlive.innerHTML = `
                        <div style="padding-top: 6px; font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">
                            ${formattedDate}<br>היו יכולים להיות חיים היום: ${aliveSoldiers}
                        </div>
                    `;
                } else {
                    // Regular tooltip content
                    tooltipDate.textContent = formattedDate;
                    tooltipAlive.innerHTML = `<div style="font-family: 'Heebo', sans-serif; font-weight: 300; font-size: 13px;">היו יכולים להיות חיים היום: ${aliveSoldiers}</div>`;
                }
                
                // Calculate positioning immediately for smooth animation
                // Force layout refresh first to ensure content dimensions are current
                tooltip.offsetWidth; // Force layout recalculation
                
                // Calculate handle position
                const sliderValue = parseInt(slider.value);
                const totalDays = this.getTotalTimelineDays();
                const handlePercent = (sliderValue / totalDays) * 100;
                
                // Get tooltip dimensions (already rendered after forced layout)
                const tooltipWidth = tooltip.offsetWidth;
                const trackWidth = track.offsetWidth;
                
                // Calculate handle pixel position
                const handleLeft = (handlePercent / 100) * trackWidth;
                
                // Calculate ideal tooltip position (centered on handle)
                const idealLeft = handleLeft - (tooltipWidth / 2);
                
                // Check if tooltip would overflow track bounds
                const minLeft = 0;
                const maxLeft = trackWidth - tooltipWidth;
                const wouldOverflow = idealLeft < minLeft || idealLeft > maxLeft;
                
                // Control triangle transition based on animation state
                const afterElement = tooltip;
                if (this.isTimelineAnimating) {
                    // Disable transitions during animation for immediate response
                    afterElement.style.setProperty('--triangle-transition', 'none');
                } else {
                    // Enable smooth transitions for static interactions
                    afterElement.style.setProperty('--triangle-transition', 'left 0.1s ease');
                }
                
                if (wouldOverflow) {
                    // Use constrained positioning with dynamic triangle
                    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, idealLeft));
                    
                    // Position tooltip at constrained position
                    tooltip.style.left = constrainedLeft + 'px';
                    tooltip.style.transform = 'none'; // Remove CSS centering
                    
                    // Calculate triangle position relative to tooltip
                    const triangleOffset = handleLeft - constrainedLeft;
                    const trianglePercent = (triangleOffset / tooltipWidth) * 100;
                    
                    // Constrain triangle within reasonable bounds (5% to 95%)
                    const constrainedTrianglePercent = Math.max(5, Math.min(95, trianglePercent));
                    tooltip.style.setProperty('--triangle-left', constrainedTrianglePercent + '%');
                } else {
                    // Use CSS centering method when tooltip fits comfortably
                    tooltip.style.left = handleLeft + 'px';
                    tooltip.style.transform = 'translateX(-50%)';
                    
                    // With CSS centering, triangle should be centered (50%)
                    tooltip.style.setProperty('--triangle-left', '50%');
                }
                
                // Update handle color based on timeline state
                this.updateHandleColor(currentDate);
            }

            updateHandleColor(currentDate) {
                const slider = document.getElementById('timelineSlider');
                if (!slider || !currentDate) return;
                
                // Determine color based on timeline state
                let handleColor;
                let borderColor = '#fff';
                
                // Check if current date exactly matches a timeline event
                const eventAtCurrentDate = this.getEventAtDate(currentDate);
                
                if (eventAtCurrentDate) {
                    // On an event date - use the same color system as timeline markers
                    const isMilitaryCategory = eventAtCurrentDate.category === 'military' || 
                                              eventAtCurrentDate.category === 'military_withdrawal' || 
                                              eventAtCurrentDate.category === 'military_operation';
                    
                    const isPoliticalCategory = eventAtCurrentDate.category === 'coalition_threat' ||
                                               eventAtCurrentDate.category === 'extremist_statement' ||
                                               eventAtCurrentDate.category === 'political_admission' ||
                                               eventAtCurrentDate.category === 'coalition_departure' ||
                                               eventAtCurrentDate.category === 'political_manipulation';
                    
                    if (eventAtCurrentDate.could_have_ended === 'yes' || eventAtCurrentDate.could_have_ended === 'ended_war') {
                        // Blue for war-ending events
                        handleColor = 'linear-gradient(135deg, #1168FF 0%, #4488FF 100%)';
                    } else if (isMilitaryCategory) {
                        // Black for military events
                        handleColor = 'linear-gradient(135deg, #000000 0%, #333333 100%)';
                    } else if (isPoliticalCategory) {
                        // Orange for political events
                        handleColor = 'linear-gradient(135deg, #FF8800 0%, #FFAA33 100%)';
                    } else {
                        // Default blue for other diplomatic events
                        handleColor = 'linear-gradient(135deg, #1168FF 0%, #4488FF 100%)';
                    }
                } else {
                    // Not on any event - always use gray
                    handleColor = 'linear-gradient(135deg, #333 0%, #555 100%)';
                }
                
                // Apply the color using CSS custom properties
                slider.style.setProperty('--handle-background', handleColor);
                slider.style.setProperty('--handle-border', `2px solid ${borderColor}`);
            }

            escapeHtml(text) {
                return text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;');
            }

            renderAllNames() {
                const container = document.getElementById('namesContainer');
                
                // Filter soldiers who died after Oct 27, 2023
                const relevantSoldiers = this.soldiers.filter(s => s.death_date >= this.startDate);
                
                if (relevantSoldiers.length === 0) {
                    container.innerHTML = '<div class="loading">No memorial data found</div>';
                    return;
                }

                // Sort by death date
                relevantSoldiers.sort((a, b) => a.death_date - b.death_date);

                const namesHtml = relevantSoldiers.map(soldier => {
                    return `<div class="soldier-name" data-death-date="${soldier.death_date.getTime()}" data-rank="${this.escapeHtml(soldier.rank)}" data-unit="${this.escapeHtml(soldier.unit)}" data-image-url="${soldier.image_url || ''}">${soldier.name}</div>`;
                }).join('');

                container.innerHTML = namesHtml;
                
                // Setup custom tooltips for soldier names
                this.setupSoldierTooltips();
                
                // Initialize tooltip now that data is loaded
                this.updateTooltip(0, this.todayDate);
                
                // Wait for DOM to settle then calculate optimal font size with buffer
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(relevantSoldiers.length, availableWidth, availableHeight);
                    }
                }, 50);
            }

            setupSoldierTooltips() {
                // Completely disable tooltips on mobile
                if (this.isMobile) {
                    window.autoHoverSystem = { active: false, start: () => {}, stop: () => {} };
                    return; // Don't setup any tooltip functionality on mobile
                }
                
                const soldierNames = document.querySelectorAll('.soldier-name');
                const tooltip = document.getElementById('soldierTooltip');
                const soldierNameEl = document.getElementById('soldierName');
                const soldierDetailsEl = document.getElementById('soldierDetails');
                const soldierPhotoEl = document.getElementById('soldierPhoto');
                const soldierImageEl = document.getElementById('soldierImage');
                let currentSoldierName = null;
                
                // Auto-hover system for current_date narrative
                // Capture 'this' context for use in autoHoverSystem
                const timelineInstance = this;
                
                // Make autoHoverSystem globally accessible for timeline updates
                window.autoHoverSystem = {
                    active: false,
                    intervals: [],
                    activeElements: new Map(), // Track active elements and their tooltip elements
                    maxSimultaneous: 4,
                    tooltipCounter: 0, // For unique IDs
                    
                    // Check if ALL visible soldiers on screen are in fallen state
                    shouldActivateAutoHover: () => {
                        const soldierNames = document.querySelectorAll('.soldier-name');
                        if (soldierNames.length === 0) {
                            console.log('DEBUG: No soldier names found on screen');
                            return false;
                        }
                        
                        let totalVisible = 0;
                        let fallenVisible = 0;
                        let aliveVisible = 0;
                        let samples = [];
                        
                        soldierNames.forEach((nameEl, index) => {
                            totalVisible++;
                            const classes = Array.from(nameEl.classList);
                            
                            if (nameEl.classList.contains('fallen')) {
                                fallenVisible++;
                            } else if (nameEl.classList.contains('alive')) {
                                aliveVisible++;
                            }
                            
                            // Sample first 5 for debugging
                            if (index < 5) {
                                samples.push({
                                    name: nameEl.textContent.substring(0, 20),
                                    classes: classes
                                });
                            }
                        });
                        
                        const allAreFallen = (fallenVisible === totalVisible) && (aliveVisible === 0);
                        
                        // Only log when state changes or for debugging
                        if (!allAreFallen && aliveVisible > 0) {
                            console.log(`Auto-hover check: ${aliveVisible} soldiers still alive - BLOCKED`);
                        } else if (allAreFallen) {
                            console.log(`Auto-hover check: All ${totalVisible} soldiers fallen - ACTIVE`);
                        }
                        
                        return allAreFallen;
                    },
                    
                    start: () => {
                        console.log('=== AUTO-HOVER START CALLED ===');
                        
                        if (window.autoHoverSystem.active) {
                            console.log('Auto-hover already active, returning');
                            return;
                        }
                        
                        // SIMPLE CHECK: only start if ALL visible soldiers are fallen
                        const shouldActivate = window.autoHoverSystem.shouldActivateAutoHover();
                        if (!shouldActivate) {
                            console.log('🚫 AUTO-HOVER BLOCKED - Not all soldiers are fallen yet');
                            return;
                        }
                        
                        console.log('✅ AUTO-HOVER STARTING - All soldiers are fallen');
                        window.autoHoverSystem.active = true;
                        window.autoHoverSystem.scheduleNext();
                    },
                    
                    stop: () => {
                        window.autoHoverSystem.active = false;
                        window.autoHoverSystem.intervals.forEach(id => clearTimeout(id));
                        window.autoHoverSystem.intervals = [];
                        
                        // Clear all active elements and their tooltips
                        window.autoHoverSystem.activeElements.forEach((data, nameEl) => {
                            nameEl.classList.remove('auto-hover-active');
                            clearTimeout(data.hideTimeout);
                            // Remove the tooltip element
                            if (data.tooltipElement && data.tooltipElement.parentNode) {
                                data.tooltipElement.remove();
                            }
                        });
                        window.autoHoverSystem.activeElements.clear();
                        
                        // Hide main tooltip if showing
                        tooltip.classList.remove('visible');
                    },
                    
                    scheduleNext: () => {
                        if (!window.autoHoverSystem.active) return;
                        
                        // CHECK EVERY TIME: Stop if not all soldiers are fallen anymore
                        if (!window.autoHoverSystem.shouldActivateAutoHover()) {
                            console.log('🛑 AUTO-HOVER STOPPING - Some soldiers are alive now');
                            window.autoHoverSystem.stop();
                            return;
                        }
                        
                        // Original behavior: 0.5-2 second delay between tooltips
                        const delay = Math.random() * 1500 + 500;
                        const timeoutId = setTimeout(() => {
                            // Check again before showing tooltip
                            if (!window.autoHoverSystem.shouldActivateAutoHover()) {
                                console.log('🛑 AUTO-HOVER STOPPING - Some soldiers are alive now');
                                window.autoHoverSystem.stop();
                                return;
                            }
                            
                            if (window.autoHoverSystem.activeElements.size < window.autoHoverSystem.maxSimultaneous) {
                                window.autoHoverSystem.showRandomTooltip();
                            }
                            window.autoHoverSystem.scheduleNext(); // Schedule the next one
                        }, delay);
                        
                        window.autoHoverSystem.intervals.push(timeoutId);
                    },
                    
                    showRandomTooltip: () => {
                        if (!window.autoHoverSystem.active) return;
                        
                        // Get available soldier names (only fallen soldiers, not currently active)
                        const availableNames = Array.from(soldierNames).filter(nameEl => 
                            !window.autoHoverSystem.activeElements.has(nameEl) &&
                            !nameEl.classList.contains('alive')
                        );
                        
                        if (availableNames.length === 0) return;
                        
                        // Pick a random soldier name
                        const randomName = availableNames[Math.floor(Math.random() * availableNames.length)];
                        const duration = Math.random() * 1000 + 3000; // 4-5 seconds
                        
                        // Create unique tooltip element for this soldier
                        const tooltipId = `autoTooltip${window.autoHoverSystem.tooltipCounter++}`;
                        const newTooltip = window.autoHoverSystem.createTooltipElement(tooltipId);
                        
                        // Schedule hide with proper timeout tracking
                        const hideTimeoutId = setTimeout(() => {
                            window.autoHoverSystem.simulateHover(randomName, false);
                            window.autoHoverSystem.activeElements.delete(randomName);
                        }, duration);
                        
                        // Track this element as active with its tooltip
                        window.autoHoverSystem.activeElements.set(randomName, { 
                            hideTimeout: hideTimeoutId,
                            tooltipElement: newTooltip
                        });
                        
                        // Show tooltip
                        window.autoHoverSystem.simulateHover(randomName, true);
                    },
                    
                    createTooltipElement: (tooltipId) => {
                        const newTooltip = document.createElement('div');
                        newTooltip.id = tooltipId;
                        newTooltip.className = 'soldier-tooltip';
                        newTooltip.innerHTML = `
                            <div class="soldier-photo" style="display: none;">
                                <div class="image-placeholder" style="width: 120px; height: 160px; background: #f0f0f0; border-radius: 3px; position: relative; overflow: hidden;">
                                    <img class="soldier-image" style="width: 100%; height: 100%; object-fit: cover; object-position: center top; border-radius: 3px; opacity: 0; transition: opacity 1.5s ease; position: absolute; top: 0; left: 0; filter: saturate(0.6) brightness(1.35) opacity(0.85);">
                                </div>
                            </div>
                            <div class="soldier-text">
                                <strong class="soldier-name-text"></strong>
                                <div class="soldier-details-text"></div>
                            </div>
                        `;
                        document.body.appendChild(newTooltip);
                        return newTooltip;
                    },
                    
                    simulateHover: (nameEl, show) => {
                        const data = window.autoHoverSystem.activeElements.get(nameEl);
                        if (!data) return;
                        
                        if (show) {
                            // Add visual hover state to the name element
                            nameEl.classList.add('auto-hover-active');
                            
                            // Show tooltip for this soldier immediately
                            const rect = nameEl.getBoundingClientRect();
                            const mouseEvent = { 
                                clientX: rect.left + rect.width/2, 
                                clientY: rect.top + rect.height/2 
                            };
                            window.autoHoverSystem.showTooltipForElement(nameEl, mouseEvent, data.tooltipElement);
                        } else {
                            // Remove visual hover state from name element
                            nameEl.classList.remove('auto-hover-active');
                            
                            // Hide this specific tooltip with transition
                            if (data.tooltipElement) {
                                data.tooltipElement.classList.remove('visible');
                                // Remove tooltip element after transition completes
                                setTimeout(() => {
                                    if (data.tooltipElement && data.tooltipElement.parentNode) {
                                        data.tooltipElement.remove();
                                    }
                                }, 200); // Match the 0.2s disappear transition
                            }
                        }
                    },
                    
                    showTooltipForElement: (nameEl, mouseEvent, tooltipElement) => {
                        const name = nameEl.textContent;
                        const rank = nameEl.dataset.rank;
                        const unit = nameEl.dataset.unit;
                        const imageUrl = nameEl.dataset.imageUrl;
                        const deathDate = new Date(parseInt(nameEl.dataset.deathDate));
                        
                        // Get tooltip sub-elements
                        const tooltipNameEl = tooltipElement.querySelector('.soldier-name-text');
                        const tooltipDetailsEl = tooltipElement.querySelector('.soldier-details-text');
                        const tooltipPhotoEl = tooltipElement.querySelector('.soldier-photo');
                        const tooltipImageEl = tooltipElement.querySelector('.soldier-image');
                        
                        // Same tooltip logic as manual hover
                        const formattedDate = deathDate.toLocaleDateString('he-IL');
                        tooltipNameEl.textContent = name;
                        tooltipDetailsEl.innerHTML = `
                            <div>${unit}</div>
                            <div style="opacity: 0.8;">נפל ${formattedDate}</div>
                        `;
                        
                        // Clear and load image
                        tooltipImageEl.style.opacity = '0';
                        tooltipImageEl.src = '';
                        
                        if (imageUrl && imageUrl.trim()) {
                            tooltipPhotoEl.style.display = 'block';
                            tooltipImageEl.onload = () => {
                                tooltipImageEl.style.opacity = '1';
                            };
                            tooltipImageEl.onerror = () => {
                                tooltipPhotoEl.style.display = 'none';
                            };
                            tooltipImageEl.src = imageUrl;
                        } else {
                            tooltipPhotoEl.style.display = 'none';
                        }
                        
                        // Apply styling and positioning
                        const tiltAngle = (Math.random() - 0.5) * 12;
                        tooltipElement.style.setProperty('--tilt-angle', `${tiltAngle}deg`);
                        
                        // Add fallen/alive class to tooltip based on soldier state
                        tooltipElement.classList.remove('fallen', 'alive');
                        if (nameEl.classList.contains('fallen')) {
                            tooltipElement.classList.add('fallen');
                        } else if (nameEl.classList.contains('alive')) {
                            tooltipElement.classList.add('alive');
                        }
                        
                        // Special current_date styling
                        tooltipElement.style.background = 'rgba(255, 245, 200, 0.98)';
                        tooltipElement.style.borderColor = 'rgba(255, 200, 100, 0.3)';
                        tooltipElement.style.boxShadow = '0 6px 16px rgba(255, 150, 50, 0.3)';
                        
                        // Position and show
                        this.positionSoldierTooltip(mouseEvent, tooltipElement, nameEl);
                        tooltipElement.classList.add('visible');
                    }
                };
                
                // Check if we're on the current_date narrative point for special tooltip behavior
                const isCurrentDateNarrative = () => {
                    return this.narrative && this.narrative.currentPointId === 'current_date';
                };
                
                // Start/stop auto-hover based on narrative point
                const updateAutoHover = () => {
                    console.log(`UpdateAutoHover called - isCurrentDate: ${isCurrentDateNarrative()}`);
                    if (isCurrentDateNarrative()) {
                        window.autoHoverSystem.start();
                    } else {
                        window.autoHoverSystem.stop();
                    }
                };
                
                // Initial check and setup observer for narrative changes
                setTimeout(updateAutoHover, 1000); // Give narrative time to initialize
                
                // Watch for narrative changes
                const originalNavigateToPoint = this.narrative.navigateToPoint;
                this.narrative.navigateToPoint = function(pointId) {
                    const result = originalNavigateToPoint.call(this, pointId);
                    setTimeout(updateAutoHover, 100); // Update auto-hover after navigation
                    return result;
                };
                
                soldierNames.forEach(nameEl => {
                    let hoverTimeout = null;
                    
                    nameEl.addEventListener('mouseenter', (e) => {
                        // Clear any existing timeout
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                        }
                        
                        // Set delay before showing tooltip - very fast and responsive
                        const delay = 100; // Almost immediate for all cases
                        console.log(`Manual hover delay: ${delay}ms`);
                        hoverTimeout = setTimeout(() => {
                            const name = nameEl.textContent;
                            const rank = nameEl.dataset.rank;
                            const unit = nameEl.dataset.unit;
                            const imageUrl = nameEl.dataset.imageUrl;
                            const deathDate = new Date(parseInt(nameEl.dataset.deathDate));
                            
                            // Format date in Hebrew style
                            const formattedDate = deathDate.toLocaleDateString('he-IL');
                            
                            // Update tooltip content (compact format)
                            soldierNameEl.textContent = name;
                            soldierDetailsEl.innerHTML = `
                                <div>${unit}</div>
                                <div style="opacity: 0.8;">נפל ${formattedDate}</div>
                            `;
                            
                            // IMMEDIATELY clear any previous image to prevent flickering
                            soldierImageEl.style.opacity = '0';
                            soldierImageEl.src = '';
                            currentSoldierName = name;
                            
                            // Handle image with fade-in animation
                            if (imageUrl && imageUrl.trim()) {
                                // console.log('Attempting to load image for', name, 'URL:', imageUrl);
                                
                                // Show container after clearing previous image
                                soldierPhotoEl.style.display = 'block';
                                
                                // Set up load handler for fade-in animation
                                soldierImageEl.onload = () => {
                                    // console.log('Image loaded successfully for', name);
                                    // Only fade in if this is still the current soldier being displayed
                                    if (currentSoldierName === name) {
                                        soldierImageEl.style.opacity = '1';
                                    }
                                };
                                
                                // Add error handler to hide image if it fails to load
                                soldierImageEl.onerror = () => {
                                    // console.log('Image failed to load for', name);
                                    soldierPhotoEl.style.display = 'none';
                                };
                                
                                // Set the image source to trigger loading
                                soldierImageEl.src = imageUrl;
                            } else {
                                soldierPhotoEl.style.display = 'none';
                            }
                            
                            // Apply random subtle tilt via CSS custom property
                            const tiltAngle = (Math.random() - 0.5) * 12; // Random tilt between -6° and +6°
                            tooltip.style.setProperty('--tilt-angle', `${tiltAngle}deg`);
                            
                            // Add fallen/alive class to tooltip based on soldier state
                            tooltip.classList.remove('fallen', 'alive');
                            if (nameEl.classList.contains('fallen')) {
                                tooltip.classList.add('fallen');
                            } else if (nameEl.classList.contains('alive')) {
                                tooltip.classList.add('alive');
                            }
                            
                            // Apply special styling for current_date narrative
                            if (isCurrentDateNarrative()) {
                                tooltip.style.background = 'rgba(255, 245, 200, 0.98)'; // Warm yellow tint
                                tooltip.style.borderColor = 'rgba(255, 200, 100, 0.3)';
                                tooltip.style.boxShadow = '0 6px 16px rgba(255, 150, 50, 0.3)';
                            } else {
                                // Reset to normal styling
                                tooltip.style.background = '';
                                tooltip.style.borderColor = '';
                                tooltip.style.boxShadow = '';
                            }
                            
                            // Position tooltip relative to the name element
                            this.positionSoldierTooltip(e, tooltip, nameEl);
                            
                            // Show tooltip
                            tooltip.classList.add('visible');
                        }, delay); // Dynamic delay based on narrative point
                    });
                    
                    nameEl.addEventListener('mouseleave', () => {
                        // Clear timeout if user leaves before delay completes
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                            hoverTimeout = null;
                        }
                        
                        // Hide tooltip in its current tilted position - don't change rotation
                        tooltip.classList.remove('visible');
                    });
                    
                    nameEl.addEventListener('mousemove', (e) => {
                        if (tooltip.classList.contains('visible')) {
                            this.positionSoldierTooltip(e, tooltip, nameEl);
                        }
                    });
                });
            }

            positionSoldierTooltip(mouseEvent, tooltip, nameElement) {
                const nameRect = nameElement.getBoundingClientRect();
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                const offset = 15; // Distance from name element
                let x, y;
                
                // Determine if name is on right or left side of screen
                const nameCenterX = nameRect.left + (nameRect.width / 2);
                const isOnRightSide = nameCenterX > screenWidth / 2;
                
                if (isOnRightSide) {
                    // Position tooltip to the LEFT of the name
                    x = nameRect.left - tooltipWidth - offset;
                    // If it would go off left edge, show on right instead
                    if (x < 10) {
                        x = nameRect.right + offset;
                    }
                } else {
                    // Position tooltip to the RIGHT of the name
                    x = nameRect.right + offset;
                    // If it would go off right edge, show on left instead
                    if (x + tooltipWidth > screenWidth - 10) {
                        x = nameRect.left - tooltipWidth - offset;
                    }
                }
                
                // Center tooltip vertically around name element
                y = nameRect.top + (nameRect.height / 2) - (tooltipHeight / 2);
                
                // Ensure tooltip stays within screen bounds vertically
                if (y < 10) {
                    y = 10;
                } else if (y + tooltipHeight > screenHeight - 10) {
                    y = screenHeight - tooltipHeight - 10;
                }
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            applySafeFontSize() {
                // console.log('Applying safe fixed font size');
                const soldierNames = document.querySelectorAll('.soldier-name');
                const isMobile = window.innerWidth <= 768;
                const safeFontSize = isMobile ? 4 : 7; // Smaller minimum on mobile
                
                soldierNames.forEach(name => {
                    name.style.fontSize = safeFontSize + 'px';
                });
                
                // console.log(`Applied safe font size: ${safeFontSize}px to ${soldierNames.length} names`);
                
                // Verify it works
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const isOverflowing = container.scrollHeight > container.clientHeight;
                    // console.log(`Safe font check - overflowing: ${isOverflowing}, scrollHeight: ${container.scrollHeight}, clientHeight: ${container.clientHeight}`);
                }, 100);
            }

            calculateOptimalFontSize(totalNames) {
                // This function is now deprecated - redirect to the proper calculation
                const container = document.getElementById('namesContainer');
                // console.log('calculateOptimalFontSize called - redirecting to performFontSizeCalculation');
                
                setTimeout(() => {
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    if (availableWidth > 0 && availableHeight > 0) {
                        this.performFontSizeCalculation(totalNames, availableWidth, availableHeight);
                    }
                }, 50);
            }
            
            debugOverflow(container, soldierNames, checkNumber) {
                const isOverflowing = container.scrollHeight > container.clientHeight;
                // console.log(`\n--- OVERFLOW CHECK ${checkNumber} ---`);
                // console.log(`Container scrollHeight: ${container.scrollHeight}px`);
                // console.log(`Container clientHeight: ${container.clientHeight}px`);
                // console.log(`Is overflowing: ${isOverflowing}`);
                // console.log(`Overflow amount: ${container.scrollHeight - container.clientHeight}px`);
                
                // Check last visible elements
                const containerRect = container.getBoundingClientRect();
                let lastVisibleIndex = -1;
                
                soldierNames.forEach((name, index) => {
                    const rect = name.getBoundingClientRect();
                    if (rect.bottom <= containerRect.bottom && rect.top >= containerRect.top) {
                        lastVisibleIndex = index;
                    }
                });
                
                // console.log(`Last visible name index: ${lastVisibleIndex} out of ${soldierNames.length}`);
                // console.log(`Names potentially hidden: ${soldierNames.length - lastVisibleIndex - 1}`);
                
                // Show details of names around the cutoff
                for (let i = Math.max(0, lastVisibleIndex - 2); i < Math.min(soldierNames.length, lastVisibleIndex + 10); i++) {
                    const name = soldierNames[i];
                    const rect = name.getBoundingClientRect();
                    const isVisible = rect.bottom <= containerRect.bottom && rect.top >= containerRect.top;
                    // console.log(`[${i}] "${name.textContent.substring(0, 15)}..." visible: ${isVisible}, bottom: ${rect.bottom}, container bottom: ${containerRect.bottom}`);
                }
                
                if (isOverflowing && checkNumber === 3) {
                    const isMobile = window.innerWidth <= 768;
                    const finalSize = isMobile ? '5px' : '9px';
                    // console.log(`\n!!! FINAL ATTEMPT - SETTING TO ${finalSize} !!!`);
                    soldierNames.forEach(name => {
                        name.style.fontSize = finalSize;
                    });
                }
            }

            performFontSizeCalculation(totalNames, availableWidth, availableHeight) {
                const soldierNames = document.querySelectorAll('.soldier-name');
                
                // console.log(`\n=== MATHEMATICAL FONT CALCULATION ===`);
                // console.log(`Names: ${totalNames}, Available: ${availableWidth}x${availableHeight}px`);
                
                // Use mathematical approach instead of trial-and-error
                const optimalFontSize = this.calculateOptimalFontSizeMathematically(
                    Array.from(soldierNames).map(el => el.textContent),
                    availableWidth,
                    availableHeight
                );
                
                // console.log(`Calculated optimal font size: ${optimalFontSize}px`);
                
                // Apply the calculated font size
                soldierNames.forEach(name => {
                    name.style.fontSize = optimalFontSize + 'px';
                });
                
                // Verify the result
                setTimeout(() => {
                    const container = document.getElementById('namesContainer');
                    const scrollHeight = container.scrollHeight;
                    const clientHeight = container.clientHeight;
                    const fillRatio = scrollHeight / clientHeight;
                    
                    console.log(`🔍 FILL RATIO DEBUG: scrollHeight=${scrollHeight}px, clientHeight=${clientHeight}px`);
                    console.log(`🔍 Fill ratio: ${(fillRatio * 100).toFixed(1)}% (target: 98%+)`);
                    console.log(`🔍 Original font size: ${optimalFontSize}px`);
                    
                    // FORCE larger font size to truly fill the space - ignore "perfect" 100% calculation
                    if (fillRatio <= 1.0) {
                        console.log('🚀 FORCING larger font size to fill visible empty space');
                        // Force increase font size by 6% when it thinks it's "perfect" but we see empty space (more conservative)
                        const correctedSize = optimalFontSize * 1.06;
                        console.log(`🔧 Force-increasing to ${correctedSize.toFixed(1)}px (8% increase)`);
                        soldierNames.forEach(name => {
                            name.style.fontSize = correctedSize + 'px';
                        });
                    } else if (fillRatio < 0.98) {
                        console.log('⚠️ Under-filled, increasing font size aggressively');
                        // Auto-increase font size much more aggressively to fill the space
                        const increaseFactor = Math.min(1.5, 0.98 / fillRatio); // Cap at 50% increase, target 98%
                        const correctedSize = optimalFontSize * increaseFactor;
                        console.log(`🔧 Auto-increasing to ${correctedSize.toFixed(1)}px (factor: ${increaseFactor.toFixed(2)})`);
                        soldierNames.forEach(name => {
                            name.style.fontSize = correctedSize + 'px';
                        });
                    } else if (fillRatio > 1.01) {
                        console.log('⚠️ Overflowing, need smaller font');
                        // Auto-correct if overflowing
                        const correctedSize = optimalFontSize * 0.95;
                        console.log(`🔧 Auto-correcting to ${correctedSize.toFixed(1)}px`);
                        soldierNames.forEach(name => {
                            name.style.fontSize = correctedSize + 'px';
                        });
                    } else {
                        // console.log('✅ Good fill ratio achieved');
                    }
                }, 100);
            }
            
            calculateOptimalFontSizeMathematically(names, availableWidth, availableHeight) {
                // Step 1: Analyze the actual content
                const totalCharacters = names.reduce((sum, name) => sum + name.length, 0);
                const avgNameLength = totalCharacters / names.length;
                
                // console.log(`Content analysis: ${totalCharacters} chars, avg ${avgNameLength.toFixed(1)} per name`);
                
                // Step 2: Font and layout constants (measured from Handjet font)
                const charWidthRatio = 0.55; // Character width relative to font size
                const lineHeight = 1.1; // From CSS
                const padding = 8; // 2px + 4px horizontal padding
                const gap = 3.3; // Gap between names
                
                // Step 3: Target fill ratio - aim to fill 95% of available space
                const targetFillRatio = 0.95;
                const targetHeight = availableHeight * targetFillRatio;
                
                // console.log(`Target height: ${targetHeight}px (${(targetFillRatio*100).toFixed(0)}% of ${availableHeight}px)`);
                
                // Step 4: Binary search for optimal font size (much more efficient than old method)
                let minFont = this.isMobile ? 6 : 8;
                let maxFont = this.isMobile ? Math.min(50, availableHeight / 8) : Math.min(200, availableHeight / 5);
                let bestFont = minFont;
                
                // console.log(`Binary search range: ${minFont}px - ${maxFont}px`);
                
                for (let iteration = 0; iteration < 20; iteration++) {
                    const testFont = (minFont + maxFont) / 2;
                    const predictedHeight = this.predictLayoutHeight(names, testFont, availableWidth, charWidthRatio, lineHeight, padding, gap);
                    
                    // console.log(`  Test ${testFont.toFixed(1)}px → height ${predictedHeight.toFixed(1)}px`);
                    
                    if (predictedHeight <= targetHeight) {
                        bestFont = testFont;
                        minFont = testFont;
                    } else {
                        maxFont = testFont;
                    }
                    
                    // Stop if we're close enough
                    if (maxFont - minFont < 0.5) break;
                }
                
                // console.log(`Binary search result: ${bestFont.toFixed(1)}px`);
                
                // Step 5: Ensure reasonable bounds
                return Math.max(8, Math.min(150, bestFont));
            }
            
            predictLayoutHeight(names, fontSize, containerWidth, charWidthRatio, lineHeight, padding, gap) {
                // Predict how tall the layout will be at a given font size
                let currentRowWidth = 0;
                let rowCount = 1;
                const effectiveWidth = containerWidth - 10; // Small margin for centering
                
                for (const name of names) {
                    const nameWidth = (name.length * fontSize * charWidthRatio) + padding;
                    
                    // Check if this name fits on current row
                    if (currentRowWidth > 0 && currentRowWidth + gap + nameWidth > effectiveWidth) {
                        // Start new row
                        rowCount++;
                        currentRowWidth = nameWidth;
                    } else {
                        // Add to current row
                        currentRowWidth += (currentRowWidth > 0 ? gap : 0) + nameWidth;
                    }
                }
                
                // Calculate total height
                const rowHeight = fontSize * lineHeight;
                const totalHeight = rowCount * rowHeight + (rowCount - 1) * gap;
                
                return totalHeight;
            }

            updateVisualization() {
                // Update all soldier name elements
                const soldierElements = document.querySelectorAll('.soldier-name');
                let aliveCount = 0;
                
                // console.log('updateVisualization called, currentEndDate:', this.currentEndDate);
                let dyingStarted = 0;
                
                // First pass: identify soldiers who should start dying
                const soldiersToStartDying = [];
                
                soldierElements.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    const previousState = this.soldierStates.get(elementId) || 'unknown';
                    
                    if (deathDate <= this.currentEndDate) {
                        // This soldier had already died by currentEndDate
                        if ((previousState === 'alive' || previousState === 'unknown') && !this.dyingTimeouts.has(elementId)) {
                            soldiersToStartDying.push(el);
                        }
                    }
                });
                
                // Second pass: start all dying animations simultaneously
                soldiersToStartDying.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    
                    el.className = 'soldier-name dying';
                    this.soldierStates.set(elementId, 'dying');
                    dyingStarted++;
                    
                    // console.log(`Started dying animation for soldier ${el.textContent} (${deathDate.toDateString()})`);
                    
                    // Set timeout to start fade transition after initial highlight
                    const timeoutId = setTimeout(() => {
                        if (el.classList.contains('dying')) {
                            // Start gradual fade by adding dying-fade class
                            el.className = 'soldier-name dying dying-fade';
                        }
                        
                        // Set final timeout to complete transition
                        const finalTimeoutId = setTimeout(() => {
                            if (el.classList.contains('dying-fade')) {
                                el.className = 'soldier-name fallen';
                                this.soldierStates.set(elementId, 'fallen');
                                
                                // Mobile auto-scroll to show most recent fallen soldier
                                if (this.isMobile) {
                                    this.scrollToMostRecentFallen(el);
                                }
                            }
                        }, 600); // Match CSS transition duration
                        
                        this.dyingTimeouts.delete(elementId);
                    }, 100); // Hold red highlight for 100ms
                    
                    this.dyingTimeouts.set(elementId, timeoutId);
                });
                
                // Third pass: handle all other states
                soldierElements.forEach(el => {
                    const deathDate = new Date(parseInt(el.dataset.deathDate));
                    const elementId = el.dataset.deathDate;
                    const wasAlive = el.classList.contains('alive');
                    const isDying = el.classList.contains('dying');
                    const wasFallen = el.classList.contains('fallen');
                    const previousState = this.soldierStates.get(elementId) || 'unknown';
                    
                    if (deathDate > this.currentEndDate) {
                        // This soldier would still be alive at currentEndDate
                        this.soldierStates.set(elementId, 'alive');
                        if (!wasAlive) {
                            // Clear any dying timeout if soldier comes back to life
                            if (this.dyingTimeouts.has(elementId)) {
                                clearTimeout(this.dyingTimeouts.get(elementId));
                                this.dyingTimeouts.delete(elementId);
                            }
                            el.className = 'soldier-name alive';
                            
                            // Mobile auto-scroll to show soldier becoming alive
                            if (this.isMobile && (previousState === 'fallen' || wasFallen)) {
                                this.scrollToMostRecentAlive(el);
                            }
                        }
                        aliveCount++;
                    } else {
                        // This soldier had already died by currentEndDate
                        if (isDying) {
                            // Currently dying, count as alive during highlight
                            aliveCount++;
                        } else if (!wasFallen && !isDying && previousState !== 'dying') {
                            // Should be fallen - handle case where soldier was never alive in this session
                            el.className = 'soldier-name fallen';
                            this.soldierStates.set(elementId, 'fallen');
                            
                            // Mobile auto-scroll to show most recent fallen soldier
                            if (this.isMobile && previousState === 'alive') {
                                this.scrollToMostRecentFallen(el);
                            }
                        }
                    }
                });
                
                // console.log('Alive count:', aliveCount, 'out of', soldierElements.length, '| Dying animations started:', dyingStarted);
                
                // Update count in draggable container - DISABLED to avoid conflicts with main updateTooltip function
                // const aliveCountSpan = document.getElementById('aliveCount');
                // if (aliveCountSpan) {
                //     aliveCountSpan.textContent = `${aliveCount} היו יכולים להיות חיים היום`;
                // }
                
                // Update narrative content to refresh placeholders
                if (this.narrative) {
                    this.narrative.updateNarrativeContent();
                }
                
                // Regenerate area chart with new split position
                this.generateAreaChart();
            }
        }

        // Modal functionality
        document.body.classList.add('modal-open'); // Add blur on page load
        
        // Populate modal with dynamic numbers once memorial is loaded
        setTimeout(() => {
            if (memorial.soldiers && memorial.startDate && memorial.todayDate) {
                // Calculate total soldiers killed since ground operation start
                const totalSoldiers = memorial.soldiers.filter(s => 
                    s.death_date >= memorial.startDate
                ).length;
                
                // Calculate months of fighting from start date to today
                const startDate = memorial.startDate;
                const todayDate = memorial.todayDate;
                const monthsDiff = Math.round((todayDate - startDate) / (1000 * 60 * 60 * 24 * 30.44)); // Average days per month
                
                // Update modal text
                document.getElementById('modalTotalSoldiers').textContent = totalSoldiers;
                document.getElementById('modalMonthsOfFighting').textContent = monthsDiff;
                
                // console.log('Modal populated:', totalSoldiers, 'soldiers over', monthsDiff, 'months');
            }
        }, 1000); // Wait for data to load
        
        document.getElementById('modalContinueBtn').addEventListener('click', function() {
            const overlay = document.getElementById('modalOverlay');
            document.body.classList.remove('modal-open'); // Remove blur
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 0.3s ease';
            
            // Animate timeline to the beginning quickly with ease-out
            const timelineSlider = document.getElementById('timelineSlider');
            if (timelineSlider) {
                const maxValue = parseInt(timelineSlider.max);
                let currentValue = parseInt(timelineSlider.value);
                
                // Animation to beginning with dramatic ease-out
                const duration = 2000; // 2 seconds
                const startTime = performance.now();
                
                function animateToBeginning(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Dramatic ease-out function (quintic for stronger deceleration)
                    const easeOut = 1 - Math.pow(1 - progress, 5);
                    
                    const newValue = currentValue + (maxValue - currentValue) * easeOut;
                    timelineSlider.value = newValue;
                    
                    // Trigger the timeline update
                    const event = new Event('input', { bubbles: true });
                    timelineSlider.dispatchEvent(event);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateToBeginning);
                    } else {
                        // Animation complete - trigger mobile scroll to show alive soldiers
                        if (memorial.isMobile) {
                            setTimeout(() => {
                                memorial.scrollToBeginning();
                            }, 100); // Small delay to ensure DOM updates are complete
                        }
                    }
                }
                
                requestAnimationFrame(animateToBeginning);
            }
            
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        });

        // Initialize the memorial
        const memorial = new TimelineMemorial();
        
        // Skip-back CTA functionality - jump to next visible event
        document.getElementById('ctaSkipBack').addEventListener('click', function() {
            if (!memorial.timelineEvents) return;
            
            // Get all visible events sorted by date (chronological order: past to future)
            const visibleEvents = memorial.timelineEvents
                .filter(event => event.show === 'show')
                .sort((a, b) => new Date(a.date) - new Date(b.date));
            
            console.log('Visible events:', visibleEvents.map(e => ({id: e.id, title: e.title_hebrew, date: e.date, show: e.show})));
            
            if (visibleEvents.length === 0) return;
            
            // Calculate current timeline position
            const timelineSlider = document.getElementById('timelineSlider');
            const currentSliderValue = parseInt(timelineSlider.value);
            const maxSliderValue = parseInt(timelineSlider.max);
            
            // console.log('Current slider value:', currentSliderValue);
            // console.log('War-ending events:', warEndingEvents.map(e => ({title: e.title_hebrew, days: e.days_from_start})));
            
            // Calculate current date from slider position (using same logic as timeline)
            const currentDaysBack = currentSliderValue;
            const currentDate = new Date(memorial.todayDate);
            currentDate.setDate(currentDate.getDate() - currentDaysBack);
            
            console.log('Current timeline date:', currentDate.toDateString());
            
            // Find the next event chronologically AFTER current position
            let nextEvent = visibleEvents.find(event => {
                console.log('Checking event:', event.title_hebrew, 'Date:', event.eventDate, 'After current?', event.eventDate > currentDate);
                return event.eventDate > currentDate;
            });
            
            // If no event found after current position, loop back to the first event
            if (!nextEvent) {
                console.log('No next event found, looping to first');
                nextEvent = visibleEvents[0];
            } else {
                console.log('Found next event:', nextEvent.title_hebrew);
            }
            
            console.log('Next event selected:', nextEvent.title_hebrew, 'at date:', nextEvent.eventDate);
            
            // Calculate target slider position using timezone-safe method
            const todayNormalized = new Date(memorial.todayDate);
            todayNormalized.setHours(12, 0, 0, 0);
            
            const eventNormalized = new Date(nextEvent.eventDate);
            eventNormalized.setHours(12, 0, 0, 0);
            
            const msPerDay = 1000 * 60 * 60 * 24;
            const daysBack = Math.round((todayNormalized - eventNormalized) / msPerDay);
            const totalDays = memorial.getTotalTimelineDays();
            const targetSliderValue = Math.max(0, Math.min(totalDays, daysBack));
            
            // Animate to the target position
            const startValue = currentSliderValue;
            const duration = 300; // 0.3 seconds (fast but smooth)
            const startTime = performance.now();
            
            function animateToEvent(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-out function for smooth deceleration
                const easeOut = 1 - Math.pow(1 - progress, 2);
                
                const newValue = startValue + (targetSliderValue - startValue) * easeOut;
                timelineSlider.value = newValue;
                
                // Trigger the timeline update
                const event = new Event('input', { bubbles: true });
                timelineSlider.dispatchEvent(event);
                
                if (progress < 1) {
                    requestAnimationFrame(animateToEvent);
                }
            }
            
            requestAnimationFrame(animateToEvent);
        });

        // Initialize Lucide icons on page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.lucide) {
                lucide.createIcons({
                    'skip-back': {
                        width: 16,
                        height: 16
                    }
                });
            }
        });
    </script>
</body>
</html>